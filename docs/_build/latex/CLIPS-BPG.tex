%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{CLIPS-BPG Documentation}
\date{Jul 06, 2020}
\release{}
\author{Kurt Pagani}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Section 1: Introduction}
\label{\detokenize{introduction:section-1-introduction}}\label{\detokenize{introduction::doc}}
This manual is the \sphinxstyleemphasis{Basic Programming Guide} for CLIPS. It is intended
for users interested in the syntax of CLIPS. No previous expert system
background is required, al?though a general understanding of computer
languages is assumed. Section 2 of this manual provides an overview of
the CLIPS language and basic terminology. Sections 3 through 11 provide
additional details regarding the CLIPS programming language on topics
such as rules and the CLIPS Object Oriented Programming Language (COOL).
The types of actions and functions provided by CLIPS are defined in
section 12. Finally, commands typically used from the CLIPS interactive
interface are described in section 13.

The \sphinxstyleemphasis{Basic Programming Guide} documents just the basic CLIPS syntax.
More advanced capabilities, such as user-defined functions, embedded
applications, etc., are docu?mented more fully in the \sphinxstyleemphasis{Advanced
Programming Guide}. The \sphinxstyleemphasis{Advanced Programming Guide} is intended for
users who have a complete knowledge of the CLIPS syntax and a
programming background. It is \sphinxstyleemphasis{not} necessary to read the \sphinxstyleemphasis{Advanced
Program?ming Guide} to learn how to use CLIPS. CLIPS can be learned and
simple expert systems can be built with the information provided in this
manual.


\chapter{Section 2: CLIPS Overview}
\label{\detokenize{overview:section-2-clips-overview}}\label{\detokenize{overview::doc}}
This section gives a general overview of CLIPS and of the basic concepts
used through?out this manual.


\section{2.1 Interacting with CLIPS}
\label{\detokenize{overview:interacting-with-clips}}
CLIPS expert systems may be executed in three ways: interactively using
a simple, text-oriented, command prompt interface; interactively using a
window/menu/mouse interface on certain ma?chines; or as embedded expert
systems in which the user provides a main pro?gram and controls
execution of the expert system. Embedded applications are dis?cussed in
the \sphinxstyleemphasis{Advanced Programming Guide}. In addition, a series of commands can
be automatically read di?rectly from a file when CLIPS is first started
or as the result of the \sphinxstylestrong{batch} command.

The generic CLIPS interface is a simple, interactive, text-oriented,
command prompt interface for high porta?bility. The stan?dard usage is
to create or edit a knowledge base using any standard text editor, save
the knowledge base as one or more text files, exit the editor and
execute CLIPS, then load the knowledge base into CLIPS. The in?terface
provides commands for viewing the current state of the sys?tem, tracing
execu?tion, adding or removing information, and clearing CLIPS.

A more sophisticated window interface is available for the Macintosh,
Windows 3.1, and X Window environments. All interface commands described
in this section are available in the window interfaces. These interfaces
are described in more detail in the \sphinxstyleemphasis{Interfaces Guide}.


\subsection{2.1.1 Top Level Commands}
\label{\detokenize{overview:top-level-commands}}
The primary method for interacting with CLIPS in a non-embedded
environment is through the CLIPS \sphinxstylestrong{command prompt} (or \sphinxstylestrong{top level}).
When the ?CLIPS\textgreater{}? prompt is printed, a command may be entered for
evaluation. Commands may be function calls, constructs, local or global
variables, or constants. If a function call is entered (see section
2.3.2), that function is evaluated and its return value is printed.
Function calls in CLIPS use a prefix notation?the operands to a function
always appear after the function name. Entering a construct definition
(see section 2.3.3) at the CLIPS prompt creates a new construct of the
appropriate type. Entering a global variable (see section 2.4.3) causes
the value of the global variable to be printed. Local variables can be
set at the command prompt using the bind function and retain their value
until a reset or clear command is issued. Entering a local variable at
the command prompt causes the value of the local variable to be printed.
Entering a constant (see section 2.3.1) at the top level causes the
constant to be printed (which is not very useful). For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS (V6.30 3/11/15)

CLIPS\PYGZgt{} (+ 3 4)

7

CLIPS\PYGZgt{} (defglobal ?*x\PYGZbs{}* = 3)

CLIPS\PYGZgt{} ?*x\PYGZbs{}*

3

CLIPS\PYGZgt{} red

red

CLIPS\PYGZgt{} (bind ?a 5)

5

CLIPS\PYGZgt{} (+ ?a 3)

8

CLIPS\PYGZgt{} (reset)

CLIPS\PYGZgt{} ?a

[EVALUATN1] Variable a is unbound

FALSE

CLIPS\PYGZgt{}
\end{sphinxVerbatim}

The previous example first called the addition function adding the
numbers 3 and 4 to yield the result 7. A global variable ?*x* was then
defined and given the value 3. The variable ?*x* was then entered at
the prompt and its value of 3 was returned. Finally the constant symbol
\sphinxstyleemphasis{red} was entered and was returned (since a constant evaluates to
itself).


\subsection{2.1.2 Automated Command Entry and Loading}
\label{\detokenize{overview:automated-command-entry-and-loading}}
Some operating systems allow additional arguments to be specified to a
program when it begins execution. When the CLIPS executable is started
under such an operating system, CLIPS can be made to automatically
execute a series of commands read directly from a file or to load
constructs from a file. The command-line syntax for starting CLIPS and
automatically reading commands or loading constructs from a file is as
follows:

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{clips} \PYG{o}{\PYGZlt{}}\PYG{n}{option}\PYG{o}{\PYGZgt{}}\PYG{o}{*}

\PYG{o}{\PYGZlt{}}\PYG{n}{option}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{n}{filename}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}

\PYG{o}{\PYGZhy{}}\PYG{n}{f2} \PYG{o}{\PYGZlt{}}\PYG{n}{filename}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}

\PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{o}{\PYGZlt{}}\PYG{n}{filename}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

For the \sphinxstylestrong{-f} option, \textless{}filename\textgreater{} is a file that contains CLIPS
commands. If the \sphinxstylestrong{exit} command is included in the file, CLIPS will
halt and the user is returned to the operat?ing system after executing
the commands in the file. If an \sphinxstylestrong{exit} command is not in the file,
CLIPS will enter in its interactive state after executing the commands
in the file. Commands in the file should be entered exactly as they
would be interactively (i.e. opening and closing parentheses must be
included and a carriage return must be at the end of the command). The
\sphinxstylestrong{-f} command line option is equivalent to interactively entering a
\sphinxstylestrong{batch} command as the first command to the CLIPS prompt.

The \sphinxstylestrong{-f2} option is similar to the \sphinxstylestrong{-f} option, but is equivalent to
interactively entering a \sphinxstylestrong{batch*} command. The commands stored in
\textless{}filename\textgreater{} are immediately executed, but the commands and their return
values are not displayed as they would be for a \sphinxstylestrong{batch} command.

For the \sphinxstylestrong{-l} option, \textless{}filename\textgreater{} should be a file containing CLIPS
constructs. This file will be loaded into the environment. The \sphinxstylestrong{-l}
command line option is equivalent to interactively entering a \sphinxstylestrong{load}
command.

Files specified using the \sphinxstylestrong{?f} option are not processed until the
command prompt appears, so these files will always be processed after
files specified using the \sphinxstylestrong{?f2} and \sphinxstylestrong{?l} options.


\subsection{2.1.3 Integration with Other Programming Languages}
\label{\detokenize{overview:integration-with-other-programming-languages}}
When using an expert system, two kinds of integration are important:
embedding CLIPS in other systems, and calling external functions from
CLIPS. CLIPS was designed to allow both kinds of integration.

Using CLIPS as an embedded application allows the easy integration of
CLIPS with existing systems. This is useful in cases where the expert
system is a small part of a larger task or needs to share data with
other functions. In these situations, CLIPS can be called as a
subroutine and information may be passed to and from CLIPS. Em?bedded
applications are discussed in the \sphinxstyleemphasis{Advanced Programming Guide}.

It also may be useful to call external functions while executing a CLIPS
construct or from the top-level of the interactive interface. CLIPS
variables or literal values may be passed to an external function, and
functions may return val?ues to CLIPS. The easy addition of external
functions allows CLIPS to be extended or customized in almost any way.
The \sphinxstyleemphasis{Advanced Programming Guide} describes how to integrate CLIPS with
functions or systems written in C as well as in other lan?guages.


\section{2.2 Reference Manual Syntax}
\label{\detokenize{overview:reference-manual-syntax}}
The terminology used throughout this manual to describe the CLIPS syntax
is fairly com?mon to computer reference manuals. Plain words or
characters, particularly paren?theses, are to be typed exactly as they
appear. Bolded words or characters, however, represent a verbal
description of what is to be entered. Sequences of words enclosed in
single-angle brackets (called terms or non-terminal symbols), such as
\textless{}string\textgreater{}, represent a single entity of the named class of items to be
supplied by the user. A non-terminal symbol followed by a *, represents
\sphinxstyleemphasis{zero or more} entities of the named class of items which must be
supplied by the user. A non-terminal symbol followed by a +, represents
\sphinxstyleemphasis{one or more} entities of the named class of items which must be
supplied by the user. A * or + by itself is to be typed as it appears.
Vertical and horizontal ellipsis (three dots arranged respectively
vertically and horizontally) are also used between non-terminal symbols
to indicate the occurrence of one or more entities. A term enclosed
within square brackets, such as {[}\textless{}comment\textgreater{}{]}, is optional (i.e. it may or
may not be included). Vertical bars indicate a choice between multiple
terms. White spaces (tabs, spaces, carriage re?turns) are used by CLIPS
only as delimiters between terms and are ignored otherwise (unless
inside double quotes). The ::= symbol is used to indicate how a
non-terminal symbol can be replaced. For example, the following syntax
description indicates that a \textless{}lexeme\textgreater{} can be replaced with either a
\textless{}symbol\textgreater{} or a \textless{}string\textgreater{}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{lexeme}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{symbol}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}} \PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

A complete BNF listing for CLIPS constructs along with some commonly
used replacements for non-terminal symbols are listed in appendix G.


\section{2.3 Basic Programming Elements}
\label{\detokenize{overview:basic-programming-elements}}
CLIPS provides three basic elements for writing programs: primitive data
types, functions for manipulating data, and constructs for adding to a
knowledge base.


\subsection{2.3.1 Data Types}
\label{\detokenize{overview:data-types}}
CLIPS provides eight primitive data types for representing information.
These types are \sphinxstylestrong{float}, \sphinxstylestrong{integer}, \sphinxstylestrong{symbol}, \sphinxstylestrong{string},
\sphinxstylestrong{external-address}, \sphinxstylestrong{fact-address}, \sphinxstylestrong{instance-name} and
\sphinxstylestrong{instance-address}. Numeric information can be represented using
floats and integers. Symbolic information can be represented using
symbols and strings.

A \sphinxstylestrong{number}; consists \sphinxstyleemphasis{only} of digits (0-9), a decimal point
(.), a sign (+ or -), and, optionally, an (e) for exponential notation
with its corresponding sign. A number is either stored as a float; or an
integer. Any number consisting of an optional sign followed by only
digits is stored as an \sphinxstylestrong{integer} (represented internally by CLIPS as a
C long integer). All other numbers are stored as \sphinxstylestrong{floats} (represented
internally by CLIPS as a C double-precision float). The number of
significant digits will de?pend on the machine implementation. Roundoff
errors also may occur, again depend?ing on the machine implementation.
As with any computer language, care should be taken when comparing
floating-point values to each other or comparing integers to
floating-point values. Some examples of integers are

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{237} \PYG{l+m+mi}{15} \PYG{o}{+}\PYG{l+m+mi}{12} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{32}
\end{sphinxVerbatim}

Some examples of floats are

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{237e3} \PYG{l+m+mf}{15.09} \PYG{o}{+}\PYG{l+m+mf}{12.0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{32.3e\PYGZhy{}7}
\end{sphinxVerbatim}

Specifically, integers use the following format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{integer}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{[}\PYG{o}{+} \PYGZbs{}\PYG{o}{\textbar{}} \PYG{o}{\PYGZhy{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{digit}\PYG{o}{\PYGZgt{}}\PYG{o}{+}

\PYG{o}{\PYGZlt{}}\PYG{n}{digit}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{l+m+mi}{0} \PYGZbs{}\PYG{o}{\textbar{}} \PYG{l+m+mi}{1} \PYGZbs{}\PYG{o}{\textbar{}} \PYG{l+m+mi}{2} \PYGZbs{}\PYG{o}{\textbar{}} \PYG{l+m+mi}{3} \PYGZbs{}\PYG{o}{\textbar{}} \PYG{l+m+mi}{4} \PYGZbs{}\PYG{o}{\textbar{}} \PYG{l+m+mi}{5} \PYGZbs{}\PYG{o}{\textbar{}} \PYG{l+m+mi}{6} \PYGZbs{}\PYG{o}{\textbar{}} \PYG{l+m+mi}{7} \PYGZbs{}\PYG{o}{\textbar{}} \PYG{l+m+mi}{8} \PYGZbs{}\PYG{o}{\textbar{}} \PYG{l+m+mi}{9}
\end{sphinxVerbatim}

Floating point numbers use the following format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{float}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{integer}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{exponent}\PYG{o}{\PYGZgt{}} \PYGZbs{}\PYG{o}{\textbar{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{integer}\PYG{o}{\PYGZgt{}} \PYG{o}{.} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{exponent}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYGZbs{}\PYG{o}{\textbar{}}

\PYG{o}{.} \PYG{o}{\PYGZlt{}}\PYG{n}{unsigned} \PYG{n}{integer}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{exponent}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYGZbs{}\PYG{o}{\textbar{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{integer}\PYG{o}{\PYGZgt{}} \PYG{o}{.} \PYG{o}{\PYGZlt{}}\PYG{n}{unsigned} \PYG{n}{integer}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{exponent}\PYG{o}{\PYGZgt{}}\PYG{p}{]}

\PYG{o}{\PYGZlt{}}\PYG{n}{unsigned}\PYG{o}{\PYGZhy{}}\PYG{n}{integer}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{digit}\PYG{o}{\PYGZgt{}}\PYG{o}{+}

\PYG{o}{\PYGZlt{}}\PYG{n}{exponent}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{n}{e} \PYGZbs{}\PYG{o}{\textbar{}} \PYG{n}{E} \PYG{o}{\PYGZlt{}}\PYG{n}{integer}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

A sequence of characters which does not exactly follow the format of a
number is treated as a symbol (see the next paragraph).

A \sphinxstylestrong{symbol} in CLIPS is any sequence of characters that starts with any
printable ASCII character and is followed by zero or more printable
ASCII characters. When a delimiter is found, the symbol is ended. The
following characters act as \sphinxstylestrong{delimiters}: any non-printable ASCII
character (including spaces, tabs, carriage returns, and line feeds), a
double quote, opening and closing parentheses ?(? and ?)?, an ampersand
?\&?, a vertical bar ?\textbar{}?, a less than ?\textless{}?, and a tilde ?\textasciitilde{}?. A semicolon
?;? starts a CLIPS comment (see section 2.3.3) and also acts as a
de?limiter. Delimiters may not be included in symbols with the exception
of the ?\textless{}? character which may be the first character in a symbol. In
addition, a symbol may not begin with either the ??? character or the
?\$?? sequence of characters (although a symbol may contain these
characters). These characters are reserved for variables (which are
discussed later in this section). CLIPS is case sensitive (i.e.
uppercase letters will match only uppercase let?ters). Note that numbers
are a special case of symbols (i.e. they satisfy the definition of a
symbol, but they are treated as a different data type). Some simple
examples of symbols are

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{foo} \PYG{n}{Hello} \PYG{n}{B76}\PYG{o}{\PYGZhy{}}\PYG{n}{HI} \PYG{n}{bad\PYGZus{}value}

\PYG{l+m+mi}{127}\PYG{n}{A} \PYG{l+m+mi}{456}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{93}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{039} \PYG{o}{@}\PYG{o}{+}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2}\PYG{n}{each}
\end{sphinxVerbatim}

A \sphinxstylestrong{string} is a set of characters that starts with a double quote (“)
and is followed by zero or more printable characters. A string ends with
double quotes. Double quotes may be embedded within a string by placing
a backslash () in front of the character. A backslash may be embedded
by placing two consecutive back?slash characters in the string. Some
examples are

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{foo}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a and b}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 number}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s+s2}{quote}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

Note that the string ?abcd” is not the same as the symbol \sphinxstyleemphasis{abcd}. They
both contain the same characters, but are of different types. The same
holds true for the instance name {[}abcd{]}.

An \sphinxstylestrong{external-address} is the address of an external data structure
returned by a function (written in a language such as C or Ada) that has
been integrated with CLIPS. This data type can only be created by
calling a function (i.e. it is not possible to specify an
external-address by typing the value). In the basic version of CLIPS
(which has no user defined external functions), it is not possible to
create this data type. External-addresses are discussed in further
detail in the \sphinxstyleemphasis{Advanced Programming Guide};. Within CLIPS, the printed
representation of an external-address is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{n}{XXXXXX}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

where XXXXXX is the external-address.

A \sphinxstylestrong{fact} is a list of atomic values that are either referenced
positionally (ordered facts) or by name (non-ordered or template facts).
Facts are referred to by index or address; section 2.4.1 gives more
details. The printed format of a \sphinxstylestrong{fact-address} is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Fact}\PYG{o}{\PYGZhy{}}\PYG{n}{XXX}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

where XXX is the fact-index.

An \sphinxstylestrong{instance} is an \sphinxstylestrong{object} that is an instantiation or specific
example of a \sphinxstylestrong{class}. Objects in CLIPS are defined to be floats,
integers, symbols, strings, multifield values, external-addresses,
fact-addresses or instances of a user-defined class. A user-defined
class is created using the \sphinxstylestrong{defclass} construct. An instance of a
user-defined class is created with the \sphinxstylestrong{make-instance} function, and
such an instance can be referred to uniquely by address. Within the
scope of a module (see section 10.5.1), an instance can also be uniquely
referred to by name. All of these definitions will be covered in more
detail in Sections 2.4.2, 2.5.2.3, 2.6 and 9. An \sphinxstylestrong{instance-name} is
formed by enclosing a symbol within left and right brackets. Thus, pure
symbols may not be surrounded by brackets. If the CLIPS Object Oriented
Language (COOL) is not included in a particular CLIPS configuration,
then brackets may be wrapped around symbols. Some examples of
instance-names are:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{pump}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{foo}\PYG{p}{]} \PYG{p}{[}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{123}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{890}\PYG{p}{]}
\end{sphinxVerbatim}

Note that the brackets are not part of the name of the instance; they
merely indicate that the enclosed symbol is an instance-name. An
\sphinxstylestrong{instance-address} can only be obtained by binding the return value of
a function called \sphinxstylestrong{instance-address} or by binding a variable to an
instance matching an object pattern on the LHS of a rule (i.e., it is
not possible to specify an instance-address by typing the value). A
reference to an instance of a user-defined class can either be by name
or address; instance-addresses should only be used when speed is
critical. Within CLIPS, the printed representation of an
instance-address is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{XXX}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

where XXX is the name of the instance.

In CLIPS, a placeholder that has a value (one of the primitive data
types) is referred to as a \sphinxstylestrong{field}. The primitive data types are
referred to as \sphinxstylestrong{single-field values}. A \sphinxstylestrong{constant} is a non-varying
single field value directly expressed as a series of characters (which
means that external-addresses, fact-addresses and instance-addresses
cannot be expressed as constants because they can only be obtained
through function calls and variable bindings). A \sphinxstylestrong{multifield value} is
a sequence of zero or more single field values. When displayed by CLIPS,
multifield values are enclosed in parentheses. Collectively, single and
multifield values are referred to as \sphinxstylestrong{values}. Some examples of
multifield values are

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{bar} \PYG{n}{foo}\PYG{p}{)} \PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{n}{x} \PYG{l+m+mf}{3.0} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+m+mi}{567}\PYG{p}{)}
\end{sphinxVerbatim}

Note that the multifield value (a) is not the same as the single field
value \sphinxstyleemphasis{a}. Multifield values are created either by calling functions
which return multifield values, by using wildcard arguments in a
deffunction, object message-handler, or method, or by binding variables
during the pattern-matching process for rules. In CLIPS, a \sphinxstylestrong{variable}
is a symbolic location that is used to store values. Variables are used
by many of the CLIPS constructs (such as defrule, deffunction,
defmethod, and defmessage-handler) and their usage is explained in the
sections describing each of these constructs.


\subsection{2.3.2 Functions}
\label{\detokenize{overview:functions}}
A \sphinxstylestrong{function} in CLIPS is a piece of executable code identified by a
specific name which returns a useful value or performs a useful side
effect (such as displaying information). Throughout the CLIPS
documentation, the word function is generally used to refer only to
functions which return a value (whereas commands and actions are used to
refer to functions which have a side effect but generally do not return
a value).

There are several types of functions. \sphinxstylestrong{User defined functions} and
\sphinxstylestrong{system defined functions} are pieces of code that have been written
in an external language (such as C, FORTRAN, or Ada) and linked with the
CLIPS environment. System defined functions are those functions that
have been defined internally by the CLIPS environment. User defined
functions are functions that have been defined externally of the CLIPS
environment. A complete list of system defined functions can be found in
appendix H.

The \sphinxstylestrong{deffunction} construct allows users to define new functions
directly in the CLIPS environment using CLIPS syntax. Functions defined
in this manner appear and act like other functions, however, instead of
being directly executed (as code written in an external language would
be) they are interpreted by the CLIPS environment. Deffunctions are also
discussed in section 2.5.2.1 in the context of procedural knowledge
representation.

Generic functions can be defined using the \sphinxstylestrong{defgeneric} and
\sphinxstylestrong{defmethod} constructs. Generic functions allow different pieces of
code to be executed depending upon the arguments passed to the generic
function. Thus, a single function name can be \sphinxstylestrong{overloaded} with more
than one piece of code. Generic functions are also discussed in section
2.5.2.2 in the context of procedural knowledge representation.

Function calls in CLIPS use a prefix notation ? the arguments to a
function always appear after the function name. Function calls begin
with a left parenthesis, followed by the name of the function, then the
arguments to the function follow (each argument separated by one or more
spaces). Arguments to a function can be primitive data types, variables,
or another function call. The function call is then closed with a right
parenthesis. Some examples of function calls using the addition (+) and
multiplication (*) functions are shown following.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{+} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5}\PYG{p}{)}

\PYG{p}{(}\PYGZbs{}\PYG{o}{*} \PYG{l+m+mi}{5} \PYG{l+m+mf}{6.0} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{p}{(}\PYG{o}{+} \PYG{l+m+mi}{3} \PYG{p}{(}\PYGZbs{}\PYG{o}{*} \PYG{l+m+mi}{8} \PYG{l+m+mi}{9}\PYG{p}{)} \PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{p}{(}\PYGZbs{}\PYG{o}{*} \PYG{l+m+mi}{8} \PYG{p}{(}\PYG{o}{+} \PYG{l+m+mi}{3} \PYG{p}{(}\PYGZbs{}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{l+m+mi}{9}\PYG{p}{)} \PYG{p}{(}\PYGZbs{}\PYG{o}{*} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

While a function refers to a piece of executable code identified by a
specific name, an \sphinxstylestrong{expression} refers to a function which has its
arguments specified (which may or may not be functions calls as well).
Thus the previous examples are expressions which make calls to the *
and + functions.


\subsection{2.3.3 Constructs}
\label{\detokenize{overview:constructs}}
Several defining \sphinxstylestrong{constructs} appear in CLIPS: \sphinxstylestrong{defmodule},
\sphinxstylestrong{defrule}, \sphinxstylestrong{deffacts}, \sphinxstylestrong{deftemplate}, \sphinxstylestrong{defglobal},
\sphinxstylestrong{deffunction}, \sphinxstylestrong{defclass}, \sphinxstylestrong{definstances}, \sphinxstylestrong{defmessage-handler},
\sphinxstylestrong{defgeneric}, and \sphinxstylestrong{defmethod}. All constructs in CLIPS are
surrounded by parentheses. The construct opens with a left parenthe?sis
and closes with a right parenthesis. Defining a construct differs from
calling a function primarily in effect. Typically a function call leaves
the CLIPS environment unchanged (with some notable exceptions such as
resetting or clearing the environment or opening a file). Defining a
construct, however, is explicitly intended to alter the CLIPS
environment by adding to the CLIPS knowledge base. Unlike function
calls, constructs never have a return value.

As with any programming language, it is highly beneficial to comment
CLIPS code. All constructs (with the exception of defglobal) allow a
comment directly following the construct name. Comments also can be
placed within CLIPS code by using a semicolon (;). Everything from the
semicolon until the next return character will be ignored by CLIPS. If
the semicolon is the first character in the line, the entire line will
be treated as a comment. Examples of commented code will be pro?vided
throughout the reference manual. Semicolon commented text is not saved
by CLIPS when loading constructs (however, the optional comment string
within a construct is saved).


\section{2.4 Data Abstraction}
\label{\detokenize{overview:data-abstraction}}
There are three primary formats for representing information in CLIPS:
facts, objects and global variables.


\subsection{2.4.1 Facts}
\label{\detokenize{overview:facts}}
Facts are one of the basic high-level forms for representing information
in a CLIPS system. Each \sphinxstylestrong{fact} represents a piece of information that
has been placed in the current list of facts, called the \sphinxstylestrong{fact-list}.
Facts are the fundamental unit of data used by rules (see section
2.5.1).

Facts may be added to the fact-list (using the \sphinxstylestrong{assert} command),
removed from the fact-list (using the \sphinxstylestrong{retract} command), modified
(using the \sphinxstylestrong{modify} command), or duplicated (using the \sphinxstylestrong{duplicate}
command) through explicit user interaction or as a CLIPS program
executes;. The number of facts in the fact-list and the amount of
information that can be stored in a fact is limited only by the amount
of memory in the computer. If a fact is asserted into the fact-list that
exactly matches an already existing fact, the new assertion will be
ignored (however, this behavior can be changed, see sections 13.4.4 and
13.4.5).

Some commands, such as the \sphinxstylestrong{retract}, \sphinxstylestrong{modify}, and \sphinxstylestrong{duplicate}
commands, require a fact to be specified. A fact can be specified either
by \sphinxstylestrong{fact-index} or \sphinxstylestrong{fact-address}. Whenever a fact is added (or
modified) it is given a unique integer index called a fact-index.
Fact-indices start at zero and are incremented by one for each new or
changed fact. Whenever a \sphinxstylestrong{reset} or \sphinxstylestrong{clear} command is given, the
fact-indices restart at zero. A fact may also be specified through the
use of a fact-address. A fact-address can be obtained by capturing the
return value of commands which return fact addresses (such as
\sphinxstylestrong{assert}, \sphinxstylestrong{modify}, and \sphinxstylestrong{duplicate}) or by binding a variable to
the fact address of a fact which matches a pattern on the LHS of a rule
(see section 5.4.1.8 for details).

A \sphinxstylestrong{fact identifier} is a shorthand notation for displaying a fact. It
consists of the character ?f?, followed by a dash, followed by the
fact-index of the fact. For example, f-10 refers to the fact with
fact-index 10.

A fact is stored in one of two formats: ordered or non-ordered.


\subsubsection{2.4.1.1 Ordered Facts}
\label{\detokenize{overview:ordered-facts}}
\sphinxstylestrong{Ordered facts} consist of a symbol followed by a sequence of zero or
more fields separated by spaces and delimited by an opening parenthesis
on the left and a closing parenthesis on the right. The first field of
an ordered fact specifies a ?relation? that applied to the remaining
fields in the ordered fact. For example, (father-of jack bill) states
that bill is the father of jack.

Some examples of ordered facts are shown following.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{the} \PYG{n}{pump} \PYG{o+ow}{is} \PYG{n}{on}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{altitude} \PYG{o+ow}{is} \PYG{l+m+mi}{10000} \PYG{n}{feet}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{grocery}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list} \PYG{n}{bread} \PYG{n}{milk} \PYG{n}{eggs}\PYG{p}{)}
\end{sphinxVerbatim}

Fields in a non-ordered fact may be of any of the primitive data types
(with the exception of the first field which must be a symbol), and no
restriction is placed on the ordering of fields. The following symbols
are reserved and should not be used as the \sphinxstyleemphasis{first} field in any fact
(ordered or non-ordered): \sphinxstyleemphasis{test}, \sphinxstyleemphasis{and}, \sphinxstyleemphasis{or}, \sphinxstyleemphasis{not}, \sphinxstyleemphasis{declare},
\sphinxstyleemphasis{logical}, \sphinxstyleemphasis{object}, exists, and forall. These words are reserved only
when used as a deftemplate name (whether explicitly defined or implied).
These symbols may be used as slot names, however, this is not
recommended.


\subsubsection{2.4.1.2 Non-ordered Facts}
\label{\detokenize{overview:non-ordered-facts}}
Ordered facts encode information positionally. To access that
information, a user must know not only what data is stored in a fact but
which field contains the data. \sphinxstylestrong{Non-ordered (or deftemplate) facts}
provide the user with the ability to abstract the structure of a fact by
assign?ing names to each field in the fact. The \sphinxstylestrong{deftemplate}
construct (see section 3) is used to create a template that can then be
used to access fields by name. The deftemplate construct is analogous to
a record or structure definition in programming languages such as Pascal
and C.

The deftemplate construct allows the name of a template to be defined
along with zero or more definitions of \sphinxstylestrong{named fields} or \sphinxstylestrong{slots}.
Unlike ordered facts, the slots of a deftemplate fact may be constrained
by type, value, and numeric range. In addition, default values can be
specified for a slot. A slot consists of an opening parenthesis followed
by the name of the slot, zero or more fields, and a closing parenthesis.
Note that slots may not be used in an ordered fact and that positional
fields may not be used in a deftemplate fact.

Deftemplate facts are distinguished from ordered facts by the first
field within the fact. The first field of all facts must be a symbol,
however, if that symbol corresponds to the name of a deftemplate, then
the fact is a deftemplate fact. The first field of a deftemplate fact is
followed by a list of zero or more slots. As with ordered facts,
deftemplate facts are enclosed by an opening parenthesis on the left and
a closing parenthesis on the right.

Some examples of deftemplate facts are shown following.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(client (name \PYGZdq{}Joe Brown\PYGZdq{}) (id X9345A))

(point\PYGZhy{}mass (x\PYGZhy{}velocity 100) (y\PYGZhy{}velocity \PYGZhy{}200))

(class (teacher \PYGZdq{}Martha Jones\PYGZdq{}) (\PYGZsh{}\PYGZhy{}students 30) (Room \PYGZdq{}37A\PYGZdq{}))

(grocery\PYGZhy{}list (\PYGZsh{}\PYGZhy{}of\PYGZhy{}items 3) (items bread milk eggs))
\end{sphinxVerbatim}

Note that the order of slots in a deftemplate fact is not important. For
example the following facts are all identical:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(class (teacher \PYGZdq{}Martha Jones\PYGZdq{}) (\PYGZsh{}\PYGZhy{}students 30) (Room \PYGZdq{}37A\PYGZdq{}))

(class (\PYGZsh{}\PYGZhy{}students 30) (teacher \PYGZdq{}Martha Jones\PYGZdq{}) (Room \PYGZdq{}37A\PYGZdq{}))

(class (Room \PYGZdq{}37A\PYGZdq{}) (\PYGZsh{}\PYGZhy{}students 30) (teacher \PYGZdq{}Martha Jones\PYGZdq{}))
\end{sphinxVerbatim}

In contrast, note that the following ordered fact \sphinxstyleemphasis{are not} identical.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(class \PYGZdq{}Martha Jones\PYGZdq{} 30 \PYGZdq{}37A\PYGZdq{})

(class 30 \PYGZdq{}Martha Jones\PYGZdq{} \PYGZdq{}37A\PYGZdq{})

(class \PYGZdq{}37A\PYGZdq{} 30 \PYGZdq{}Martha Jones\PYGZdq{})
\end{sphinxVerbatim}

The im?mediate advantages of clarity and slot order independence for
deftemplate facts should be readily apparent.

In addition to being asserted and retracted, deftemplate facts can also
be modified and duplicated (using the \sphinxstylestrong{modify} and \sphinxstylestrong{duplicate}
commands). Modifying a fact changes a set of specified slots within that
fact. Duplicating a fact creates a new fact identical to the original
fact and then changes a set of specified slots within the new fact. The
benefit of using the modify and duplicate commands is that slots which
don?t change, don?t have to be specified.


\subsubsection{2.4.1.3 Initial Facts}
\label{\detokenize{overview:initial-facts}}
The \sphinxstylestrong{deffacts} construct allows a set of \sphinxstyleemphasis{a priori} or initial
knowledge to be specified as a collection of facts. When the CLIPS
environment is reset (using the \sphinxstylestrong{reset} command) every fact specified
within a deffacts construct in the CLIPS knowledge base is added to the
fact-list.


\subsection{2.4.2 Objects}
\label{\detokenize{overview:objects}}
An \sphinxstylestrong{object} in CLIPS is defined to be a symbol, a string, a
floating-point or integer number, a multifield value, an
external-address or an instance of a user-defined class. Section 2.3.1
explains how to reference instances of user-defined classes. Objects are
described in two basic parts: properties and behavior. A \sphinxstylestrong{class} is a
template for common properties and behavior of objects that are
\sphinxstylestrong{instances} of that class. Some examples of objects and their classes
are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Object (Printed Representation)}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Class}
\\
\hline
Rolls-Royce
&
SYMBOL
\\
\hline
“Rolls-Royce”
&
STRING
\\
\hline
8.0
&
FLOAT
\\
\hline
8
&
INTEGER
\\
\hline
(8.0 Rolls-Royce 8 {[}Rolls-Royce{]})
&
MULTIFIELD
\\
\hline
\textless{}Pointer-00CF61AB\textgreater{}
&
EXTERNAL-ADDRESS
\\
\hline
{[}Rolls-Royce{]}
&
CAR (a user-defined class)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Objects in CLIPS are split into two important categories: primitive
types and instances of \sphinxstyleemphasis{user-defined} classes. These two types of
objects differ in the way they are referenced, created and deleted as
well as how their properties are specified.

Primitive type objects are referenced simply by giving their value, and
they are created and deleted implicitly by CLIPS as they are needed.
Primitive type objects have no names or slots, and their classes are
predefined by CLIPS. The behavior of primitive type objects is like that
of instances of user-defined classes, however, in that you can define
message-handlers and attach them to the primitive type classes. It is
anticipated that primitive types will not be used often in an
object-oriented programming (OOP) context; the main reason classes are
provided for them is for use in generic functions. Generic functions use
the classes of their arguments to determine which methods to execute;
sections 2.3.2, 2.5.2.2 and 8 give more detail.

An instance of a user-defined class is referenced by name or address,
and they are created and deleted explicitly via messages and special
functions. The properties of an instance of a \sphinxstyleemphasis{user-defined} class are
expressed by a set of slots, which the object obtains from its class. As
previously defined, slots are named single field or multifield values.
For example, the object Rolls-Royce is an instance of the class CAR. One
of the slots in class CAR might be ?price?, and the Rolls-Royce object?s
value for this slot might be \$75,000.00. The behavior of an object is
specified in terms of procedural code called message-handlers, which are
attached to the object?s class. Message-handlers and manipulation of
objects are described in Section 2.5.2.3. All instances of a
user-defined class have the same set of slots, but each instance may
have different values for those slots. However, two instances that have
the same set of slots do not necessarily belong to the same class, since
two different classes can have identical sets of slots.

The primary difference between object slots and template (or
non-ordered) facts is the notion of inheritance. Inheritance allows the
properties and behavior of a class to be described in terms of other
classes. COOL supports multiple inheritance: a class may directly
inherit slots and message-handlers from more than one class. Since
inheritance is only useful for slots and message-handlers, it is often
not meaningful to inherit from one of the primitive type classes, such
as MULTIFIELD or NUMBER. This is because these classes cannot have slots
and usually do not have message-handlers.

Further discussion on these topics can be found in Section 2.6, and a
comprehensive description of the CLIPS Object-Oriented Language (COOL)
can be found in Section 9.


\subsubsection{2.4.2.1 Initial Objects}
\label{\detokenize{overview:initial-objects}}
The \sphinxstylestrong{definstances} construct allows a set of \sphinxstyleemphasis{a priori} or initial
knowledge to be specified as a collection of instances of user-defined
classes. When the CLIPS environment is reset (using the \sphinxstylestrong{reset}
command) every instance specified within a definstances construct in the
CLIPS knowledge base is added to the instance-list.


\subsection{2.4.3 Global Variables}
\label{\detokenize{overview:global-variables}}
The \sphinxstylestrong{defglobal} construct allows variables to be defined which are
global in scope throughout the CLIPS environment. That is, a global
variable can be accessed anywhere in the CLIPS environment and retains
its value independent of other constructs. In contrast, some constructs
(such as defrule and deffunction) allow local variables to be defined
within the definition of the construct. These local variables can be
referred to within the construct, but have no meaning outside the
construct. A CLIPS global variable is similar to global variables found
in procedural programming languages such as LISP, C and Ada. Unlike C
and Ada, however, CLIPS global variables are weakly typed (they are not
restricted to holding a value of a single data type).


\section{2.5 Knowledge Representation}
\label{\detokenize{overview:knowledge-representation}}
CLIPS provides heuristic and procedural paradigms for representing
knowledge. These two paradigms are discussed in this section.
Object-oriented programming (which combines aspects of both data
abstraction and procedural knowledge) is discussed in section 2.6.


\subsection{2.5.1 Heuristic Knowledge ? Rules}
\label{\detokenize{overview:heuristic-knowledge-rules}}
One of the primary methods of representing knowledge in CLIPS is a rule.
Rules are used to represent heuristics, or ?rules of thumb?, which
specify a set of actions to be performed for a given situation. The
de?veloper of an expert system defines a set of rules that collectively
work together to solve a problem. A \sphinxstylestrong{rule} is composed of an
\sphinxstylestrong{antecedent} and a \sphinxstylestrong{consequent}. The antecedent of a rule is also
referred to as the \sphinxstylestrong{if portion} or the \sphinxstylestrong{left-hand side} (LHS) of the
rule. The consequent of a rule is also referred to as the \sphinxstylestrong{then
portion} or the \sphinxstylestrong{right-hand side} (RHS) of the rule.

The antecedent of a rule is a set of \sphinxstylestrong{conditions} (or \sphinxstylestrong{conditional
elements}) that must be satisfied for the rule to be applicable. In
CLIPS, the conditions of a rule are satisfied based on the existence or
non-existence of specified facts in the fact-list or specified instances
of user-defined classes in the instance-list. One type of condition that
can be specified is a \sphinxstylestrong{pattern}. Patterns consist of a set of
restrictions that are used to determine which facts or objects satisfy
the condition specified by the pattern. The process of matching facts
and objects to patterns is called \sphinxstylestrong{pattern-matching}. CLIPS provides a
mechanism, called the \sphinxstylestrong{inference engine}, which automatically matches
patterns against the current state of the fact-list and instance-list
and determines which rules are applicable.

The consequent of a rule is the set of actions to be executed when the
rule is applicable. The actions of applicable rules are executed when
the CLIPS inference engine is instructed to begin execution of
applicable rules. If more than one rule is applicable, the inference
engine uses a \sphinxstylestrong{conflict resolution strategy} to select which rule
should have its actions executed. The actions of the selected rule are
executed (which may affect the list of applicable rules) and then the
inference engine selects another rule and executes its actions. This
process continues until no applicable rules remain.

In many ways, rules can be thought of as IF-THEN statements found in
procedural programming languages such as C and Ada. However, the
conditions of an IF-THEN statement in a procedural language are only
evaluated when the program flow of control is directly at the IF-THEN
statement. In contrast, rules act like WHENEVER-THEN statements. The
inference engine always keeps track of rules that have their conditions
satisfied and thus rules can immediately be executed when they are
applicable. In this sense, rules are similar to exception handlers found
in languages such as Ada.


\subsection{2.5.2 Procedural Knowledge}
\label{\detokenize{overview:procedural-knowledge}}
CLIPS also supports a procedural paradigm for representing knowledge
like that of more conventional languages, such as Pascal and C.
Deffunctions and generic functions allow the user to define new
executable elements to CLIPS that perform a useful side-effect or return
a useful value. These new functions can be called just like the built-in
functions of CLIPS. Message-handlers allow the user to define the
behavior of objects by specifying their response to messages.
Deffunctions, generic functions and message-handlers are all procedural
pieces of code specified by the user that CLIPS executes interpretively
at the appropriate times. Defmodules allow a knowledge base to be
partitioned.


\subsubsection{2.5.2.1 Deffunctions}
\label{\detokenize{overview:deffunctions}}
Deffunctions allow you to define new functions in CLIPS directly. In
previous versions of CLIPS, the only way to have user-defined functions
was to write them in some external language, such as C or Ada, and then
recompile and relink CLIPS with the new functions. The body of a
deffunction is a series of expressions similar to the RHS of a rule that
are executed in order by CLIPS when the deffunction is called. The
return value of a deffunction is the value of the last expression
evaluated within the deffunction. Calling a deffunction is identical to
calling any other function in CLIPS. Deffunctions are covered
comprehensively in Section 7.


\subsubsection{2.5.2.2 Generic Functions}
\label{\detokenize{overview:generic-functions}}
Generic functions are similar to deffunctions in that they can be used
to define new procedural code directly in CLIPS, and they can be called
like any other function. However, generic functions are much more
powerful because they can be \sphinxstylestrong{overloaded}. A generic function will do
different things depending on the types (or classes) and number of its
arguments. Generic functions are comprised of multiple components called
methods, where each method handles different cases of arguments for the
generic function. For example, you might overload the ?+? operator to do
string concatenation when it is passed strings as arguments. However,
the ?+? operator will still perform arithmetic addition when passed
numbers. There are two methods in this example: an explicit one for
strings defined by the user and an implicit one which is the standard
CLIPS arithmetic addition operator. The return value of a generic
function is the evaluation of the last expression in the method
executed. Generic functions are covered comprehensively in Section 8.


\subsubsection{2.5.2.3 Object Message-Passing}
\label{\detokenize{overview:object-message-passing}}
Objects are described in two basic parts: properties and behavior.
Object properties are specified in terms of slots obtained from the
object?s class; slots are discussed in more detail in Section 2.4.2.
Object behavior is specified in terms of procedural code called
message-handlers which are attached to the object?s class. Objects are
manipulated via message-passing. For example, to cause the Rolls-Royce
object, which is an instance of the class CAR, to start its engine, the
user must call the \sphinxstylestrong{send} function to send the message ?start-engine?
to the Rolls-Royce. How the Rolls-Royce responds to this message will be
dictated by the execution of the message-handlers for ?start-engine?
attached to the CAR class and any of its superclasses. The result of a
message is similar to a function call in CLIPS: a useful return value or
side-effect.

Further discussion on message-handlers can be found in Section 2.6, and
a comprehensive description of the CLIPS Object-Oriented Language (COOL)
can be found in Section 9.


\subsubsection{2.5.2.4 Defmodules}
\label{\detokenize{overview:defmodules}}
Defmodules allow a knowledge base to be partitioned. Every construct
defined must be placed in a module. The programmer can explicitly
control which constructs in a module are visible to other modules and
which constructs from other modules are visible to a module. The
visibility of facts and instances between modules can be controlled in a
similar manner. Modules can also be used to control the flow of
execution of rules. Defmodules are covered comprehensively in Section
10.


\section{2.6 CLIPS Object-Oriented Language}
\label{\detokenize{overview:clips-object-oriented-language}}
This section gives a brief overview of the programming elements of the
CLIPS Object-Oriented Language (COOL). COOL includes elements of data
abstraction and knowledge representation. This section gives an overview
of COOL as a whole, incorporating the elements of both concepts.
References to instanes of user-defined classes are discussed in Section
2.3.1, and the structure of objects is discussed in Sections 2.4.2 and
2.5.2.3. The comprehensive details of COOL are given in Section 9.


\subsection{2.6.1 COOL Deviations from a Pure OOP Paradigm}
\label{\detokenize{overview:cool-deviations-from-a-pure-oop-paradigm}}
In a pure OOP language, \sphinxstyleemphasis{all} programming elements are objects which can
only be manipulated via messages. In CLIPS, the definition of an object
is much more constrained: floating-point and integer numbers, symbols,
strings, multifield values, external-addresses, fact-addresses and
instances of user-defined classes. All objects \sphinxstyleemphasis{may} be manipulated with
messages, except instances of user-defined classes, which \sphinxstyleemphasis{must} be. For
example, in a pure OOP system, to add two numbers together, you would
send the message ?add? to the first number object with the second number
object as an argument. In CLIPS, you may simply call the ?+? function
with the two numbers as arguments, or you can define message-handlers
for the NUMBER class which allow you to do it in the purely OOP fashion.

All programming elements that are not objects must be manipulated in a
non-OOP utilizing function tailored for those programming elements. For
example, to print a rule, you call the function \sphinxstylestrong{ppdefrule}; you do
not send a message ?print? to a rule, since it is not an object.


\subsection{2.6.2 Primary OOP Features}
\label{\detokenize{overview:primary-oop-features}}
There are five primary characteristics that an OOP system must possess:
\sphinxstylestrong{abstraction}, \sphinxstylestrong{encapsulation}, \sphinxstylestrong{inheritance}, \sphinxstylestrong{polymorphism}
and \sphinxstylestrong{dynamic binding}. An abstraction is a higher level, more
intuitive representation for a complex concept. Encapsulation is the
process whereby the implementation details of an object are masked by a
well-defined external interface. Classes may be described in terms of
other classes by use of inheritance. Polymorphism is the ability of
different objects to respond to the same message in a specialized
manner. Dynamic binding is the ability to defer the selection of which
specific message-handlers will be called for a message until run-time.

The definition of new classes allows the abstraction of new data types
in COOL. The slots and message-handlers of these classes describe the
properties and behavior of a new group of objects.

COOL supports encapsulation by requiring message-passing for the
manipulation of instances of user-defined classes. An instance cannot
respond to a message for which it does not have a defined
message-handler.

COOL allows the user to specify some or all of the properties and
behavior of a class in terms of one or more unrelated superclasses. This
process is called \sphinxstylestrong{multiple inheritance}. COOL uses the existing
hierarchy of classes to establish a linear ordering called the \sphinxstylestrong{class
precedence list} for a new class. Objects that are instances of this
new class can inherit properties (slots) and behavior (message-handlers)
from each of the classes in the class precedence list. The word
precedence implies that properties and behavior of a class first in the
list override conflicting definitions of a class later in the list.

One COOL object can respond to a message in a completely different way
than another object; this is polymorphism. This is accomplished by
attaching message-handlers with differing actions but which have the
same name to the classes of these two objects respectively.

Dynamic binding is supported in that an object reference (see section
2.3.1) in a \sphinxstylestrong{send} function call is not bound until run-time. For
example, an instance-name or variable might refer to one object at the
time a message is sent and another at a later time.


\subsection{2.6.3 Instance-set Queries and Distributed Actions}
\label{\detokenize{overview:instance-set-queries-and-distributed-actions}}
In addition to the ability of rules to directly pattern-match on
objects, COOL provides a useful query system for determining, grouping
and performing actions on sets of instances of user-defined classes that
meet user-defined criteria. The query system allows you to associate
instances that are either related or not. You can simply use the query
system to determine if a particular association set exists, you can save
the set for future reference, or you can iterate an action over the set.
An example of the use of the query system might be to find the set of
all pairs of boys and girls that have the same age.


\chapter{Section 3: Deftemplate Construct}
\label{\detokenize{deftemplate:section-3-deftemplate-construct}}\label{\detokenize{deftemplate::doc}}
Ordered facts encode information positionally. To access that
information, a user must know not only what data is stored in a fact but
also which field contains the data. Non-ordered (or deftemplate) facts
provide the user with the ability to abstract the structure of a fact by
assign?ing names to each field found within the fact. The
\sphinxstylestrong{deftemplate} construct is used to create a template that can then be
used by non-ordered facts to access fields of the fact by name. The
deftemplate construct is analogous to a record or structure definition
in programming languages such as Pascal and C.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(deftemplate \PYGZlt{}deftemplate\PYGZhy{}name\PYGZgt{} [\PYGZlt{}comment\PYGZgt{}] \PYGZlt{}slot\PYGZhy{}definition\PYGZgt{}*)

   \PYGZlt{}slot\PYGZhy{}definition\PYGZgt{} ::= \PYGZlt{}single\PYGZhy{}slot\PYGZhy{}definition\PYGZgt{} \textbar{} \PYGZlt{}multislot\PYGZhy{}definition\PYGZgt{}

   \PYGZlt{}single\PYGZhy{}slot\PYGZhy{}definition\PYGZgt{} ::= (slot \PYGZlt{}slot\PYGZhy{}name\PYGZgt{} \PYGZlt{}template\PYGZhy{}attribute\PYGZgt{}*)

   \PYGZlt{}multislot\PYGZhy{}definition\PYGZgt{} ::= (multislot \PYGZlt{}slot\PYGZhy{}name\PYGZgt{} \PYGZlt{}template\PYGZhy{}attribute\PYGZgt{}*)

   \PYGZlt{}template\PYGZhy{}attribute\PYGZgt{} ::= \PYGZlt{}default\PYGZhy{}attribute\PYGZgt{} \textbar{} \PYGZlt{}constraint\PYGZhy{}attribute\PYGZgt{}

   \PYGZlt{}default\PYGZhy{}attribute\PYGZgt{} ::= (default ?DERIVE \textbar{} ?NONE \textbar{} \PYGZlt{}expression\PYGZgt{}*) \textbar{}
                             (default\PYGZhy{}dynamic \PYGZlt{}expression\PYGZgt{}*)
\end{sphinxVerbatim}

Redefining a deftemplate will result in the previous definition being
discarded. A deftemplate can not be redefined while it is being used
(for example, by a fact or pattern in a rule). A deftemplate can have
any number of single or multifield slots. CLIPS always enforces the
single and multifield definitions of the deftemplate. For example, it is
an error to store (or match) multiple values in a single-field slot.

\sphinxcode{\sphinxupquote{Example}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate} \PYG{n+nb}{object}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{name}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{location}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{on}\PYG{o}{\PYGZhy{}}\PYG{n}{top}\PYG{o}{\PYGZhy{}}\PYG{n}{of}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{weight}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{multislot} \PYG{n}{contents}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\section{3.1 Slot Default Values}
\label{\detokenize{deftemplate:slot-default-values}}
The \textless{}default-attribute\textgreater{} specifies the value to be used for unspecified
slots of a template fact when an \sphinxstylestrong{assert} action is performed. One of
two types of default selections can be chosen: default or
dynamic-default.

The \sphinxstylestrong{default} attribute specifies a static default value. The
specified expressions are evaluated once when the deftemplate is defined
and the result is stored with the deftemplate. The result is assigned to
the appropriate slot when a new template fact is asserted. If the
keyword ?DERIVE is used for the default value, then a default value is
derived from the constraints for the slot (see section 11.5 for more
details). By default, the default attribute for a slot is (default
?DERIVE). If the keyword ?NONE is used for the default value, then a
value must explicitly be assigned for a slot when an assert is
performed. It is an error to assert a template fact without specifying
the values for the (default ?NONE) slots.

The \sphinxstylestrong{default-dynamic} attribute is a dynamic default. The specified
expressions are evaluated every time a template fact is asserted, and
the result is assigned to the appropriate slot.

A single-field slot may only have a single value for its default. Any
number of values may be specified as the default for a multifield slot
(as long as the number of values satisfies the cardinality attribute for
the slot).

\sphinxcode{\sphinxupquote{Example}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(deftemplate foo
  (slot w (default ?NONE))
  (slot x (default ?DERIVE))
  (slot y (default (gensym*)))
  (slot z (default\PYGZhy{}dynamic (gensym*))))
CLIPS\PYGZgt{} (assert (foo))

[TMPLTRHS1] Slot w requires a value because of its (default ?NONE)
attribute.

CLIPS\PYGZgt{} (assert (foo (w 3)))
\PYGZlt{}Fact\PYGZhy{}1\PYGZgt{}
CLIPS\PYGZgt{} (assert (foo (w 4)))
\PYGZlt{}Fact\PYGZhy{}2\PYGZgt{}
CLIPS\PYGZgt{} (facts)
f\PYGZhy{}0 (initial\PYGZhy{}fact)
f\PYGZhy{}1 (foo (w 3) (x nil) (y gen1) (z gen2))
f\PYGZhy{}2 (foo (w 4) (x nil) (y gen1) (z gen3))
For a total of 3 facts.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\section{3.2 Slot Default Constraints for Pattern-Matching}
\label{\detokenize{deftemplate:slot-default-constraints-for-pattern-matching}}
Single-field slots that are not specified in a pattern on the LHS of a
rule are defaulted to single-field wildcards (?) and multifield slots
are defaulted to multifield wildcards (\$?).


\section{3.3 Slot Value Constraint Attributes}
\label{\detokenize{deftemplate:slot-value-constraint-attributes}}
The syntax and functionality of single and multifield constraint
attributes are described in detail in Section 11. Static and dynamic
constraint checking for deftemplates is supported. Static checking is
performed when constructs or commands using deftemplates slots are being
parsed (and the specific deftemplate associated with the construct or
command can be immediately determined). Template patterns used on the
LHS of a rule are also checked to determine if constraint conflicts
exist among variables used in more than one slot. Errors for
inappropriate values are immediately signaled. References to
fact-indexes made in commands such as \sphinxstylestrong{modify} and \sphinxstylestrong{duplicate} are
considered to be ambiguous and are never checked using static checking.
Static checking is enabled by default. This behavior can be changed
using the \sphinxstylestrong{set-static-constraint-checking} function. Dynamic checking
is also supported. If dynamic checking is enabled, then new deftemplate
facts have their values checked when added to the fact-list. This
dynamic checking is disabled by default. This behavior can be changed
using the \sphinxstylestrong{set-dynamic-constraint-checking} function. If a violation
occurs when dynamic checking is being performed, then execution will be
halted.

\sphinxcode{\sphinxupquote{Example}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(deftemplate object
  (slot name (type SYMBOL) (default ?DERIVE))
  (slot location (type SYMBOL) (default ?DERIVE))
  (slot on\PYGZhy{}top\PYGZhy{}of (type SYMBOL) (default floor))
  (slot weight (allowed\PYGZhy{}values light heavy) (default light))
  (multislot contents (type SYMBOL) (default ?DERIVE)))
\end{sphinxVerbatim}


\section{3.4 Implied Deftemplates}
\label{\detokenize{deftemplate:implied-deftemplates}}
Asserting or referring to an ordered fact (such as in a LHS pattern)
creates an ?implied? deftemplate with a single implied multifield slot.
The implied multifield slot?s name is not printed when the fact is
printed. The implied deftemplate can be manipulated and examined
identically to any user defined deftemplate (although it has no pretty
print form).

\sphinxcode{\sphinxupquote{Example}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{foo} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{n}{Fact}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defrule} \PYG{n}{yak} \PYG{p}{(}\PYG{n}{bar} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n+nb}{list}\PYG{o}{\PYGZhy{}}\PYG{n}{deftemplates}\PYG{p}{)}
\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n}{fact}
\PYG{n}{foo}
\PYG{n}{bar}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{3} \PYG{n}{deftemplates}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{facts}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0} \PYG{p}{(}\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n}{fact}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{n}{foo} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{2} \PYG{n}{facts}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{deftemplate:section-1}}

\chapter{Section 4: Deffacts Construct}
\label{\detokenize{deffacts:section-4-deffacts-construct}}\label{\detokenize{deffacts::doc}}
With the \sphinxstylestrong{deffacts} construct, a list of facts can be defined which
are automatically asserted whenever the \sphinxstylestrong{reset} command is performed.
Facts as?serted through deffacts may be retracted or pattern-matched
like any other fact. The initial fact-list, including any defined
deffacts, is always reconstructed after a \sphinxstylestrong{reset} command.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deffacts} \PYG{o}{\PYGZlt{}}\PYG{n}{deffacts}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{comment}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{o}{\textbar{}} \PYG{o}{\PYGZlt{}}\PYG{n}{RHS}\PYG{o}{\PYGZhy{}}\PYG{n}{pattern}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Redefining a currently existing deffacts causes the previous deffacts
with the same name to be removed even if the new definition has errors
in it. There may be multiple deffacts constructs and any number of facts
(either ordered or deftemplate) may be asserted into the initial
fact-list by each deffacts construct.

Dynamic expressions may be included in a fact by embedding the
expression directly within the fact. All such expressions are evaluated
when CLIPS is reset.

\sphinxcode{\sphinxupquote{Example}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deffacts} \PYG{n}{startup} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Refrigerator Status}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{p}{(}\PYG{n}{refrigerator} \PYG{n}{light} \PYG{n}{on}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{refrigerator} \PYG{n}{door} \PYG{n+nb}{open}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{refrigerator} \PYG{n}{temp} \PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Upon startup and after a \sphinxstylestrong{clear} command, CLIPS automatically
constructs the following deftemplate and deffacts.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate} \PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n}{fact}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{deffacts} \PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n}{fact}
\PYG{p}{(}\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n}{fact}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

In prior versions of CLIPS, the initial-fact deffacts provided a
convenient method for starting the execution of a system: rules without
conditional elements had an (initial-fact) pattern automatically added
to their LHS. When a \sphinxstylestrong{reset} command was issued, the assertion of the
(intial-fact) would activate these rules. Starting with version 6.3 of
CLIPS, rules without conditional elements are automatically matched
without the need for the (initial-fact) assertion. Usage of the
initial-fact is now deprecated. Programs should not rely on the
assertion of this fact when a reset is performed.

\phantomsection\label{\detokenize{deffacts:section-2}}

\chapter{Section 5: Defrule Construct}
\label{\detokenize{defrule:section-5-defrule-construct}}\label{\detokenize{defrule::doc}}
One of the primary methods of representing knowledge in CLIPS is a rule.
A \sphinxstylestrong{rule} is a collec?tion of conditions and the actions to be taken if
the conditions are met. The developer of an expert system defines the
rules that describe how to solve a problem. Rules execute (or \sphinxstylestrong{fire})
based on the existence or non-existence of facts or instances of
user-defined classes. CLIPS provides the mechanism (the \sphinxstylestrong{inference
engine}) which attempts to match the rules to the cur?rent state of the
system (as represented by the fact-list and instance-list) and applies
the actions.

Throughout this section, the term \sphinxstylestrong{pattern entity} will be used to
refer to either a fact or an instance of a user-defined class.


\section{5.1 Defining Rules}
\label{\detokenize{defrule:defining-rules}}
Rules are defined using the \sphinxstylestrong{defrule} construct.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defrule} \PYG{o}{\PYGZlt{}}\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{comment}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{declaration}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{p}{;} \PYG{n}{Rule} \PYG{n}{Properties}
        \PYG{o}{\textbar{}} \PYG{o}{\PYGZlt{}}\PYG{n}{conditional}\PYG{o}{\PYGZhy{}}\PYG{n}{element}\PYG{o}{\PYGZgt{}}\PYG{o}{*} \PYG{p}{;} \PYG{n}{Left}\PYG{o}{\PYGZhy{}}\PYG{n}{Hand} \PYG{n}{Side} \PYG{p}{(}\PYG{n}{LHS}\PYG{p}{)}
        \PYG{o}{\textbar{}} \PYG{o}{=}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\textbar{}} \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)} \PYG{p}{;} \PYG{n}{Right}\PYG{o}{\PYGZhy{}}\PYG{n}{Hand} \PYG{n}{Side} \PYG{p}{(}\PYG{n}{RHS}\PYG{p}{)}
\end{sphinxVerbatim}

Redefining a currently existing defrule causes the previous defrule with
the same name to be removed even if the new definition has errors in it.
The LHS is made up of a series of conditional elements (CEs) that
typically consist of pattern conditional elements (or just simply
patterns) to be matched against pattern entities. An implicit \sphinxstylestrong{and}
conditional element always surrounds all the patterns on the LHS. The
RHS contains a list of actions to be per?formed when the LHS of the rule
is sat?isfied. In addition, the LHS of a rule may also contain
declarations about the rule?s properties immediately following the
rule?s name and comment (see section 5.4.10 for more details). The arrow
(\sphinxstylestrong{=\textgreater{}}) separates the LHS from the RHS. There is no limit to the number
of conditional elements or ac?tions a rule may have (other than the
limitation placed by actual avail?able memory). Actions are performed
sequentially if, and only if, all condi?tional elements on the LHS are
satisfied.

If no conditional elements are on the LHS, the rule will automatically
be activated. If no ac?tions are on the RHS, the rule can be activated
and fired but nothing will happen.

As rules are defined, they are incrementally reset. This means that CEs
in newly defined rules can be satisfied by pattern entities at the time
the rule is defined, in addition to pattern entities created after the
rule is defined (see sections 13.1.8, 13.6.9, and 13.6.10 for more
details).

\sphinxcode{\sphinxupquote{Example}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{example}\PYG{o}{\PYGZhy{}}\PYG{n}{rule} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is an example of a simple rule}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{p}{(}\PYG{n}{refrigerator} \PYG{n}{light} \PYG{n}{on}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{refrigerator} \PYG{n}{door} \PYG{n+nb}{open}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{refrigerator} \PYG{n}{food} \PYG{n}{spoiled}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\section{5.2 Basic Cycle Of Rule Execution}
\label{\detokenize{defrule:basic-cycle-of-rule-execution}}
Once a knowledge base (in the form of rules) is built and the fact-list
and instance-list is prepared, CLIPS is ready to execute rules. In a
conventional language the programmer explicitly defines the starting
point, the stopping point, and the sequence of operations. With CLIPS,
the program flow does not need to be defined quite so explicitly. The
knowledge (rules) and the data (facts and instances) are separated, and
the inference engine pro?vided by CLIPS is used to apply the knowledge
to the data. The basic execution cycle is as follows:

a) If the rule firing limit has been reached or there is no current
focus, then execution is halted. Otherwise, the top rule on the agenda
of the module that is the current focus is selected for execution. If
there are no rules on that agenda, then the current focus is removed
from the focus stack and the current focus becomes the next module on
the focus stack. If the focus stack is empty, then execution is halted,
otherwise step \sphinxstyleemphasis{a} is executed again. See sections 5.4.10.2, 10.6, 12.2,
and 13.7 for information on the focus stack and the current focus.

b) The right-hand side (RHS) actions of the selected rule are executed.
The use of the \sphinxstylestrong{return} function on the RHS of a rule may remove the
current focus from the focus stack (see sections 10.6 and 12.6.7). The
number of rules fired is incremented for use with the rule firing limit.

c) As a result of step b, rules may be \sphinxstylestrong{activated} or \sphinxstylestrong{deactivated}.
Activated rules (those rules whose conditions are currently satisfied)
are placed on the \sphinxstylestrong{agenda} of the module in which they are defined.
The placement on the agenda is determined by the \sphinxstylestrong{salience} of the
rule and the current \sphinxstylestrong{conflict resolution strategy} (see sections 5.3,
5.4.10, 13.7.5, and 13.7.6). Deactivated rules are removed from the
agenda. If the activations item is being watched (see section 13.2),
then an informational message will be displayed each time a rule is
activated or deactivated.

d) If \sphinxstylestrong{dynamic salience} is being used, the salience values for all
rules on the agenda are reevaluated (see sections 5.4.10, 13.7.9, and
13.7.10). Repeat the cycle beginning with step a.


\section{5.3 Conflict Resolution Strategies}
\label{\detokenize{defrule:conflict-resolution-strategies}}
The \sphinxstylestrong{agenda} is the list of all rules that have their conditions
satisfied (and have not yet been executed). Each module has its own
agenda. The agenda acts similar to a stack (the top rule on the agenda
is the first one to be executed). When a rule is newly activated, its
placement on the agenda is based (in order) on the following factors:

a) Newly activated rules are placed above all rules of lower salience
and below all rules of higher salience.

b) Among rules of equal salience, the current conflict resolution
strategy is used to determine the placement among the other rules of
equal salience.

c) If a rule is activated (along with several other rules) by the same
assertion or retraction of a fact, and steps a and b are unable to
specify an ordering, then the rule is arbitrarily (\sphinxstyleemphasis{not randomly})
ordered in relation to the other rules with which it was activated.
Note, in this respect, the order in which rules are defined has an
arbitrary effect on conflict resolution (which is highly dependent upon
the current underlying implementation of rules). \sphinxstyleemphasis{Do not} depend upon
this arbitrary ordering for the proper execution of your rules.

CLIPS provides seven conflict resolution strategies: depth, breadth,
simplicity, complexity, lex, mea, and random. The default strategy is
depth. The current strategy can be set by using the \sphinxstylestrong{set-strategy}
command (which will reorder the agenda based upon the new strategy).


\subsection{5.3.1 Depth Strategy}
\label{\detokenize{defrule:depth-strategy}}
Newly activated rules are placed above all rules of the same salience.
For example, given that fact-a activates rule-1 and rule-2 and fact-b
activates rule-3 and rule-4, then if fact-a is asserted before fact-b,
rule-3 and rule-4 will be above rule-1 and rule-2 on the agenda.
However, the position of rule-1 relative to rule-2 and rule-3 relative
to rule-4 will be arbitrary.


\subsection{5.3.2 Breadth Strategy}
\label{\detokenize{defrule:breadth-strategy}}
Newly activated rules are placed below all rules of the same salience.
For example, given that fact-a activates rule-1 and rule-2 and fact-b
activates rule-3 and rule-4, then if fact-a is asserted before fact-b,
rule-1 and rule-2 will be above rule-3 and rule-4 on the agenda.
However, the position of rule-1 relative to rule-2 and rule-3 relative
to rule-4 will be arbitrary.


\subsection{5.3.3 Simplicity Strategy}
\label{\detokenize{defrule:simplicity-strategy}}
Among rules of the same salience, newly activated rules are placed above
all activations of rules with equal or higher specificity. The
\sphinxstylestrong{specificity} of a rule is determined by the number of comparisons
that must be performed on the LHS of the rule. Each comparison to a
constant or previously bound variable adds one to the specificity. Each
function call made on the LHS of a rule as part of the :, =, or test
conditional element adds one to the specificity. The boolean functions
\sphinxstylestrong{and}, \sphinxstylestrong{or}, and \sphinxstylestrong{not} do not add to the specificity of a rule,
but their arguments do. Function calls made within a function call do
not add to the specificity of a rule. For example, the following rule

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule example
  (item ?x ?y ?x)
  (test (and (numberp ?x) (\PYGZgt{} ?x (+ 10 ?y)) (\PYGZlt{} ?x 100)))
 =\PYGZgt{})
\end{sphinxVerbatim}

has a specificity of 5. The comparison to the constant item, the
comparison of ?x to its previous binding, and the calls to the
\sphinxstylestrong{numberp}, \sphinxstylestrong{\textless{}}, and \sphinxstylestrong{\textgreater{}} functions each add one to the specificity
for a total of 5. The calls to the \sphinxstylestrong{and} and \sphinxstylestrong{+} functions do not
add to the specificity of the rule.


\subsection{5.3.4 Complexity Strategy}
\label{\detokenize{defrule:complexity-strategy}}
Among rules of the same salience, newly activated rules are placed above
all activations of rules with equal or lower specificity.


\subsection{5.3.5 LEX Strategy}
\label{\detokenize{defrule:lex-strategy}}
Among rules of the same salience, newly activated rules are placed using
the OPS5 strategy of the same name. First the recency of the pattern
entities that activated the rule is used to determine where to place the
activation. Every fact and instance is marked internally with a ?time
tag? to indicate its relative recency with respect to every other fact
and instance in the system. The pattern entities associated with each
rule activation are sorted in descending order for determining
placement. An activation with a more recent pattern entities is placed
before activations with less recent pattern entities. To determine the
placement order of two activations, compare the sorted time tags of the
two activations one by one starting with the largest time tags. The
comparison should continue until one activation?s time tag is greater
than the other activation?s corresponding time tag. The activation with
the greater time tag is placed before the other activation on the
agenda.

If one activation has more pattern entities than the other activation
and the compared time tags are all identical, then the activation with
more time tags is placed before the other activation on the agenda. If
two activations have the exact same recency, the activation with the
higher specificity is placed above the activation with the lower
specificity. Unlike OPS5, the \sphinxstyleemphasis{not} conditional elements in CLIPS have
pseudo time tags that are used by the LEX conflict resolution strategy.
The time tag of a \sphinxstyleemphasis{not} CE is always less than the time tag of a pattern
entity, but greater than the time tag of a \sphinxstyleemphasis{not} CE that was
instantiated after the \sphinxstyleemphasis{not} CE in question.

As an example, the following six activations have been listed in their
LEX ordering (where the comma at the end of the activation indicates the
presence of a \sphinxstyleemphasis{not} CE). Note that a fact?s time tag is not necessarily
the same as it?s index (since instances are also assigned time tags),
but if one fact?s index is greater than another facts?s index, then it?s
time tag is also greater. For this example, assume that the time tags
and indices are the same.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

Shown following are the same activations with the fact indices sorted as
they would be by the LEX strategy for comparison.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\subsection{5.3.6 MEA Strategy}
\label{\detokenize{defrule:mea-strategy}}
Among rules of the same salience, newly activated rules are placed using
the OPS5 strategy of the same name. First the time tag of the pattern
entity associated with the first pattern is used to determine where to
place the activation. An activation thats first pattern?s time tag is
greater than another activations first pattern?s time tag is placed
before the other activation on the agenda. If both activations have the
same time tag associated with the first pattern, then the LEX strategy
is used to determine placement of the activation. Again, as with the
CLIPS LEX strategy, negated patterns have pseudo time tags.

As an example, the following six activations have been listed in their
MEA ordering (where the comma at the end of the activation indicates the
presence of a negated pattern).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}
\end{sphinxVerbatim}


\subsection{5.3.7 Random Strategy}
\label{\detokenize{defrule:random-strategy}}
Each activation is assigned a random number that is used to determine
its placement among activations of equal salience. This random number is
preserved when the strategy is changed so that the same ordering is
reproduced when the random strategy is selected again (among activations
that were on the agenda when the strategy was originally changed).

A conflict resolution strategy is an implicit mechanism for specifying
the order in which rules of equal salience should be executed. In early
expert system tools, this was often the only mechanism provided to
specify the order. Because the mechanism is implicit, it?s not possible
to determine the programmer?s original intent simply by looking at the
code. {[}Of course in the real world there isn?t a need to guess the
original intent because the code is riddled with helpful comments.{]}
Rather than explicitly indicating that rule A should be executed before
rule B, the order of execution is implicitly determined by the order in
which facts are asserted and the complexity of the rules. The assumption
one must make when examining the code is that the original programmer
carefully analyzed the rules and followed the necessary conventions so
that the rules execute in the appropriate sequence.

Because they require explicit declarations, the preferred mechanisms in
CLIPS for ordering the execution of rules are salience and modules.
Salience allows one to explicitly specify that one rule should be
executed before another rule. Modules allow one to explicitly specify
that all of the rules in a particular group (module) should be executed
before all of the rules in a different group. Thus, when designing a
program the following convention should be followed: if two rules have
the same salience, are in the same module, and are activated
concurrently, then the order in which they are executed should not
matter. For example, the following two rules need correction because
they can be activated at the same time, but the order in which they
execute matters:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule rule\PYGZhy{}1
  (factoid a)
  =\PYGZgt{}
  (assert (factoid b)))

(defrule rule\PYGZhy{}2
  ?f \PYGZlt{}\PYGZhy{} (factoid a)
  (factoid d)
  =\PYGZgt{}
  (retract ?f)
  (assert (factoid c)))
\end{sphinxVerbatim}

Programmers should also be careful to avoid overusing salience. Trying
to unravel the relationships between dozens of salience values can be
just as confusing as the implicit use of a conflict resolution strategy
in determining rule execution order. It?s rarely necessary to use more
than five to ten salience values in a well-designed program.

Most programs should use the default conflict resolution strategy of
depth. The breadth, simplicity, and complexity strategies are provided
largely for academic reasons (i.e. the study of conflict resolution
strategies). The lex and mea strategies are provided to help in
converting OPS5 programs to CLIPS.

The random strategy is useful for testing. Because this strategy
randomly orders activations having the same salience, it is useful in
detecting whether the execution order of rules with the same salience
effects the program behavior. Before running a program with the random
strategy, first seed the random number generator using the \sphinxstylestrong{seed}
function. The same seed value can be subsequently be used if it is
necessary to replicate the results of the program run.


\section{5.4 LHS Syntax}
\label{\detokenize{defrule:lhs-syntax}}
This section describes the syntax used on the LHS of a rule. The LHS of
a CLIPS rule is made up of a series of conditional elements (CEs) that
must be satisfied for the rule to be placed on the agenda. There are
eight types of conditional elements: \sphinxstylestrong{pattern} CEs, \sphinxstylestrong{test} CEs,
\sphinxstylestrong{and} CEs, \sphinxstylestrong{or} CEs, \sphinxstylestrong{not} CEs, \sphinxstylestrong{exists} CEs, \sphinxstylestrong{forall} CEs,
and \sphinxstylestrong{logical} CEs. The \sphinxstylestrong{pattern} CE is the most basic and commonly
used conditional element. \sphinxstylestrong{Pattern} CEs contain constraints that are
used to determine if any pattern entities (facts or instances) satisfy
the pattern. The \sphinxstylestrong{test} CE is used to evaluate expressions as part of
the pattern-matching process. The \sphinxstylestrong{and} CE is used to specify that an
entire group of CEs must all be satisfied. The \sphinxstylestrong{or} CE is used to
specify that only one of a group of CEs must be satisfied. The \sphinxstylestrong{not}
CE is used to specify that a CE must not be satisfied. The \sphinxstylestrong{exists} CE
is used to test for the occurence of at least one partial match for a
set of CEs. The \sphinxstylestrong{forall} CE is used to test that a set of CEs is
satisfied for every partial match of a specified CE. Finally, the
\sphinxstylestrong{logical} CE allows assertions of facts and the creation of instances
on the RHS of a rule to be logically dependent upon pattern entities
matching patterns on the LHS of a rule (truth maintenance).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{conditional}\PYG{o}{\PYGZhy{}}\PYG{n}{element}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{pattern}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{assigned}\PYG{o}{\PYGZhy{}}\PYG{n}{pattern}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
  \PYG{o}{\PYGZlt{}}\PYG{o+ow}{not}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
  \PYG{o}{\PYGZlt{}}\PYG{o+ow}{and}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
  \PYG{o}{\PYGZlt{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{logical}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{test}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{exists}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{forall}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{5.4.1 Pattern Conditional Element}
\label{\detokenize{defrule:pattern-conditional-element}}
\sphinxstylestrong{Pattern conditional elements} consist of a collection of field
constraints, wildcards, and variables which are used to constrain the
set of facts or instances which match the pattern CE. A pattern CE is
satisfied by each and every pattern entity that satisfies its
constraints. \sphinxstylestrong{Field constraints} are a set of constraints that are
used to test a single field or slot of a pattern entity. A field
constraint may consist of only a single literal constraint:literal;,
however, it may also consist of several constraints connected together.
In addition to literal constraints, CLIPS provides three other types of
constraints: connective constraints, predicate constraints, and return
value constraints. Wildcards are used within pattern CEs to indicate
that a single field or group of fields can be matched by anything.
Variables are used to store the value of a field so that it can be used
later on the LHS of a rule in other conditional elements or on the RHS
of a rule as an argument to an action.

The first field of any pattern \sphinxstyleemphasis{must} be a symbol and can not use any
other constraints. This first field is used by CLIPS to determine if the
pattern applies to an ordered fact, a template fact, or an instance. The
symbol \sphinxstyleemphasis{object} is reserved to indicate an object pattern. Any other
symbol used must correspond to a deftemplate name (or an implied
deftemplate will be created). Slot names must also be symbols and cannot
contain any other constraints.

For object and deftemplate patterns, a single field slot can only
contain one field constraint and that field constraint must only be able
to match a single field (no multifield wildcards or variables). A
multifield slot can contain any number of field constraints.

The examples and syntax shown in the following sections will be for
ordered and deftemplate fact patterns. Section 5.4.1.7 will discuss
differences between deftemplate patterns and object patterns. The
following constructs are used by the examples.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deffacts} \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{facts}
  \PYG{p}{(}\PYG{n}{data} \PYG{l+m+mf}{1.0} \PYG{n}{blue} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{data} \PYG{l+m+mi}{1} \PYG{n}{blue}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{data} \PYG{l+m+mi}{1} \PYG{n}{blue} \PYG{n}{red}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{data} \PYG{l+m+mi}{1} \PYG{n}{blue} \PYG{n}{RED}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{data} \PYG{l+m+mi}{1} \PYG{n}{blue} \PYG{n}{red} \PYG{l+m+mf}{6.9}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{deftemplate} \PYG{n}{person}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{name}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{age}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{multislot} \PYG{n}{friends}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{deffacts} \PYG{n}{people}
  \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Joe}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Bob}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Joe}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{34}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Sue}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{34}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Sue}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{5.4.1.1 Literal Constraints}
\label{\detokenize{defrule:literal-constraints}}
The most basic constraint that can be used in a pattern CE is one which
precisely defines the exact value that will match a field. This is
called a \sphinxstylestrong{literal constraint}. A \sphinxstylestrong{literal pattern CE} consists
entirely of constants such as floats, integers, symbols, strings, and
instance names. It does not contain any variables or wildcards. All
constraints in a literal pattern must be matched exactly by all fields
of a pattern entity.

An ordered pattern conditional element containing only literals has the
following basic syntax:

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{constant}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{o}{\PYGZlt{}}\PYG{n}{constant}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

A deftemplate pattern conditional element containing only literals has
the following basic syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{constant}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
  \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{constant}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Example 1

This example utilizes the \sphinxstyleemphasis{data-facts} deffacts shown in section 5.4.1.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defrule} \PYG{n}{find}\PYG{o}{\PYGZhy{}}\PYG{n}{data} \PYG{p}{(}\PYG{n}{data} \PYG{l+m+mi}{1} \PYG{n}{blue} \PYG{n}{red}\PYG{p}{)} \PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{reset}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{l+m+mi}{0} \PYG{n}{find}\PYG{o}{\PYGZhy{}}\PYG{n}{data}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{1} \PYG{n}{activation}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{facts}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0} \PYG{p}{(}\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n}{fact}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{n}{data} \PYG{l+m+mf}{1.0} \PYG{n}{blue} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{n}{data} \PYG{l+m+mi}{1} \PYG{n}{blue}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{p}{(}\PYG{n}{data} \PYG{l+m+mi}{1} \PYG{n}{blue} \PYG{n}{red}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{p}{(}\PYG{n}{data} \PYG{l+m+mi}{1} \PYG{n}{blue} \PYG{n}{RED}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5} \PYG{p}{(}\PYG{n}{data} \PYG{l+m+mi}{1} \PYG{n}{blue} \PYG{n}{red} \PYG{l+m+mf}{6.9}\PYG{p}{)}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{6} \PYG{n}{facts}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Example 2

This example utilizes the \sphinxstyleemphasis{person} deftemplate and \sphinxstyleemphasis{people} deffacts
shown in section 5.4.1.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{Find}\PYG{o}{\PYGZhy{}}\PYG{n}{Bob}
\PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Bob}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{Find}\PYG{o}{\PYGZhy{}}\PYG{n}{Sue}
\PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{34}\PYG{p}{)} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Sue}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{reset}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{l+m+mi}{0} \PYG{n}{Find}\PYG{o}{\PYGZhy{}}\PYG{n}{Sue}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}
\PYG{l+m+mi}{0} \PYG{n}{Find}\PYG{o}{\PYGZhy{}}\PYG{n}{Bob}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{2} \PYG{n}{activations}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{facts}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0} \PYG{p}{(}\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n}{fact}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Joe}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{20}\PYG{p}{)} \PYG{p}{(}\PYG{n}{friends}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Bob}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{20}\PYG{p}{)} \PYG{p}{(}\PYG{n}{friends}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Joe}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{34}\PYG{p}{)} \PYG{p}{(}\PYG{n}{friends}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Sue}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{34}\PYG{p}{)} \PYG{p}{(}\PYG{n}{friends}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5} \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Sue}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{20}\PYG{p}{)} \PYG{p}{(}\PYG{n}{friends}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{6} \PYG{n}{facts}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{5.4.1.2 Wildcards Single- and Multifield}
\label{\detokenize{defrule:wildcards-single-and-multifield}}
CLIPS has two \sphinxstylestrong{wildcard} symbols that may be used to match fields in a
pat?tern. CLIPS in?terprets these wildcard symbols as standing in place
of some part of a pattern entity. The \sphinxstylestrong{single-field wild?card},
denoted by a question mark character (?), matches any value stored in
exactly one field in the pattern entity. The \sphinxstylestrong{multifield wildcard},
denoted by a dollar sign followed by a question mark (\$?), matches any
value in \sphinxstyleemphasis{zero} or more fields in a pattern entity. Single-field and
multifield wildcards may be combined in a single pattern in any
combination. It is illegal to use a multifield wildcard in a single
field slot of a deftemplate or object pattern. By default, an
unspecified single-field slot in a deftemplate/object pattern is matched
against an implied single-field wildcard. Similarly, an unspecified
multifield slot in a deftemplate/object pattern is matched against an
implied multifield-wildcard.

An ordered pattern conditional element containing only literals and
wildcards has the following basic syntax:

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZlt{}constraint\PYGZhy{}1\PYGZgt{} ... \PYGZlt{}constraint\PYGZhy{}n\PYGZgt{})

where \PYGZlt{}constraint\PYGZgt{} ::= \PYGZlt{}constant\PYGZgt{} \textbar{} ? \textbar{} \PYGZdl{}?
\end{sphinxVerbatim}

A deftemplate pattern conditional element containing only literals and
wildcards has the following basic syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{constraint}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
   \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{constraint}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Example 1

This example utilizes the \sphinxstyleemphasis{data-facts} deffacts shown in section 5.4.1.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    CLIPS\PYGZgt{} (clear)
    CLIPS\PYGZgt{}
    (defrule find\PYGZhy{}data
    (data ? blue red \PYGZdl{}?)
    =\PYGZgt{})
    CLIPS\PYGZgt{} (reset)
    CLIPS\PYGZgt{} (agenda)
    0 find\PYGZhy{}data: f\PYGZhy{}5
    0 find\PYGZhy{}data: f\PYGZhy{}3
    For a total of 2 activations.
    CLIPS\PYGZgt{} (facts)
    f\PYGZhy{}0 (initial\PYGZhy{}fact)
    f\PYGZhy{}1 (data 1.0 blue \PYGZdq{}red\PYGZdq{})
    f\PYGZhy{}2 (data 1 blue)
    f\PYGZhy{}3 (data 1 blue red)
    f\PYGZhy{}4 (data 1 blue RED)
    f\PYGZhy{}5 (data 1 blue red 6.9)
    For a total of 6 facts.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

Example 2

This example utilizes the \sphinxstyleemphasis{person} deftemplate and \sphinxstyleemphasis{people} deffacts
shown in section 5.4.1.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{persons}
\PYG{p}{(}\PYG{n}{person}\PYG{p}{)}
\PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{reset}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{persons}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{persons}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{persons}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{persons}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{persons}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{5} \PYG{n}{activations}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{facts}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0} \PYG{p}{(}\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n}{fact}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Joe}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{20}\PYG{p}{)} \PYG{p}{(}\PYG{n}{friends}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Bob}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{20}\PYG{p}{)} \PYG{p}{(}\PYG{n}{friends}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Joe}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{34}\PYG{p}{)} \PYG{p}{(}\PYG{n}{friends}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Sue}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{34}\PYG{p}{)} \PYG{p}{(}\PYG{n}{friends}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5} \PYG{p}{(}\PYG{n}{person} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Sue}\PYG{p}{)} \PYG{p}{(}\PYG{n}{age} \PYG{l+m+mi}{20}\PYG{p}{)} \PYG{p}{(}\PYG{n}{friends}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{6} \PYG{n}{facts}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Multifield wildcard and literal constraints can be combined to yield
some powerful pattern-matching capabilities. A pattern to match all of
the facts that have the symbol YELLOW in any field (other than the
first) could be written as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(data \PYGZdl{}? YELLOW \PYGZdl{}?)
\end{sphinxVerbatim}

Some examples of what this pattern would match are

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{data} \PYG{n}{YELLOW} \PYG{n}{blue} \PYG{n}{red} \PYG{n}{green}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{data} \PYG{n}{YELLOW} \PYG{n}{red}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{data} \PYG{n}{red} \PYG{n}{YELLOW}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{data} \PYG{n}{YELLOW}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{data} \PYG{n}{YELLOW} \PYG{n}{data} \PYG{n}{YELLOW}\PYG{p}{)}
\end{sphinxVerbatim}

The last fact will match twice since YELLOW appears twice in the fact.
The use of multifield wildcards should be confined to cases of patterns
in which the single-field wildcard cannot create a pattern that
satisfies the match required, since the multifield wildcard produces
every possible match combination that can be derived from a pattern
entity. This derivation of matches requires a significant amount of time
to perform when compared to the time needed to perform a single-field
match.


\subsubsection{5.4.1.3 Variables Single- and Multifield}
\label{\detokenize{defrule:variables-single-and-multifield}}
Wildcard symbols replace portions of a pattern and accept any value. The
value of the field being replaced may be captured in a \sphinxstylestrong{variable} for
comparison, display, or other manipulations. This is done by directly
following the wildcard symbol with a variable name.

Expanding on the syntax definition given in section 5.4.1.2 now gives:

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}constraint\PYGZgt{} ::= \PYGZlt{}constant\PYGZgt{} \textbar{} ? \textbar{} \PYGZdl{}? \textbar{}
  \PYGZlt{}single\PYGZhy{}field\PYGZhy{}variable\PYGZgt{} \textbar{}
  \PYGZlt{}multifield\PYGZhy{}variable\PYGZgt{}

\PYGZlt{}single\PYGZhy{}field\PYGZhy{}variable\PYGZgt{} ::= ?\PYGZlt{}variable\PYGZhy{}symbol\PYGZgt{}

\PYGZlt{}multifield\PYGZhy{}variable\PYGZgt{} ::= \PYGZdl{}?\PYGZlt{}variable\PYGZhy{}symbol\PYGZgt{}
\end{sphinxVerbatim}

where \textless{}variable-symbol\textgreater{} is similar to a symbol, except that it must
start with an alphabetic char?acter. Double quotes are not allowed as
part of a variable name; i.e. a string cannot be used for a variable
name. The rules for pattern-matching are similar to those for wildcard
symbols. On its first appearance, a variable acts just like a wildcard
in that it will bind to any value in the field(s). However, later
appearances of the variable require the field(s) to match the binding of
the variable. The binding will only be true within the scope of the rule
in which it occurs. Each rule has a private list of variable names with
their associated values; thus, variables are local to a rule. Bound
vari?ables can be passed to external functions. The \$ operator has
special significance on the LHS as a pattern-matching operator to
indicate that zero or more fields need to be matched. In other places
(such as the RHS of a rule), the \$ in front of a variable indicates that
sequence expansion should take place before calling the function. Thus,
when passed as parameters in function calls (either on the LHS or RHS of
a rule), multifield variables should not be preceded by the \$ (unless
sequence expansion is desired). All other uses of a multifield variable
on the LHS of a rule, however, should use the \$. It is illegal to use a
multifield variable in a single field slot of a deftemplate/object
pattern.

Example 1

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{} (reset)
CLIPS\PYGZgt{} (assert (data 2 blue green)
(data 1 blue)
(data 1 blue red))
\PYGZlt{}Fact\PYGZhy{}3\PYGZgt{}
CLIPS\PYGZgt{} (facts)
f\PYGZhy{}0 (initial\PYGZhy{}fact)
f\PYGZhy{}1 (data 2 blue green)
f\PYGZhy{}2 (data 1 blue)
f\PYGZhy{}3 (data 1 blue red)
For a total of 4 facts.
CLIPS\PYGZgt{}
(defrule find\PYGZhy{}data\PYGZhy{}1
  (data ?x ?y ?z)
  =\PYGZgt{}
  (printout t ?x \PYGZdq{} : \PYGZdq{} ?y \PYGZdq{} : \PYGZdq{} ?z crlf))

CLIPS\PYGZgt{} (run)
1 : blue : red
2 : blue : green
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

Example 2

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (reset)
CLIPS\PYGZgt{} (assert (data 1 blue)
(data 1 blue red)
(data 1 blue red 6.9))
\PYGZlt{}Fact\PYGZhy{}3\PYGZgt{}
CLIPS\PYGZgt{} (facts)
f\PYGZhy{}0 (initial\PYGZhy{}fact)
f\PYGZhy{}1 (data 1 blue)
f\PYGZhy{}2 (data 1 blue red)
f\PYGZhy{}3 (data 1 blue red 6.9)
For a total of 4 facts.
CLIPS\PYGZgt{}
(defrule find\PYGZhy{}data\PYGZhy{}1
  (data ?x \PYGZdl{}?y ?z)
  =\PYGZgt{}
 (printout t \PYGZdq{}?x = \PYGZdq{} ?x crlf \PYGZdq{}?y = \PYGZdq{} ?y crlf \PYGZdq{}?z = \PYGZdq{} ?z crlf \PYGZdq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZdq{} crlf))

CLIPS\PYGZgt{} (run)
?x = 1
?y = (blue red)
?z = 6.9
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
?x = 1
?y = (blue)
?z = red
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
?x = 1
?y = ()
?z = blue
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

Once the initial binding of a variable occurs, all references to that
variable have to match the value that the first binding matched. This
applies to both single- and multi?field variables. It also applies
across patterns.

Example 3

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(deffacts data
  (data red green)
  (data purple blue)
  (data purple green)
  (data red blue green)
  (data purple blue green)
  (data purple blue brown))
CLIPS\PYGZgt{}
(defrule find\PYGZhy{}data\PYGZhy{}1
  (data red ?x)
  (data purple ?x)
  =\PYGZgt{})

CLIPS\PYGZgt{}
(defrule find\PYGZhy{}data\PYGZhy{}2
  (data red \PYGZdl{}?x)
  (data purple \PYGZdl{}?x)
  =\PYGZgt{})

CLIPS\PYGZgt{} (reset)
CLIPS\PYGZgt{} (facts)
f\PYGZhy{}0 (initial\PYGZhy{}fact)
f\PYGZhy{}1 (data red green)
f\PYGZhy{}2 (data purple blue)
f\PYGZhy{}3 (data purple green)
f\PYGZhy{}4 (data red blue green)
f\PYGZhy{}5 (data purple blue green)
f\PYGZhy{}6 (data purple blue brown)
For a total of 7 facts.

CLIPS\PYGZgt{} (agenda)
0 find\PYGZhy{}data\PYGZhy{}2: f\PYGZhy{}4,f\PYGZhy{}5
0 find\PYGZhy{}data\PYGZhy{}1: f\PYGZhy{}1,f\PYGZhy{}3
0 find\PYGZhy{}data\PYGZhy{}2: f\PYGZhy{}1,f\PYGZhy{}3
For a total of 3 activations.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{5.4.1.4 Connective Constraints}
\label{\detokenize{defrule:connective-constraints}}
Three \sphinxstylestrong{connective constraints} are available for connecting individual
constraints and variables to each other. These are the \& (and), \textbar{} (or),
and \textasciitilde{} (not) connective constraints. The \& constraint is satisfied if the
two adjoining constraints are satisfied. The \textbar{} constraint is satisfied
if either of the two adjoining constraints is satisfied. The \textasciitilde{}
constraint is satisfied if the following constraint is not satisfied.
The connective constraints can be com?bined in almost any manner or
number to constrain the value of specific fields while pattern-matching.
The \textasciitilde{} constraint has highest precedence, followed by the \& constraint,
followed by the \textbar{} constraint. Otherwise, evaluation of multiple
constraints can be considered to occur from left to right. There is one
exception to the precedence rules that applies to the binding occurrence
of a variable. If the first constraint is a variable followed by an \&
connective constraint, then the first constraint is treated as a
separate constraint which also must be satisified. Thus the constraint
?x\&red\textbar{}blue is treated like ?x\&(red\textbar{}blue) rather than (?x\&red)\textbar{}blue as
the normal precedence rules would indicate.

Basic Syntax

Connective constraints have the following basic syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{term}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}  \PYG{o}{\PYGZlt{}}\PYG{n}{term}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{o}{\PYGZam{}}  \PYG{o}{\PYGZlt{}}\PYG{n}{term}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{term}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}} \PYG{o}{\PYGZlt{}}\PYG{n}{term}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{o}{\textbar{}}  \PYG{o}{\PYGZlt{}}\PYG{n}{term}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZti{}} \PYG{o}{\PYGZlt{}}\PYG{n}{term}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

where \textless{}term\textgreater{} could be a single-field variable, multifield variable,
constant, or connected constraint.

Expanding on the syntax definition given in section 5.4.1.3 now gives:

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}constraint\PYGZgt{} ::= ? \textbar{} \PYGZdl{}? \textbar{} \PYGZlt{}connected\PYGZhy{}constraint\PYGZgt{}

\PYGZlt{}connected\PYGZhy{}constraint\PYGZgt{} ::= \PYGZlt{}single\PYGZhy{}constraint\PYGZgt{} \textbar{}
  \PYGZlt{}single\PYGZhy{}constraint\PYGZgt{} \PYGZam{} \PYGZlt{}connected\PYGZhy{}constraint\PYGZgt{} \textbar{}
  \PYGZlt{}single\PYGZhy{}constraint\PYGZgt{} \textbar{} \PYGZlt{}connected\PYGZhy{}constraint\PYGZgt{}

\PYGZlt{}single\PYGZhy{}constraint\PYGZgt{} ::= \PYGZlt{}term\PYGZgt{} \textbar{} \PYGZti{}\PYGZlt{}term\PYGZgt{}

\PYGZlt{}term\PYGZgt{} ::= \PYGZlt{}constant\PYGZgt{} \textbar{} \PYGZlt{}single\PYGZhy{}field\PYGZhy{}variable\PYGZgt{} \textbar{} \PYGZlt{}multifield\PYGZhy{}variable\PYGZgt{}
\end{sphinxVerbatim}

The \& constraint typically is used only in conjunction with other
constraints or variable bindings. Notice that connective constraints may
be used together and/or with variable bindings. If the first term of a
connective constraint is the first occurrence of a variable name, then
the field will be constrained only by the remaining field constraints.
The variable will be bound to the value of the field. If the variable
has been bound previously, it is considered an additional con?straint
along with the remaining field constraints; i.e., the field must have
the same value already bound to the variable and must satisfy the field
constraints.

Example 1

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{deftemplate} \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{p}{(}\PYG{n}{slot} \PYG{n}{value}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{deffacts} \PYG{n}{AB}
  \PYG{p}{(}\PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{A} \PYG{n}{green}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{A} \PYG{n}{blue}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{p}{(}\PYG{n}{value} \PYG{n}{red}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{p}{(}\PYG{n}{value} \PYG{n}{blue}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{example1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
  \PYG{p}{(}\PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{A} \PYG{o}{\PYGZti{}}\PYG{n}{blue}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{example1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}
  \PYG{p}{(}\PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{p}{(}\PYG{n}{value} \PYG{o}{\PYGZti{}}\PYG{n}{red}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZti{}}\PYG{n}{green}\PYG{p}{)}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{example1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
  \PYG{p}{(}\PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{p}{(}\PYG{n}{value} \PYG{n}{green}\PYG{o}{\textbar{}}\PYG{n}{red}\PYG{p}{)}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{reset}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{facts}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0} \PYG{p}{(}\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n}{fact}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{A} \PYG{n}{green}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{A} \PYG{n}{blue}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{p}{(}\PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{p}{(}\PYG{n}{value} \PYG{n}{red}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{p}{(}\PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{p}{(}\PYG{n}{value} \PYG{n}{blue}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{5} \PYG{n}{facts}\PYG{o}{.}

\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{l+m+mi}{0} \PYG{n}{example1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}
\PYG{l+m+mi}{0} \PYG{n}{example1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
\PYG{l+m+mi}{0} \PYG{n}{example1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{3} \PYG{n}{activations}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Example 2

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  CLIPS\PYGZgt{} (clear)
  CLIPS\PYGZgt{} (deftemplate data\PYGZhy{}B (slot value))
  CLIPS\PYGZgt{}
  (deffacts B
(data\PYGZhy{}B (value red))
    (data\PYGZhy{}B (value blue)))
  CLIPS\PYGZgt{}
  (defrule example2\PYGZhy{}1
    (data\PYGZhy{}B (value ?x\PYGZam{}\PYGZti{}red\PYGZam{}\PYGZti{}green))
    =\PYGZgt{}
    (printout t \PYGZdq{}?x in example2\PYGZhy{}1 = \PYGZdq{} ?x crlf))
  CLIPS\PYGZgt{}
  (defrule example2\PYGZhy{}2
    (data\PYGZhy{}B (value ?x\PYGZam{}green\textbar{}red))
    =\PYGZgt{}
    (printout t \PYGZdq{}?x in example2\PYGZhy{}2 = \PYGZdq{} ?x crlf))
  CLIPS\PYGZgt{} (reset)
  CLIPS\PYGZgt{} (run)
  ?x in example2\PYGZhy{}1 = blue
  ?x in example2\PYGZhy{}2 = red
  CLIPS\PYGZgt{}
\end{sphinxVerbatim}

Example 3

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{} (deftemplate data\PYGZhy{}B (slot value))
CLIPS\PYGZgt{}
(deffacts AB
  (data\PYGZhy{}A green)
  (data\PYGZhy{}A blue)
  (data\PYGZhy{}B (value red))
  (data\PYGZhy{}B (value blue)))
CLIPS\PYGZgt{}
(defrule example3\PYGZhy{}1
  (data\PYGZhy{}A ?x\PYGZam{}\PYGZti{}green)
  (data\PYGZhy{}B (value ?y\PYGZam{}\PYGZti{}?x))
=\PYGZgt{})
CLIPS\PYGZgt{}
(defrule example3\PYGZhy{}2
  (data\PYGZhy{}A ?x)
  (data\PYGZhy{}B (value ?x\PYGZam{}green\textbar{}blue))
  =\PYGZgt{})
CLIPS\PYGZgt{}
(defrule example3\PYGZhy{}3
  (data\PYGZhy{}A ?x)
  (data\PYGZhy{}B (value ?y\PYGZam{}blue\textbar{}?x))
  =\PYGZgt{})
CLIPS\PYGZgt{} (reset)
CLIPS\PYGZgt{} (facts)
f\PYGZhy{}0 (initial\PYGZhy{}fact)
f\PYGZhy{}1 (data\PYGZhy{}A green)
f\PYGZhy{}2 (data\PYGZhy{}A blue)
f\PYGZhy{}3 (data\PYGZhy{}B (value red))
f\PYGZhy{}4 (data\PYGZhy{}B (value blue))
For a total of 5 facts.

CLIPS\PYGZgt{} (agenda)
0 example3\PYGZhy{}3: f\PYGZhy{}1,f\PYGZhy{}4
0 example3\PYGZhy{}3: f\PYGZhy{}2,f\PYGZhy{}4
0 example3\PYGZhy{}2: f\PYGZhy{}2,f\PYGZhy{}4
0 example3\PYGZhy{}1: f\PYGZhy{}2,f\PYGZhy{}3
For a total of 4 activations.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{5.4.1.5 Predicate Constraints}
\label{\detokenize{defrule:predicate-constraints}}
Sometimes it becomes necessary to constrain a field based upon the truth
of a given boolean expression. CLIPS allows the use of a \sphinxstylestrong{predicate
constraint} to restrict a field in this manner. The predicate
constraint allows a \sphinxstylestrong{predicate function} (one returning the symbol
FALSE for unsatisfied and a non-FALSE value for satisfied) to be called
during the pattern-matching process. If the predicate function returns a
non-FALSE value, the constraint is satisfied. If the predicate function
returns the symbol FALSE, the constraint is not satisfied. A predicate
constraint is invoked by following a colon with an appropriate function
call to a predicate function. Typically, predicate constraints are used
in conjunction with a connective constraint and a variable binding (i.e.
you have to bind the variable to be tested and then connect it to the
predicate constraint).

Basic Syntax

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{call}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Expanding on the syntax definition given in section 5.4.1.4 now gives:

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{term}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{constant}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{single}\PYG{o}{\PYGZhy{}}\PYG{n}{field}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{multifield}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}}  \PYG{o}{\textbar{}}
  \PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{call}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Multiple predicate constraints may be used to constrain a single field.
CLIPS provides several predicate functions (see section 12.2). Users
also may develop their own predicate functions.

Example 1

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defrule example\PYGZhy{}1
  (data ?x\PYGZam{}:(numberp ?x))
  =\PYGZgt{})
CLIPS\PYGZgt{} (assert (data 1) (data 2) (data red))
\PYGZlt{}Fact\PYGZhy{}3\PYGZgt{}
CLIPS\PYGZgt{} (agenda)
0 example\PYGZhy{}1: f\PYGZhy{}2
0 example\PYGZhy{}1: f\PYGZhy{}1
For a total of 2 activations.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

Example 2

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defrule example\PYGZhy{}2
  (data ?x\PYGZam{}\PYGZti{}:(symbolp ?x))
  =\PYGZgt{})
CLIPS\PYGZgt{} (assert (data 1) (data 2) (data red))
\PYGZlt{}Fact\PYGZhy{}3\PYGZgt{}
CLIPS\PYGZgt{} (agenda)
0 example\PYGZhy{}2: f\PYGZhy{}2
0 example\PYGZhy{}2: f\PYGZhy{}1
For a total of 2 activations.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

Example 3

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defrule example\PYGZhy{}3
  (data ?x\PYGZam{}:(numberp ?x)\PYGZam{}:(oddp ?x))
  =\PYGZgt{})
CLIPS\PYGZgt{} (assert (data 1) (data 2) (data red))
\PYGZlt{}Fact\PYGZhy{}3\PYGZgt{}
CLIPS\PYGZgt{} (agenda)
0 example\PYGZhy{}3: f\PYGZhy{}1
For a total of 1 activation.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

Example 4

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defrule example\PYGZhy{}4
  (data ?y)
  (data ?x\PYGZam{}:(\PYGZgt{} ?x ?y))
  =\PYGZgt{})
CLIPS\PYGZgt{} (assert (data 3) ; f\PYGZhy{}1
(data 5) ; f\PYGZhy{}2
(data 9)) ; f\PYGZhy{}3
\PYGZlt{}Fact\PYGZhy{}3\PYGZgt{}
CLIPS\PYGZgt{} (agenda)
0 example\PYGZhy{}4: f\PYGZhy{}1,f\PYGZhy{}3
0 example\PYGZhy{}4: f\PYGZhy{}2,f\PYGZhy{}3
0 example\PYGZhy{}4: f\PYGZhy{}1,f\PYGZhy{}2
For a total of 3 activations.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

Example 5

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defrule example\PYGZhy{}5
  (data \PYGZdl{}?x\PYGZam{}:(\PYGZgt{} (length\PYGZdl{} ?x) 2))
  =\PYGZgt{})
CLIPS\PYGZgt{} (assert (data 1) ; f\PYGZhy{}1
(data 1 2) ; f\PYGZhy{}2
(data 1 2 3)) ; f\PYGZhy{}3
\PYGZlt{}Fact\PYGZhy{}3\PYGZgt{}
CLIPS\PYGZgt{} (agenda)
0 example\PYGZhy{}5: f\PYGZhy{}3
For a total of 1 activation.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{5.4.1.6 Return Value Constraints}
\label{\detokenize{defrule:return-value-constraints}}
It is possible to use the return value of an external function to
constrain the value of a field. The \sphinxstylestrong{return value constraint} (=)
allows the user to call external functions from inside a pat?tern. (This
constraint is different from the com?parison function that uses the same
symbol. The difference can be determined from context.) The return value
must be one of the primitive data types. This value is incorporated
directly into the pattern at the position at which the function was
called as if it were a literal constraint, and any matching pat?terns
must match this value as though the rule were typed with that value.
Note that the function is evaluated each time the constraint is checked
(not just once).

Basic Syntax

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{call}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Expanding on the syntax definition given in section 5.4.1.5 now gives:

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{term}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{constant}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{single}\PYG{o}{\PYGZhy{}}\PYG{n}{field}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{multifield}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{call}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{call}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Example 1

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{} (deftemplate data (slot x) (slot y))
CLIPS\PYGZgt{}
(defrule twice
  (data (x ?x) (y =(\PYGZbs{}* 2 ?x)))
  =\PYGZgt{})
CLIPS\PYGZgt{} (assert (data (x 2) (y 4)) ; f\PYGZhy{}1
(data (x 3) (y 9))) ; f\PYGZhy{}2
\PYGZlt{}Fact\PYGZhy{}1\PYGZgt{}
CLIPS\PYGZgt{} (agenda)
0 twice: f\PYGZhy{}1
For a total of 1 activation.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

Example 2

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass DATA (is\PYGZhy{}a USER)
  (slot x))
CLIPS\PYGZgt{}
(defrule return\PYGZhy{}value\PYGZhy{}example\PYGZhy{}2
  (object (is\PYGZhy{}a DATA)
  (x ?x1))
  (object (is\PYGZhy{}a DATA)
  (x ?x2\PYGZam{}=(+ 5 ?x1)\textbar{}=(\PYGZhy{} 12 ?x1)))
  =\PYGZgt{})
CLIPS\PYGZgt{} (make\PYGZhy{}instance of DATA (x 4))
[gen1]
CLIPS\PYGZgt{} (make\PYGZhy{}instance of DATA (x 9))
[gen2]
CLIPS\PYGZgt{} (make\PYGZhy{}instance of DATA (x 3))
[gen3]
CLIPS\PYGZgt{} (agenda)
0 return\PYGZhy{}value\PYGZhy{}example\PYGZhy{}2: [gen3],[gen2]
0 return\PYGZhy{}value\PYGZhy{}example\PYGZhy{}2: [gen2],[gen3]
0 return\PYGZhy{}value\PYGZhy{}example\PYGZhy{}2: [gen1],[gen2]
For a total of 3 activations.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{5.4.1.7 Pattern-Matching with Object Patterns}
\label{\detokenize{defrule:pattern-matching-with-object-patterns}}
Instances of user-defined classes in COOL can be pattern-matched on the
left-hand side of rules. Patterns can only match objects for which the
object?s most specific class is defined before the pattern and which are
in scope for the current module. Any classes that could have objects
that match the pattern cannot be deleted or changed until the pattern is
deleted. Even if a rule is deleted by its RHS, the classes bound to its
patterns cannot be changed until after the RHS finishes executing.

When an instance is created or deleted, all patterns applicable to that
object are updated. However, when a slot is changed, only those patterns
that explicitly match on that slot are affected. Thus, one could use
logical dependencies to hook to a change to a particular slot (rather
than a change to any slot, which is all that is possible with
deftemplates).

Changes to non-reactive slots or instances of non-reactive classes (see
sections 9.3.2.2 and 9.3.3.7) will have no effect on rules. Also Rete
network activity will not be immediately apparent after changes to slots
are made if pattern-matching is being delayed through the use of the
\sphinxstylestrong{make-instance}, i.\sphinxstylestrong{initialize-instance};,
i.\sphinxstylestrong{modify-instance};, i.\sphinxstylestrong{message-modify-instance};,
i.\sphinxstylestrong{duplicate-instance};, i.\sphinxstylestrong{message-duplicate-instance}; or
\sphinxstylestrong{object-pattern-match-delay} functions.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{object}\PYG{o}{\PYGZhy{}}\PYG{n}{pattern}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{object} \PYG{o}{\PYGZlt{}}\PYG{n}{attribute}\PYG{o}{\PYGZhy{}}\PYG{n}{constraint}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{n}{attribute}\PYG{o}{\PYGZhy{}}\PYG{n}{constraint}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{n}{constraint}\PYG{o}{\PYGZgt{}}\PYG{p}{)} \PYG{o}{\textbar{}}
\PYG{p}{(}\PYG{n}{name} \PYG{o}{\PYGZlt{}}\PYG{n}{constraint}\PYG{o}{\PYGZgt{}}\PYG{p}{)} \PYG{o}{\textbar{}}
\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{constraint}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

The \sphinxstylestrong{is-a} constraint is used for specifying class constraints such as
?Is this object a member of class FOO??. The is-a constraint also
encompasses subclasses of the matching classes unless specifically
excluded by the pattern. The \sphinxstylestrong{name} constraint is used for specifying
a specific instance on which to pattern-match. The evaluation of the
name constraint must be of primitive type \sphinxstylestrong{instance-name}, not
\sphinxstylestrong{symbol}. Multifield constraints (such as \$?) cannot be used with the
is-a or name constraints. Other than these special cases, constraints
used in object slots work similarly to constraints used in deftemplate
slots. As with deftemplate patterns, slot names for object patterns must
be symbols and can not contain any other constraints.

Example 1

The following rules illustrate pattern-matching on an object’s class.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule class\PYGZhy{}match\PYGZhy{}1
  (object)
  =\PYGZgt{})

(defrule class\PYGZhy{}match\PYGZhy{}2
  (object (is\PYGZhy{}a FOO))
  =\PYGZgt{})

(defrule class\PYGZhy{}match\PYGZhy{}3
  (object (is\PYGZhy{}a FOO \textbar{} BAR))
  =\PYGZgt{})

(defrule class\PYGZhy{}match\PYGZhy{}4
  (object (is\PYGZhy{}a ?x))
  (object (is\PYGZhy{}a \PYGZti{}?x))
  =\PYGZgt{})
\end{sphinxVerbatim}

Rule \sphinxstyleemphasis{class-match-1} is satisified by all instances of any reactive
class. Rule \sphinxstyleemphasis{class-match-2} is satisfied by all instances of class FOO.
Rule \sphinxstyleemphasis{class-match-3} is satisfied by all instances of class FOO or BAR.
Rule \sphinxstyleemphasis{class-match-4} will be satisfied by any two instances of mutually
exclusive classes.

Example 2

The following rules illustrate pattern-matching on various attributes of
an object’s slots.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule slot\PYGZhy{}match\PYGZhy{}1
  (object (width))
  =\PYGZgt{})

(defrule slot\PYGZhy{}match\PYGZhy{}2
  (object (width ?))
  =\PYGZgt{})

(defrule slot\PYGZhy{}match\PYGZhy{}3
  (object (width \PYGZdl{}?))
  =\PYGZgt{})
\end{sphinxVerbatim}

Rule \sphinxstyleemphasis{slot-match-1} is satisfied by all instances of reactive classes
that contain a reactive \sphinxstyleemphasis{width} slot with a zero length multifield
value. Rule \sphinxstyleemphasis{slot-match-2} is satisfied by all instances of reactive
classes that contain a reactive single or multifield \sphinxstyleemphasis{width} slot that
is bound to a single value. Rule \sphinxstyleemphasis{slot-match-3} is satisfied by all
instances of reactive classes that contain a reactive single or
multifield \sphinxstyleemphasis{width} slot that is bound to any number of values. Note that
a slot containing a zero length multifield value would satisfy rules
\sphinxstyleemphasis{slot-match-1} and \sphinxstyleemphasis{slot-match-3}, but not rule \sphinxstyleemphasis{slot-match-2} (because
the value’s cardinality is zero).

Example 3

The following rules illustrate pattern-matching on the slot values of an
object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule value\PYGZhy{}match\PYGZhy{}1
  (object (width 10)
  =\PYGZgt{})

(defrule value\PYGZhy{}match\PYGZhy{}2
  (object (width ?x\PYGZam{}:(\PYGZgt{} ?x 20)))
  =\PYGZgt{})

(defrule value\PYGZhy{}match\PYGZhy{}3
  (object (width ?x) (height ?x))
  =\PYGZgt{})
\end{sphinxVerbatim}

Rule \sphinxstyleemphasis{value-match-1} is satisified by all instances of reactive classes
that contain a reactive \sphinxstyleemphasis{width} slot with value 10. Rule \sphinxstyleemphasis{value-match-2}
is satisfied by all instances of reactive classes that contain a
reactive \sphinxstyleemphasis{width} slot that has a value greater than 20. Rule
\sphinxstyleemphasis{value-match-3} is satisfied by all instances of reactive classes that
contain a reactive \sphinxstyleemphasis{width} and \sphinxstyleemphasis{height} slots with the same value.


\subsubsection{5.4.1.8 Pattern-Addresses}
\label{\detokenize{defrule:pattern-addresses}}
Certain RHS actions, such as \sphinxstylestrong{retract} and \sphinxstylestrong{unmake-instance},
operate on an entire pattern CE. To signify which fact or instance they
are to act upon, a variable can be bound to the \sphinxstylestrong{fact-address} or
\sphinxstylestrong{instance-address} of a pattern CE. Collectively, fact-addresses and
instance-addresses bound on the LHS of a rule are referred to as
\sphinxstylestrong{pattern-addresses}.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}assigned\PYGZhy{}pattern\PYGZhy{}CE\PYGZgt{} ::= ?\PYGZlt{}variable\PYGZhy{}symbol\PYGZgt{} \PYGZlt{}\PYGZhy{} \PYGZlt{}pattern\PYGZhy{}CE\PYGZgt{}
\end{sphinxVerbatim}

The left arrow, \sphinxstylestrong{\textless{}-}, is a required part of the syntax. A variable
bound to a fact-address or instance-address can be compared to other
variables or passed to external functions. Variables bound to a fact or
instance-address may later be used to constrain fields within a pattern
CE, however, the reverse is not allowed. It is an error to bind a
varible to a \sphinxstylestrong{not} CE.

Examples

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule dummy
  (data 1)
  ?fact \PYGZlt{}\PYGZhy{} (dummy pattern)
 =\PYGZgt{}
  (retract ?fact))

(defrule compare\PYGZhy{}facts\PYGZhy{}1
  ?f1 \PYGZlt{}\PYGZhy{} (color \PYGZti{}red)
  ?f2 \PYGZlt{}\PYGZhy{} (color \PYGZti{}green)
  (test (neq ?f1 ?f2))
 =\PYGZgt{}
  (printout t \PYGZdq{}Rule fires from different facts\PYGZdq{} crlf))

(defrule compare\PYGZhy{}facts\PYGZhy{}2
  ?f1 \PYGZlt{}\PYGZhy{} (color \PYGZti{}red)
  ?f2 \PYGZlt{}\PYGZhy{} (color \PYGZti{}green\PYGZam{}:(neq ?f1 ?f2))
 =\PYGZgt{}
  (printout t \PYGZdq{}Rule fires from different facts\PYGZdq{} crlf))

(defrule print\PYGZhy{}and\PYGZhy{}delete\PYGZhy{}all\PYGZhy{}objects
  ?ins \PYGZlt{}\PYGZhy{} (object)
 =\PYGZgt{}
  (send ?ins print)
  (unmake\PYGZhy{}instance ?ins))
\end{sphinxVerbatim}


\subsection{5.4.2 Test Conditional Element}
\label{\detokenize{defrule:test-conditional-element}}
Field constraints used within pattern CEs allow very descriptive
constraints to be applied to pattern-matching. Additional capability is
provided with the \sphinxstylestrong{test} \sphinxstylestrong{conditional element}. The test CE is
satisfied if the function call within the test CE evaluates to a
non-FALSE value and unsatisfied if the function call evaluates to FALSE.
As with predicate constraints, the user can compare the variable
bindings that already have oc?curred in any manner. Mathematical
comparisons on variables (e.g., is the differ?ence between ?x and ?y
greater than some value?) and complex logical or equality comparisons
can be done. External functions also can be called which compare
vari?ables in any way that the user desires.

Any kind of external function may be embedded within a \sphinxstylestrong{test}
conditional element (or within field constraints). User-defined
predicate functions must take arguments as defined in the \sphinxstyleemphasis{Advanced
Programming Guide}. CLIPS provides sev?eral predicate functions (see
section 12.1).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{test}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{n}{test} \PYG{o}{\PYGZlt{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{call}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Since the symbol \sphinxstylestrong{test} is used to indicate this type of conditional
element, rules may not use the symbol test as the first field in a
pattern CE. A \sphinxstylestrong{test} CE is evaluated when all proceeding CEs are
satisfied. This means that a \sphinxstylestrong{test} CE will be evaluated more than
once if the proceeding CEs can be satisfied by more than one group of
pattern entities. In order to cause the reevaluation of a \sphinxstylestrong{test} CE, a
pattern entity matching a CE prior to the \sphinxstylestrong{test} CE must be changed.

Example 1

This example checks to see if the difference between two numbers is
greater than or equal to three:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defrule example\PYGZhy{}1
  (data ?x)
  (value ?y)
  (test (\PYGZgt{}= (abs (\PYGZhy{} ?y ?x)) 3))
 =\PYGZgt{})
CLIPS\PYGZgt{} (assert (data 6) (value 9))
\PYGZlt{}Fact\PYGZhy{}2\PYGZgt{}
CLIPS\PYGZgt{} (agenda)
0 example\PYGZhy{}1: f\PYGZhy{}1,f\PYGZhy{}2
For a total of 1 activation.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

Example 2

This example checks to see if there is a positive slope between two
points on a line.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(deffunction positive\PYGZhy{}slope
  (?x1 ?y1 ?x2 ?y2)
  (\PYGZlt{} 0 (/ (\PYGZhy{} ?y2 ?y1) (\PYGZhy{} ?x2 ?x1))))
CLIPS\PYGZgt{}
(defrule example\PYGZhy{}2
  (point ?a ?x1 ?y1)
  (point ?b ?x2 ?y2)
  (test (\PYGZgt{} ?b ?a))
  (test (positive\PYGZhy{}slope ?x1 ?y1 ?x2 ?y2))
 =\PYGZgt{})
CLIPS\PYGZgt{}
(assert (point 1 4.0 7.0) (point 2 5.0 9.0))
\PYGZlt{}Fact\PYGZhy{}2\PYGZgt{}
CLIPS\PYGZgt{} (agenda)
0 example\PYGZhy{}2: f\PYGZhy{}1,f\PYGZhy{}2
For a total of 1 activation.
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{5.4.3 Or Conditional Element}
\label{\detokenize{defrule:or-conditional-element}}
The \sphinxstylestrong{or conditional element} allows any one of several conditional
elements to activate a rule. If any of the conditional elements inside
of the \sphinxstylestrong{or} CE is satisfied, then the \sphinxstylestrong{or} CE is satisfied. If all
other LHS condi?tional elements are satisfied, the rule will be
activated. Note that a rule will be activated for each conditional
element with an \sphinxstylestrong{or} CE that is satisfied (assuming the other
conditional elements of the rule are also satisfied). Any number of
conditional elements may appear within an \sphinxstylestrong{or} CE. The \sphinxstylestrong{or} CE
produces the identical effect of writing several rules with sim?ilar
LHS?s and RHS?s.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{o+ow}{or} \PYG{o}{\PYGZlt{}}\PYG{n}{conditional}\PYG{o}{\PYGZhy{}}\PYG{n}{element}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Again, if more than one of the conditional elements in the \sphinxstylestrong{or} CE can
be met, the rule will fire \sphinxstyleemphasis{multiple times}, once for each satisfied
combination of conditions.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{system}\PYG{o}{\PYGZhy{}}\PYG{n}{fault}
  \PYG{p}{(}\PYG{n}{error}\PYG{o}{\PYGZhy{}}\PYG{n}{status} \PYG{n}{unknown}\PYG{p}{)}
  \PYG{p}{(}\PYG{o+ow}{or} \PYG{p}{(}\PYG{n}{temp} \PYG{n}{high}\PYG{p}{)}
      \PYG{p}{(}\PYG{n}{valve} \PYG{n}{broken}\PYG{p}{)}
      \PYG{p}{(}\PYG{n}{pump} \PYG{p}{(}\PYG{n}{status} \PYG{n}{off}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
   \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The system has a fault.}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{crlf}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Note that the above example is exactly equivalent to the following three
(separate) rules:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{system}\PYG{o}{\PYGZhy{}}\PYG{n}{fault}
  \PYG{p}{(}\PYG{n}{error}\PYG{o}{\PYGZhy{}}\PYG{n}{status} \PYG{n}{unknown}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{pump} \PYG{p}{(}\PYG{n}{status} \PYG{n}{off}\PYG{p}{)}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The system has a fault.}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{crlf}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{system}\PYG{o}{\PYGZhy{}}\PYG{n}{fault}
  \PYG{p}{(}\PYG{n}{error}\PYG{o}{\PYGZhy{}}\PYG{n}{status} \PYG{n}{unknown}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{valve} \PYG{n}{broken}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The system has a fault.}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{crlf}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{system}\PYG{o}{\PYGZhy{}}\PYG{n}{fault}
  \PYG{p}{(}\PYG{n}{error}\PYG{o}{\PYGZhy{}}\PYG{n}{status} \PYG{n}{unknown}\PYG{p}{)}
 \PYG{p}{(}\PYG{n}{temp} \PYG{n}{high}\PYG{p}{)}
 \PYG{o}{=}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The system has a fault.}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{crlf}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{5.4.4 And Conditional Element}
\label{\detokenize{defrule:and-conditional-element}}
CLIPS assumes that all rules have an implicit \sphinxstylestrong{and} \sphinxstylestrong{conditional
element} surrounding the conditional elements on the LHS. This means
that all conditional elements on the LHS must be satisfied before the
rule can be activated. An explicit \sphinxstylestrong{and} conditional element is
provided to allow the mixing of \sphinxstylestrong{and} CEs and \sphinxstylestrong{or} CEs. This allows
other types of conditional elements to be grouped together within \sphinxstylestrong{or}
and \sphinxstylestrong{not} CEs. The \sphinxstylestrong{and} CE is satisfied if \sphinxstyleemphasis{all} of the CEs inside
of the explicit \sphinxstylestrong{and} CE are satisfied. If all other LHS condi?tions
are true, the rule will be activated. Any number of conditional elements
may be placed within an \sphinxstylestrong{and} CE. Note that the LHS of any rule is
enclosed within an implied \sphinxstylestrong{and} CE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{o+ow}{and}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{o+ow}{and} \PYG{o}{\PYGZlt{}}\PYG{n}{conditional}\PYG{o}{\PYGZhy{}}\PYG{n}{element}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{system}\PYG{o}{\PYGZhy{}}\PYG{n}{flow}
  \PYG{p}{(}\PYG{n}{error}\PYG{o}{\PYGZhy{}}\PYG{n}{status} \PYG{n}{confirmed}\PYG{p}{)}
  \PYG{p}{(}\PYG{o+ow}{or} \PYG{p}{(}\PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{temp} \PYG{n}{high}\PYG{p}{)}
           \PYG{p}{(}\PYG{n}{valve} \PYG{n}{closed}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{temp} \PYG{n}{low}\PYG{p}{)}
       \PYG{p}{(}\PYG{n}{valve} \PYG{n+nb}{open}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
 \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The system is having a flow problem.}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{crlf}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{5.4.5 Not Conditional Element}
\label{\detokenize{defrule:not-conditional-element}}
Sometimes the \sphinxstyleemphasis{lack} of information is meaningful; i.e., one wishes to
fire a rule if a pattern entity or other CE does \sphinxstyleemphasis{not} exist. The
\sphinxstylestrong{not} \sphinxstylestrong{conditional element} provides this capability. The \sphinxstylestrong{not} CE
is satisfied only if the conditional element contained within it is not
satisfied. As with other conditional elements, any number of additional
CEs may be on the LHS of the rule and field con?straints may be used
within the negated pattern.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{o+ow}{not}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{o+ow}{not} \PYG{o}{\PYGZlt{}}\PYG{n}{conditional}\PYG{o}{\PYGZhy{}}\PYG{n}{element}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Only one CE may be negated at a time. Multiple patterns may be negated
by using multiple \sphinxstylestrong{not} CEs. Care must be taken when combining \sphinxstylestrong{not}
CEs with \sphinxstylestrong{or} and \sphinxstylestrong{and} CEs; the results are not always obvi?ous!
The same holds true for variable bindings within a \sphinxstylestrong{not} CE.
Previously bound variables may be used freely inside of a \sphinxstylestrong{not} CE.
However, variables bound for the first time within a \sphinxstylestrong{not} CE can be
used only in that pattern.

Examples
\begin{quote}
\begin{description}
\item[{(defrule high-flow-rate}] \leavevmode
(temp high)
(valve open)
(not (error-status confirmed))
=\textgreater{}
(printout t “Recommend closing of valve due to high temp” crlf))

\item[{(defrule check-valve}] \leavevmode
(check-status ?valve)
(not (valve-broken ?valve))
=\textgreater{}
(printout t “Device ” ?valve ” is OK” crlf))

\item[{(defrule double-pattern}] \leavevmode
(data red)
(not (data red ?x ?x))
=\textgreater{}
(printout t “No patterns with red green green!” crlf ))

\end{description}
\end{quote}


\subsection{5.4.6 Exists Conditional Element}
\label{\detokenize{defrule:exists-conditional-element}}
The \sphinxstylestrong{exists} \sphinxstylestrong{conditional element} provides a mechanism for
determining if a group of specified CEs is satisfied by a least one set
of pattern entities.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{exists}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{n}{exists} \PYG{o}{\PYGZlt{}}\PYG{n}{conditional}\PYG{o}{\PYGZhy{}}\PYG{n}{element}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

The \sphinxstylestrong{exists} CE is implemented by replacing the \sphinxstylestrong{exists} keyword
with two nested \sphinxstylestrong{not} CEs. For example, the following rule

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule example
  (exists (a ?x) (b ?x))
 =\PYGZgt{})
\end{sphinxVerbatim}

is equivalent to the rule below

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule example
  (not (not (and (a ?x) (b ?x))))
  =\PYGZgt{})
\end{sphinxVerbatim}

Because of the way the \sphinxstylestrong{exists} CE is implemented using \sphinxstylestrong{not} CEs,
the restrictions which apply to CEs found within \sphinxstylestrong{not} CEs (such as
binding a pattern CE to a fact-address) also apply to the CEs found
within an \sphinxstylestrong{exists} CE.

Example

Given the following constructs,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{deftemplate} \PYG{n}{hero}
  \PYG{p}{(}\PYG{n}{multislot} \PYG{n}{name}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{status} \PYG{p}{(}\PYG{n}{default} \PYG{n}{unoccupied}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{deffacts} \PYG{n}{goal}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{and}\PYG{o}{\PYGZhy{}}\PYG{n}{heroes}
  \PYG{p}{(}\PYG{n}{goal} \PYG{n}{save}\PYG{o}{\PYGZhy{}}\PYG{n}{the}\PYG{o}{\PYGZhy{}}\PYG{n}{day}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{hero} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Death} \PYG{n}{Defying} \PYG{n}{Man}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{hero} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Stupendous} \PYG{n}{Man}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{hero} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Incredible} \PYG{n}{Man}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{save}\PYG{o}{\PYGZhy{}}\PYG{n}{the}\PYG{o}{\PYGZhy{}}\PYG{n}{day}
  \PYG{p}{(}\PYG{n}{goal} \PYG{n}{save}\PYG{o}{\PYGZhy{}}\PYG{n}{the}\PYG{o}{\PYGZhy{}}\PYG{n}{day}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{exists} \PYG{p}{(}\PYG{n}{hero} \PYG{p}{(}\PYG{n}{status} \PYG{n}{unoccupied}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The day is saved.}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{crlf}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

the following commands illustrate that even though there are three facts
which can match the second CE in the \sphinxstyleemphasis{save-the-day} rule, there is only
one partial match generated.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{reset}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{l+m+mi}{0} \PYG{n}{save}\PYG{o}{\PYGZhy{}}\PYG{n}{the}\PYG{o}{\PYGZhy{}}\PYG{n}{day}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{*}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{1} \PYG{n}{activation}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{facts}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0} \PYG{p}{(}\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n}{fact}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{n}{goal} \PYG{n}{save}\PYG{o}{\PYGZhy{}}\PYG{n}{the}\PYG{o}{\PYGZhy{}}\PYG{n}{day}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{n}{hero} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Death} \PYG{n}{Defying} \PYG{n}{Man}\PYG{p}{)} \PYG{p}{(}\PYG{n}{status} \PYG{n}{unoccupied}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{p}{(}\PYG{n}{hero} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Stupendous} \PYG{n}{Man}\PYG{p}{)} \PYG{p}{(}\PYG{n}{status} \PYG{n}{unoccupied}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{p}{(}\PYG{n}{hero} \PYG{p}{(}\PYG{n}{name} \PYG{n}{Incredible} \PYG{n}{Man}\PYG{p}{)} \PYG{p}{(}\PYG{n}{status} \PYG{n}{unoccupied}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{5} \PYG{n}{facts}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{matches} \PYG{n}{save}\PYG{o}{\PYGZhy{}}\PYG{n}{the}\PYG{o}{\PYGZhy{}}\PYG{n}{day}\PYG{p}{)}
\PYG{n}{Matches} \PYG{k}{for} \PYG{n}{Pattern} \PYG{l+m+mi}{1}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{Matches} \PYG{k}{for} \PYG{n}{Pattern} \PYG{l+m+mi}{2}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}
\PYG{n}{Partial} \PYG{n}{matches} \PYG{k}{for} \PYG{n}{CEs} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{*}
\PYG{n}{Activations}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{*}
\PYG{p}{(}\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{5.4.7 Forall Conditional Element}
\label{\detokenize{defrule:forall-conditional-element}}
The \sphinxstylestrong{forall} \sphinxstylestrong{conditional element} provides a mechanism for
determining if a group of specified CEs is satisfied for every occurence
of another specified CE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{forall}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{n}{forall} \PYG{o}{\PYGZlt{}}\PYG{n}{conditional}\PYG{o}{\PYGZhy{}}\PYG{n}{element}\PYG{o}{\PYGZgt{}}
                        \PYG{o}{\PYGZlt{}}\PYG{n}{conditional}\PYG{o}{\PYGZhy{}}\PYG{n}{element}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

The \sphinxstylestrong{forall} CE is implemented by replacing the \sphinxstylestrong{forall} keyword
with combinations of \sphinxstylestrong{not} and \sphinxstylestrong{and} CEs. For example, the following
rule

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule example
  (forall (a ?x) (b ?x) (c ?x))
  =\PYGZgt{})
\end{sphinxVerbatim}

is equivalent to the rule below

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule example
  (not (and (a ?x)
  (not (and (b ?x) (c ?x)))))
  =\PYGZgt{})
\end{sphinxVerbatim}

Because of the way the \sphinxstylestrong{forall} CE is implemented using \sphinxstylestrong{not} CEs,
the restrictions which apply to CE found within \sphinxstylestrong{not} CEs (such as
binding a pattern CE to a fact-address) also apply to the CEs found
within an \sphinxstylestrong{forall} CE.

Example

The following rule determines if every student has passed in reading,
writing, and arithmetic by using the \sphinxstylestrong{forall} CE.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defrule all\PYGZhy{}students\PYGZhy{}passed
  (forall (student ?name)
          (reading ?name)
          (writing ?name)
          (arithmetic ?name))
   =\PYGZgt{}
   (printout t \PYGZdq{}All students passed.\PYGZdq{} crlf))
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

The following commands illustrate how the \sphinxstylestrong{forall} CE works in the
\sphinxstyleemphasis{all-students-passed} rule. Note that initially the
\sphinxstyleemphasis{all-students-passed} rule is satisfied because there are no students.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{reset}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{l+m+mi}{0} \PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{students}\PYG{o}{\PYGZhy{}}\PYG{n}{passed}\PYG{p}{:} \PYGZbs{}\PYG{o}{*}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{1} \PYG{n}{activation}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

After the (student Bob) fact is asserted, the rule is no longer
satisfied since Bob has not passed reading, writing, and arithmetic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{student} \PYG{n}{Bob}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{n}{Fact}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

The rule is still not satisfied after Bob has passed reading and
writing, since he still has not passed arithmetic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{reading} \PYG{n}{Bob}\PYG{p}{)} \PYG{p}{(}\PYG{n}{writing} \PYG{n}{Bob}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{n}{Fact}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{\PYGZgt{}}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Once Bob has passed arithmetic, the all-students-passed rule is
reactivated.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{arithmetic} \PYG{n}{Bob}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{n}{Fact}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{o}{\PYGZgt{}}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{l+m+mi}{0} \PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{students}\PYG{o}{\PYGZhy{}}\PYG{n}{passed}\PYG{p}{:} \PYGZbs{}\PYG{o}{*}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{1} \PYG{n}{activation}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

If a new student is asserted, then the rule is taken off the agenda,
since John has not passed reading, writing, and arithmetic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{student} \PYG{n}{John}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{n}{Fact}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{o}{\PYGZgt{}}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Removing both \sphinxstyleemphasis{student} facts reactivates the rule again.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{retract} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{l+m+mi}{0} \PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{students}\PYG{o}{\PYGZhy{}}\PYG{n}{passed}\PYG{p}{:} \PYG{o}{*}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{1} \PYG{n}{activation}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{5.4.8 Logical Conditional Element}
\label{\detokenize{defrule:logical-conditional-element}}
The \sphinxstylestrong{logical} \sphinxstylestrong{conditional element} provides a \sphinxstylestrong{truth maintenance}
capability for pattern entities (facts or instances) created by rules
that use the \sphinxstylestrong{logical} CE. A pattern entity created on the RHS (or as
a result of actions performed from the RHS) can be made logically
dependent upon the pattern entities that matched the patterns enclosed
with the \sphinxstylestrong{logical} CE on the LHS of the rule. The pattern entities
matching the LHS \sphinxstylestrong{logical} patterns provide \sphinxstylestrong{logical support} to the
facts and instance created by the RHS of the rule. A pattern entity can
be logically supported by more than one group of pattern entities from
the same or different rules. If any one supporting pattern entities is
removed from a group of supporting pattern entities (and there are no
other supporting groups), then the pattern entity is removed.

If a pattern entity is created without logical support (e.g., from a
deffacts, definstaces, as a top-level command, or from a rule without
any logical patterns), then the pattern entity has \sphinxstylestrong{unconditional
support}. Unconditionally supporting a pattern entity removes all
logical support (without causing the removal of the pattern entity). In
addition, further logical support for an unconditionally supported
pattern entity is ignored. Removing a rule that generated logical
support for a pattern entity, removes the logical support generated by
that rule (but does not cause the removal of the pattern entity if no
logical support remains).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{logical}\PYG{o}{\PYGZhy{}}\PYG{n}{CE}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{n}{logical} \PYG{o}{\PYGZlt{}}\PYG{n}{conditional}\PYG{o}{\PYGZhy{}}\PYG{n}{element}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

The \sphinxstylestrong{logical} CE groups patterns together exactly as the explicit
\sphinxstylestrong{and} CE does. It may be used in conjunction with the \sphinxstylestrong{and}, \sphinxstylestrong{or},
and \sphinxstylestrong{not} CEs. However, only the first N patterns of a rule can have
the logical CE applied to them. For example, the following rule is legal

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{ok}
  \PYG{p}{(}\PYG{n}{logical} \PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{logical} \PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

whereas the following rules are \sphinxstylestrong{illegal}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defrule} \PYG{o+ow}{not}\PYG{o}{\PYGZhy{}}\PYG{n}{ok}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
  \PYG{p}{(}\PYG{n}{logical} \PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{logical} \PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defrule} \PYG{o+ow}{not}\PYG{o}{\PYGZhy{}}\PYG{n}{ok}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}
  \PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{logical} \PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{logical} \PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defrule} \PYG{o+ow}{not}\PYG{o}{\PYGZhy{}}\PYG{n}{ok}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
  \PYG{p}{(}\PYG{o+ow}{or} \PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{logical} \PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{logical} \PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Example

Given the following rules,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{rule1}
  \PYG{p}{(}\PYG{n}{logical} \PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{logical} \PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{g}\PYG{p}{)} \PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{rule2}
  \PYG{p}{(}\PYG{n}{logical} \PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{logical} \PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{g}\PYG{p}{)} \PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

the following commands illustrate how logical dependencies work.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{watch} \PYG{n}{facts}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{watch} \PYG{n}{activations}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{.} \PYG{p}{(}\PYG{n}{watch} \PYG{n}{rules}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{p}{(}\PYG{n}{b}\PYG{p}{)} \PYG{p}{(}\PYG{n}{c}\PYG{p}{)} \PYG{p}{(}\PYG{n}{d}\PYG{p}{)} \PYG{p}{(}\PYG{n}{e}\PYG{p}{)} \PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{Activation} \PYG{l+m+mi}{0} \PYG{n}{rule1}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5} \PYG{p}{(}\PYG{n}{e}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6} \PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{Activation} \PYG{l+m+mi}{0} \PYG{n}{rule2}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}
\PYG{o}{\PYGZlt{}}\PYG{n}{Fact}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{o}{\PYGZgt{}}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{run}\PYG{p}{)}
\PYG{n}{FIRE} \PYG{l+m+mi}{1} \PYG{n}{rule2}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6} \PYG{p}{;} \PYG{l+m+mi}{1}\PYG{n}{st} \PYG{n}{rule} \PYG{n}{adds} \PYG{n}{logical} \PYG{n}{support}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7} \PYG{p}{(}\PYG{n}{g}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8} \PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{FIRE} \PYG{l+m+mi}{2} \PYG{n}{rule1}\PYG{p}{:} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{p}{;} \PYG{l+m+mi}{2}\PYG{n}{nd} \PYG{n}{rule} \PYG{n}{adds} \PYG{n}{further} \PYG{n}{support}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{retract} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{o}{==} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{p}{;} \PYG{n}{Removes} \PYG{l+m+mi}{1}\PYG{n}{st} \PYG{n}{support} \PYG{k}{for} \PYG{p}{(}\PYG{n}{g}\PYG{p}{)} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{assert} \PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)} \PYG{p}{;} \PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{unconditionally} \PYG{n}{supported}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{retract} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{o}{==} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{p}{(}\PYG{n}{d}\PYG{p}{)} \PYG{p}{;} \PYG{n}{Removes} \PYG{l+m+mi}{2}\PYG{n}{nd} \PYG{n}{support} \PYG{k}{for} \PYG{p}{(}\PYG{n}{g}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{o}{==} \PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7} \PYG{p}{(}\PYG{n}{g}\PYG{p}{)} \PYG{p}{;} \PYG{p}{(}\PYG{n}{g}\PYG{p}{)} \PYG{n}{has} \PYG{n}{no} \PYG{n}{more} \PYG{n}{support}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{unwatch} \PYG{n+nb}{all}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

As mentioned in section 5.4.1.7, the logical CE can be used with an
object pattern to create pattern entities that are logically dependent
on changes to specific slots in the matching instance(s) rather than all
slots. This cannot be accomplished with template facts because a change
to a template fact slot actually involves the retraction of the old
template fact and the assertion of a new one, whereas a change to an
instance slot is done in place. The example below illustrates this
behavior:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass A (is\PYGZhy{}a USER)
  (slot foo)
  (slot bar))
CLIPS\PYGZgt{}
(deftemplate A
  (slot foo)
  (slot bar))
CLIPS\PYGZgt{}
(defrule match\PYGZhy{}A\PYGZhy{}s
  (logical (object (is\PYGZhy{}a A) (foo ?))
  (A (foo ?)))
  =\PYGZgt{}
  (assert (new\PYGZhy{}fact)))
CLIPS\PYGZgt{} (make\PYGZhy{}instance a of A)
[a]
CLIPS\PYGZgt{} (assert (A))
\PYGZlt{}Fact\PYGZhy{}1\PYGZgt{}
CLIPS\PYGZgt{} (watch facts)
CLIPS\PYGZgt{} (run)
==\PYGZgt{} f\PYGZhy{}2 (new\PYGZhy{}fact)
CLIPS\PYGZgt{} (send [a] put\PYGZhy{}bar 100)
100
CLIPS\PYGZgt{} (agenda)
CLIPS\PYGZgt{} (modify 1 (bar 100))
\PYGZlt{}== f\PYGZhy{}1 (A (foo nil) (bar nil))
\PYGZlt{}== f\PYGZhy{}2 (new\PYGZhy{}fact)
==\PYGZgt{} f\PYGZhy{}3 (A (foo nil) (bar 100))
\PYGZlt{}Fact\PYGZhy{}3\PYGZgt{}
CLIPS\PYGZgt{} (agenda)
0 match\PYGZhy{}A\PYGZhy{}s: [a],f\PYGZhy{}3
For a total of 1 activation.
CLIPS\PYGZgt{} (run)
==\PYGZgt{} f\PYGZhy{}4 (new\PYGZhy{}fact)
CLIPS\PYGZgt{} (send [a] put\PYGZhy{}foo 100)
\PYGZlt{}== f\PYGZhy{}4 (new\PYGZhy{}fact)
100
CLIPS\PYGZgt{} (agenda)
0 match\PYGZhy{}A\PYGZhy{}s: [a],f\PYGZhy{}3
For a total of 1 activation.
CLIPS\PYGZgt{} (unwatch facts)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{5.4.9 Automatic Replacement of LHS CEs}
\label{\detokenize{defrule:automatic-replacement-of-lhs-ces}}
Under certain circumstances, CLIPS will change the CEs specified in the
rule LHS.


\subsubsection{5.4.9.1 Or CEs Following Not CEs}
\label{\detokenize{defrule:or-ces-following-not-ces}}
If an \sphinxstyleemphasis{or} CE immediately follows a \sphinxstyleemphasis{not} CE, then the \sphinxstyleemphasis{not}/\sphinxstyleemphasis{or} CE
combination is replaced with an \sphinxstyleemphasis{and}/\sphinxstyleemphasis{not} CE combination where each of
the CEs contained in the original \sphinxstyleemphasis{or} CE is enclosed within a \sphinxstyleemphasis{not} CE
and then all of the \sphinxstyleemphasis{not} CEs are enclosed within a single \sphinxstyleemphasis{and} CE. For
example, the following rule

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule example
  (a ?x)
  (not (or (b ?x)
  (c ?x)))
  =\PYGZgt{})
\end{sphinxVerbatim}

would be changed as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule example
  (a ?x)
  (and (not (b ?x))
  (not (c ?x)))
  =\PYGZgt{})
\end{sphinxVerbatim}


\subsection{5.4.10 Declaring Rule Properties}
\label{\detokenize{defrule:declaring-rule-properties}}
This feature allows the properties or characteristics of a rule to be
defined. The char?acter?istics are declared on the LHS of a rule using
the \sphinxstylestrong{declare} keyword. A rule may only have one \sphinxstylestrong{declare} statement
and it must appear be?fore the first conditional element on the LHS (as
shown in section 5.1).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{declaration}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{n}{declare} \PYG{o}{\PYGZlt{}}\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}

\PYG{o}{\PYGZlt{}}\PYG{n}{rule}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{n}{salience} \PYG{o}{\PYGZlt{}}\PYG{n}{integer}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)} \PYG{o}{\textbar{}}
                    \PYG{p}{(}\PYG{n}{auto}\PYG{o}{\PYGZhy{}}\PYG{n}{focus} \PYG{o}{\PYGZlt{}}\PYG{n}{boolean}\PYG{o}{\PYGZhy{}}\PYG{n}{symbol}\PYG{o}{\PYGZgt{}}\PYG{p}{)}

\PYG{o}{\PYGZlt{}}\PYG{n}{boolean}\PYG{o}{\PYGZhy{}}\PYG{n}{symbol}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{n}{TRUE} \PYG{o}{\textbar{}} \PYG{n}{FALSE}
\end{sphinxVerbatim}


\subsubsection{5.4.10.1 The Salience Rule Property}
\label{\detokenize{defrule:the-salience-rule-property}}
The \sphinxstylestrong{salience} rule property allows the user to assign a priority to a
rule. When multiple rules are in the agenda, the rule with the highest
priority will fire first. The declared salience value should be an
expression that evaluates to an an integer in the range -10000 to
+10000. Salience expressions may freely reference global variables and
other functions (however, you should avoid using functions with
side-effects). If unspecified, the salience value for a rule defaults to
zero.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule test\PYGZhy{}1
  (declare (salience 99))
 (fire test\PYGZhy{}1)
 =\PYGZgt{}
 (printout t \PYGZdq{}Rule test\PYGZhy{}1 firing.\PYGZdq{} crlf))

(defrule test\PYGZhy{}2
  (declare (salience (+ ?*constraint\PYGZhy{}salience\PYGZbs{}* 10)))
  (fire test\PYGZhy{}2)
      =\PYGZgt{}
  (printout t \PYGZdq{}Rule test\PYGZhy{}2 firing.\PYGZdq{} crlf))
\end{sphinxVerbatim}

Salience values can be evaluated at one of three times: when a rule is
defined, when a rule is activated, and every cycle of execution (the
latter two situations are referred to as \sphinxstylestrong{dynamic salience}). By
default, salience values are only evaluated when a rule is defined. The
\sphinxstylestrong{set-salience-evaluation} command can be used to change this behavior.
Note that each salience evaluation method encompasses the previous
method (i.e. if saliences are evaluated every cycle, then they are also
evaluated when rules are activated or defined).

Usage Note

Despite the large number of possible values, with good design there?s
rarely a need for more than five salience values in a simple program and
ten salience values in a complex program. Defining the salience values
as global variables allows you to specify and document the values used
by your program in a centralized location and also makes it easier to
change the salience of a group of rules sharing the same salience value:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defglobal ?*high\PYGZhy{}priority* = 100)
(defglobal ?*low\PYGZhy{}priority* = \PYGZhy{}100)

(defrule rule\PYGZhy{}1
  (declare (salience ?*high\PYGZhy{}priority*))
  =\PYGZgt{})

(defrule rule\PYGZhy{}2
  (declare (salience ?*low\PYGZhy{}priority*))
  =\PYGZgt{})
\end{sphinxVerbatim}


\subsubsection{5.4.10.2 The Auto-Focus Rule Property}
\label{\detokenize{defrule:the-auto-focus-rule-property}}
The \sphinxstylestrong{auto-focus} rule property allows an automatic \sphinxstylestrong{focus} command
to be executed whenever a rule becomes activated. If the auto-focus
property for a rule is TRUE, then a focus command on the module in which
the rule is defined is automatically executed whenever the rule is
activated. If the auto-focus property for a rule is FALSE, then no
action is taken when the rule is activated. If unspecified, the
auto-focus value for a rule defaults to FALSE.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule VIOLATIONS::bad\PYGZhy{}age
  (declare (auto\PYGZhy{}focus TRUE))
  (person (name ?name) (age ?x\PYGZam{}:(\PYGZlt{} ?x 0)))
  =\PYGZgt{}
  (printout t ?name \PYGZdq{} has a bad age value.\PYGZdq{} crlf))
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{defrule:section-3}}

\chapter{Section 6: Defglobal Construct}
\label{\detokenize{defglobal:section-6-defglobal-construct}}\label{\detokenize{defglobal::doc}}
With the \sphinxstylestrong{defglobal} construct, global variables can be defined, set,
and accessed within the CLIPS environment. Global variables can be
accessed as part of the pattern-matching process, but changing them does
not invoke the pattern-matching process. The \sphinxstylestrong{bind} function is used
to set the value of global variables. Global variables are reset to
their original value when the \sphinxstylestrong{reset} command is performed or when
\sphinxstylestrong{bind} is called for the global with no values. This behavior can be
changed using the \sphinxstylestrong{set-reset-globals} function. Global variables can
be removed by using the \sphinxstylestrong{clear} command or the \sphinxstylestrong{undefglobal}
command. If the globals item is being watched (see section 13.2), then
an informational message will be displayed each time the value of a
global variable is changed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defglobal [\PYGZlt{}defmodule\PYGZhy{}name\PYGZgt{}] \PYGZlt{}global\PYGZhy{}assignment\PYGZgt{}*)

 \PYGZlt{}global\PYGZhy{}assignment\PYGZgt{} ::= \PYGZlt{}global\PYGZhy{}variable\PYGZgt{} = \PYGZlt{}expression\PYGZgt{}

 \PYGZlt{}global\PYGZhy{}variable\PYGZgt{} ::= ?*\PYGZlt{}symbol\PYGZgt{}*
\end{sphinxVerbatim}

There may be multiple defglobal constructs and any number of global
variables may be defined in each defglobal statement. The optional
\textless{}defmodule-name\textgreater{} indicates the module in which the defglobals will be
defined. If none is specified, the globals will be placed in the current
module. If a variable was defined in a previous defglobal construct, its
value will be replaced by the value found in the new defglobal
construct. If an error is encountered when defining a defglobal
construct, any global variable definitions that occurred before the
error was encountered will still remain in effect.

Commands that operate on defglobals such as ppdefglobal and undefglobal
expect the symbolic name of the global without the astericks (e.g. use
the symbol \sphinxstyleemphasis{max} when you want to refer to the global variable ?*max*).

Global variables may be used anyplace that a local variable could be
used (with two exceptions). Global variables may not be used as a
parameter variable for a deffunction, defmethod, or message-handler.
Global variables may not be used in the same way that a local variable
is used on the LHS of a rule to bind a value. Therefore, the following
rule is \sphinxstylestrong{illegal}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule example
  (fact ?*x*)
  =\PYGZgt{})
\end{sphinxVerbatim}

The following rule, however, is legal.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule example
  (fact ?y\PYGZam{}:(\PYGZgt{} ?y ?*x*))
  =\PYGZgt{})
\end{sphinxVerbatim}

Note that this rule will not necessarily be updated when the value of
?*x* is changed. For example, if ?*x* is 4 and the fact (fact 3) is
added, then the rule is not satisfied. If the value of ?*x* is now
changed to 2, the rule will not be activated.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defglobal
  ?*x* = 3
  ?*y* = ?*x*
  ?*z* = (+ ?*x* ?*y*)
  ?*q* = (create\PYGZdl{} a b c))
\end{sphinxVerbatim}

Usage Note

The inappropriate use of globals within rules is quite often the first
resort of beginning programmers who have reached an impasse in
developing a program because they do not fully understand how rules and
pattern-matching work. As it relates to this issue, the following
sentence from the beginning of this section is important enough to
repeat:

\sphinxstyleemphasis{Global variables can be accessed as part of the pattern-matching
process, but changing them does not invoke the pattern-matching
process.}

Facts and instances are the primary mechanism that should be used to
pass information from one rule to another specifically because they \sphinxstyleemphasis{do}
invoke pattern-matching. A change to a slot value of a fact or instance
will trigger pattern-matching ensuring that a rule is aware of the
current state of that fact or instance. Since a change to a global
variable does not trigger pattern-matching, it is possible for a rule to
remain activated based on a past value of a global variable that is
undesirable in most situations.

It’s worth pointing out that facts and instances are no less ?global’ in
nature than global variables. Just as a rule can access any global
variable that’s visible (i.e. it hasn’t been hidden through the use of
modules), so too can it access any fact or instance belonging to a
deftemplate or defclass that’s visible. In the case of a fact, one can
either pattern-match for the fact on the LHS of a rule or use the
fact-set query functions from the RHS of a rule. In the case of an
instance, pattern-matching and instance-set query functions can also be
used, and in addition an instance can be directly referenced by name
just as a global variable can.

Common Problem

One of the more common situations in which it is tempting to use global
variables is collecting a group of slot values from a fact. First
attempts at rules to accomplish this task often loop endlessly because
of rules inadvertently retriggered by changes. For example, the
following rule will loop endlessly because the new \sphinxstyleemphasis{collection} fact
asserted will create an activation with the same \sphinxstyleemphasis{factoid} fact that was
just added to the \sphinxstyleemphasis{collection} fact:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule add\PYGZhy{}factoid
  (factoid ?data)
  ?c \PYGZlt{}\PYGZhy{} (collection \PYGZdl{}?collection)
  =\PYGZgt{}
  (retract ?c)
  (assert (collection ?collection ?data)))
\end{sphinxVerbatim}

This problem can be corrected by removing the \sphinxstyleemphasis{factoid} fact just added
to the \sphinxstyleemphasis{collection} fact:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule add\PYGZhy{}factoid
  ?f \PYGZlt{}\PYGZhy{} (factoid ?data)
  ?c \PYGZlt{}\PYGZhy{} (collection \PYGZdl{}?collection)
  =\PYGZgt{}
  (retract ?f ?c)
  (assert (collection ?collection ?data)))
\end{sphinxVerbatim}

Retracting the \sphinxstyleemphasis{factoid} facts, however, isn’t a viable solution if
these facts are needed by other rules. A non-destructive approach makes
use of temporary facts created by a helper rule:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule add\PYGZhy{}factoid\PYGZhy{}helper
  (factoid ?data)
  =\PYGZgt{}
 (assert (temp\PYGZhy{}factoid ?data)))

(defrule add\PYGZhy{}factoid
  ?f \PYGZlt{}\PYGZhy{} (temp\PYGZhy{}factoid ?data)
  ?c \PYGZlt{}\PYGZhy{} (collection \PYGZdl{}?collection)
  =\PYGZgt{}
 (retract ?f ?c)
 (assert (collection ?collection ?data)))
\end{sphinxVerbatim}

It certainly looks simpler, however, to use a global variable to collect
the slot values:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defglobal ?*collection* = (create\PYGZdl{}))

(defrule add\PYGZhy{}factoid
  (factoid ?data)
  =\PYGZgt{}
  (bind ?*collection* (create\PYGZdl{} ?*collection* ?data)))
\end{sphinxVerbatim}

Again, the drawback to this approach is that changes to a global
variable do not trigger pattern-matching, so in spite of its greater
complexity the fact-based approach is still preferable.

Although it’s important to understand how each of the previous
approaches work, they’re not practical solutions. If there are 1000
\sphinxstyleemphasis{factoid} facts, the add-factoid/add-factoid-helper rules will each fire
1000 times generating and retracting 2000 facts. The best solution is to
use the fact-set query functions to iterate over all of the \sphinxstyleemphasis{factoid}
facts and generate the \sphinxstyleemphasis{collection} fact as the result of a single rule
firing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule collect\PYGZhy{}factoids
  (collect\PYGZhy{}factoids)
  =\PYGZgt{}
  (bind ?data (create\PYGZdl{}))
  (do\PYGZhy{}for\PYGZhy{}all\PYGZhy{}facts ((?f factoid)) TRUE
  (bind ?data (create\PYGZdl{} ?data ?f:implied)))
  (assert (collection ?data)))
\end{sphinxVerbatim}

With this approach, the \sphinxstyleemphasis{collection} fact is available for
pattern-matching with the added benefit that there are no intermediate
results generated in creating the fact. Typically if other rules are
waiting for the finished result of the collection, they would need to
have lower salience so that they aren’t fired for the intermediate
results:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule print\PYGZhy{}factoids
  (declare (salience \PYGZhy{}10))
  (collection \PYGZdl{}?data)
  =\PYGZgt{}
  (printout t \PYGZdq{}The collected data is \PYGZdq{} ?data crlf))
\end{sphinxVerbatim}

If the \sphinxstyleemphasis{factoid} facts are collected by a single rule firing, then the
salience declaration is unnecessary.

Appropriate Uses

The primary use of global variables (in conjunction with rules) is in
making a program easier to maintain. It is a rare situation where a
global variable is required in order to solve a problem. One appropriate
use of global variables is defining salience values shared among
multiple rules:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defglobal ?*high\PYGZhy{}priority* = 100)

(defrule rule\PYGZhy{}1
  (declare (salience ?*high\PYGZhy{}priority*))
  =\PYGZgt{})

(defrule rule\PYGZhy{}2
  (declare (salience ?*high\PYGZhy{}priority*))
  =\PYGZgt{})
\end{sphinxVerbatim}

Another use is defining constants used on the LHS or RHS of a rule:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defglobal ?*week\PYGZhy{}days* =

(create\PYGZdl{} monday tuesday wednesday thursday friday saturday sunday))

(defrule invalid\PYGZhy{}day
  (day ?day\PYGZam{}:(not (member\PYGZdl{} ?day ?*week\PYGZhy{}days*)))
  =\PYGZgt{}
 (printout t ?day \PYGZdq{} is invalid\PYGZdq{} crlf))

(defrule valid\PYGZhy{}day
  (day ?day\PYGZam{}:(member\PYGZdl{} ?day ?*week\PYGZhy{}days*))
  =\PYGZgt{}
  (printout t ?day \PYGZdq{} is valid\PYGZdq{} crlf))
\end{sphinxVerbatim}

A third use is passing information to a rule when it is desirable \sphinxstyleemphasis{not}
to trigger pattern-matching. In the following rule, a global variable is
used to determine whether additional debugging information is printed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defglobal ?*debug\PYGZhy{}print* = nil)

(defrule rule\PYGZhy{}debug
  ?f \PYGZlt{}\PYGZhy{} (info ?info)
  =\PYGZgt{}
  (retract ?f)
  (printout ?*debug\PYGZhy{}print* \PYGZdq{}Retracting info \PYGZdq{} ?info crlf))
\end{sphinxVerbatim}

If ?*debug-print* is set to nil, then the printout statement will not
display any information. If the ?*debug-print* is set to t, then
debugging information will be sent to the screen. Because
?*debug-print* is a global, it can be changed interactively without
causing rules to be reactivated. This is useful when stepping through a
program because it allows the level of information displayed to be
changed without effecting the normal flow of the program.

It’s possible, but a little more verbose, to achieve this same
functionality using instances rather than global variables:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defclass DEBUG\PYGZhy{}INFO
  (is\PYGZhy{}a USER)
  (slot debug\PYGZhy{}print))

(definstances debug
([debug\PYGZhy{}info] of DEBUG\PYGZhy{}INFO (debug\PYGZhy{}print nil)))

(defrule rule\PYGZhy{}debug
  ?f \PYGZlt{}\PYGZhy{} (info ?info)
  =\PYGZgt{}
  (retract ?f)
  (printout (send [debug\PYGZhy{}info] get\PYGZhy{}debug\PYGZhy{}print) \PYGZdq{}Retracting info \PYGZdq{} ?info
  crlf))
\end{sphinxVerbatim}

Unlike fact slots, changes to a slot of an instance won’t trigger
pattern matching in a rule unless the slot is specified on the LHS of
that rule, thus you have explicit control over whether an instance slot
triggers pattern-matching. The following rule won’t be retriggered if a
change is made to the \sphinxstyleemphasis{debug-print} slot:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule rule\PYGZhy{}debug
  ?f \PYGZlt{}\PYGZhy{} (info ?info)
  (object (is\PYGZhy{}a DEBUG\PYGZhy{}INFO) (name ?name))
  =\PYGZgt{}
  (retract ?f)
  (printout (send ?name get\PYGZhy{}debug\PYGZhy{}print) \PYGZdq{}Retracting info \PYGZdq{} ?info crlf))
\end{sphinxVerbatim}

This is a generally applicable technique and can be used in many
situations to prevent rules from inadvertently looping when slot values
are changed.

\phantomsection\label{\detokenize{defglobal:section-4}}

\chapter{Section 7: Deffunction Construct}
\label{\detokenize{deffunction:section-7-deffunction-construct}}\label{\detokenize{deffunction::doc}}
With the \sphinxstylestrong{deffunction} construct, new functions may be defined
directly in CLIPS. Deffunctions are equivalent in use to other
functions; see section 2.3.2 for more detail on calling functions in
CLIPS. The only differences between user-defined external functions and
deffunctions are that deffunctions are written in CLIPS and executed by
CLIPS interpretively and user-defined external functions are written in
an external language, such as C, and executed by CLIPS directly. Also,
deffunctions allow the addition of new functions without having to
recompile and relink CLIPS.

A deffunction is comprised of five elements: 1) a name, 2) an optional
comment, 3) a list of zero or more required parameters, 4) an optional
wildcard parameter to handle a variable number of arguments and 5) a
sequence of actions, or expressions, which will be executed in order
when the deffunction is called.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deffunction} \PYG{o}{\PYGZlt{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{comment}\PYG{o}{\PYGZgt{}}\PYG{p}{]}
  \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{regular}\PYG{o}{\PYGZhy{}}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}\PYGZbs{}\PYG{o}{*} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{wildcard}\PYG{o}{\PYGZhy{}}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
   \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}

 \PYG{o}{\PYGZlt{}}\PYG{n}{regular}\PYG{o}{\PYGZhy{}}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{single}\PYG{o}{\PYGZhy{}}\PYG{n}{field}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{n}{wildcard}\PYG{o}{\PYGZhy{}}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{multifield}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

A deffunction must have a unique name different from all other system
functions and generic functions. In particular, a deffunction cannot be
overloaded like a system function (see section 8 for more detail). A
deffunction must be declared prior to being called from another
deffunction, generic function method, object message-handler, rule, or
the top level. The only exception is a self recursive deffunction.

A deffunction may accept \sphinxstyleemphasis{exactly} or \sphinxstyleemphasis{at least} a specified number of
arguments, depending on whether a wildcard parameter is used or not. The
regular parameters specify the minimum number of arguments that must be
passed to the deffunction. Each of these parameters may be referenced
like a normal single-field variable within the actions of the
deffunction. If a wildcard parameter is present, the deffunction may be
passed any number of arguments greater than or equal to the minimum. If
no wildcard parameter is present, then the deffunction must be passed
exactly the number of arguments specified by the regular parameters. All
arguments to a deffunction that do not correspond to a regular parameter
are grouped into a multifield value that can be referenced by the
wildcard parameter. The standard CLIPS multifield functions, such as
length and nth, can be applied to the wildcard parameter.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(deffunction print\PYGZhy{}args (?a ?b \PYGZdl{}?c)
  (printout t ?a \PYGZdq{} \PYGZdq{} ?b \PYGZdq{} and \PYGZdq{} (length ?c) \PYGZdq{} extras: \PYGZdq{} ?c crlf))
CLIPS\PYGZgt{} (print\PYGZhy{}args 1 2)
1 2 and 0 extras: ()
CLIPS\PYGZgt{} (print\PYGZhy{}args a b c d)
a b and 2 extras: (c d)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

When a deffunction is called, its actions are executed in order. The
return value of a deffunction is the evaluation of the last action. If a
deffunction has no actions, its return value is the symbol FALSE. If an
error occurs while the deffunction is executing, any actions not yet
executed will be aborted, and the deffunction will return the symbol
FALSE.

Deffunctions may be self and mutually recursive. Self recursion is
accomplished simply by calling the deffunction from within its own
actions.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(deffunction factorial (?a)
  (if (or (not (integerp ?a)) (\PYGZlt{} ?a 0)) then
    (printout t \PYGZdq{}Factorial Error!\PYGZdq{} crlf)
   else
    (if (= ?a 0) then
       1
     else
       (* ?a (factorial (\PYGZhy{} ?a 1))))))
\end{sphinxVerbatim}

Mutual recursion between two deffunctions requires a forward declaration
of one of the deffunctions. A forward declaration is simply a
declaration of the deffunction without any actions. In the following
example, the deffunction foo is forward declared so that it may be
called by the deffunction bar. Then the deffunction foo is redefined
with actions that call the deffunction bar.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deffunction} \PYG{n}{foo} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{deffunction} \PYG{n}{bar} \PYG{p}{(}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{foo}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{deffunction} \PYG{n}{foo} \PYG{p}{(}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{bar}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Care should be taken with recursive deffunctions; too many levels of
recursion can lead to an overflow of stack memory (especially on PC-type
machines).

\phantomsection\label{\detokenize{deffunction:section-5}}

\chapter{Section 8: Generic Functions}
\label{\detokenize{generic:section-8-generic-functions}}\label{\detokenize{generic::doc}}
With the \sphinxstylestrong{defgeneric} and \sphinxstylestrong{defmethod} constructs, new generic
functions may be written directly in CLIPS. Generic functions are
similar to deffunctions because they can be used to define new
procedural code directly in CLIPS, and they can be called like any other
function (see sections 2.3.2 and 7). However, generic functions are much
more powerful because they can do different things depending on the
types (or classes) and number of their arguments. For example, a ?+?
operator could be defined which performs concatenation for strings but
still performs arithmetic addition for numbers. Generic functions are
comprised of multiple components called \sphinxstylestrong{methods}, where each method
handles different cases of arguments for the generic function. A generic
function which has more than one method is said to be \sphinxstylestrong{overloaded}.

Generic functions can have system functions and user-defined external
functions as \sphinxstyleemphasis{implicit} methods. For example, an overloading of the ?+?
operator to handle strings consists of two methods: 1) an implicit one
which is the system function handling numerical addition, and 2) an
explicit (user-defined) one handling string concatenation. Deffunctions,
however, may not be methods of generic functions because they are
subsumed by generic functions anyway. Deffunctions are only provided so
that basic new functions can be added directly in CLIPS without the
concerns of overloading. For example, a generic function that has only
one method that restricts only the number of arguments is equivalent to
a deffunction.

In most cases, generic function methods are not called directly (the
function \sphinxstylestrong{call-specific-method} described in section 12.15.8 can be
used to do so, however). CLIPS recognizes that a function call is
generic and uses the generic function?s arguments to find and execute
the appropriate method. This process is termed the \sphinxstylestrong{generic dispatch}.


\section{8.1 Note on the Use of the Term \sphinxstyleemphasis{Method}}
\label{\detokenize{generic:note-on-the-use-of-the-term-method}}
Most OOP systems support procedural behavior of objects either through
message-passing (e.g. Smalltalk) or by generic functions (e.g. CLOS).
CLIPS supports both of these mechanisms, although generic functions are
not strictly part of COOL. A generic function may examine the classes of
its arguments but must still use messages within the bodies of its
methods to manipulate any arguments that are instances of user-defined
classes. Section 9 gives more details on COOL. The fact that CLIPS
supports both mechanisms leads to confusion in terminology. In OOP
systems that support message-passing only, the term \sphinxstylestrong{method} is used
to denote the different implementations of a \sphinxstylestrong{message} for different
classes. In systems that support generic functions only, however, the
term \sphinxstylestrong{method} is used to denote the different implementations of a
generic function for different sets of argument restrictions. To avoid
this confusion, the term \sphinxstylestrong{message-handler} is used to take the place
of \sphinxstylestrong{method} in the context of messages. Thus in CLIPS,
\sphinxstylestrong{message-handlers} denote the different implementations of a
\sphinxstylestrong{message} for different classes, and \sphinxstylestrong{methods} denote the different
implementations of a \sphinxstylestrong{generic function} for different sets of argument
restrictions.


\section{8.2 Performance Penalty of Generic Functions}
\label{\detokenize{generic:performance-penalty-of-generic-functions}}
A call to a generic function is computationally more expensive than a
call to a system function, user-defined external function or
deffunction. This is because CLIPS must first examine the function
arguments to determine which method is applicable. A performance penalty
of 15\%-20\% is not unexpected. Thus, generic functions should not be used
for routines for which time is critical, such as routines that are
called within a while loop, if at all possible. Also, generic functions
should always have at least two methods. Deffunctions or user-defined
external functions should be used when overloading is not required. A
system or user-defined external function that is not overloaded will, of
course, execute as quickly as ever, since the generic dispatch is
unnecessary.


\section{8.3 Order Dependence of Generic Function Definitions}
\label{\detokenize{generic:order-dependence-of-generic-function-definitions}}
If a construct which uses a system or user-defined external function is
loaded before a generic function that uses that function as an implicit
method, all calls to that function from that construct will bypass the
generic dispatch. For example, if a generic function which overloads the
?+? operator is defined after a rule which uses the ?+? operator, that
rule will always call the ?+? system function directly. However, similar
rules defined after the generic function will use the generic dispatch.


\section{8.4 Defining a New Generic Function}
\label{\detokenize{generic:defining-a-new-generic-function}}
A generic function is comprised of a header (similar to a forward
declaration) and zero or more methods. A generic function header can
either be explicitly declared by the user or implicitly declared by the
definition of at least one method. A method is comprised of six
elements: 1) a name (which identifies to which generic function the
method belongs), 2) an optional index, 3) an optional comment, 4) a set
of parameter \sphinxstylestrong{restrictions}, 5) an optional wildcard parameter
restriction to handle a variable number of arguments and 6) a sequence
of actions, or expressions, which will be executed in order when the
method is called. The parameter restrictions are used by the generic
dispatch to determine a method?s applicability to a set of arguments
when the generic function is actually called. The \sphinxstylestrong{defgeneric}
construct is used to specify the generic function header, and the
\sphinxstylestrong{defmethod} construct is used for each of the generic function?s
methods.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defgeneric} \PYG{o}{\PYGZlt{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{comment}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defmethod} \PYG{o}{\PYGZlt{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{index}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{comment}\PYG{o}{\PYGZgt{}}\PYG{p}{]}
  \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{parameter}\PYG{o}{\PYGZhy{}}\PYG{n}{restriction}\PYG{o}{\PYGZgt{}}\PYG{o}{*} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{wildcard}\PYG{o}{\PYGZhy{}}\PYG{n}{parameter}\PYG{o}{\PYGZhy{}}\PYG{n}{restriction}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
   \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}

\PYG{o}{\PYGZlt{}}\PYG{n}{parameter}\PYG{o}{\PYGZhy{}}\PYG{n}{restriction}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{single}\PYG{o}{\PYGZhy{}}\PYG{n}{field}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
  \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{single}\PYG{o}{\PYGZhy{}}\PYG{n}{field}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n+nb}{type}\PYG{o}{\PYGZgt{}}\PYG{o}{*} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}

\PYG{o}{\PYGZlt{}}\PYG{n}{wildcard}\PYG{o}{\PYGZhy{}}\PYG{n}{parameter}\PYG{o}{\PYGZhy{}}\PYG{n}{restriction}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{multifield}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}}
  \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{multifield}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n+nb}{type}\PYG{o}{\PYGZgt{}}\PYG{o}{*} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}

\PYG{o}{\PYGZlt{}}\PYG{n+nb}{type}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{k}{global}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}} \PYG{o}{\textbar{}} \PYG{o}{\PYGZlt{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{call}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

A generic function must be declared, either by a header or a method,
prior to being called from another generic function method, deffunction,
object message-handler, rule, or the top level. The only exception is a
self recursive generic function.


\subsection{8.4.1 Generic Function Headers}
\label{\detokenize{generic:generic-function-headers}}
A generic function is uniquely identified by name. In order to reference
a generic function in other constructs before any of its methods are
declared, an explicit header is necessary. Otherwise, the declaration of
the first method implicitly creates a header. For example, two generic
functions whose methods mutually call the other generic function
(mutually recursive generic functions) would require explicit headers.


\subsection{8.4.2 Method Indices}
\label{\detokenize{generic:method-indices}}
A method is uniquely identified by name and index, or by name and
parameter restrictions. Each method for a generic function is assigned a
unique integer index within the group of all methods for that generic
function. Thus, if a new method is defined which has exactly the same
name and parameter restrictions as another method, CLIPS will
automatically replace the older method. However, any difference in
parameter restrictions will cause the new method to be defined \sphinxstyleemphasis{in
addition to} the older method. To replace an old method with one that
has different parameter restrictions, the index of the old method can be
explicitly specified in the new method definition. However, the
parameter restrictions of the new method must not match that of another
method with a different index. If an index is not specified, CLIPS
assigns an index that has never been used by any method (past or
current) of this generic function. The index assigned by CLIPS can be
determined with the \sphinxstylestrong{list-defmethods} command (see section 13.10.4).


\subsection{8.4.3 Method Parameter Restrictions}
\label{\detokenize{generic:method-parameter-restrictions}}
Each parameter for a method can be defined to have arbitrarily complex
restrictions or none at all. A parameter restriction is applied to a
generic function argument at run-time to determine if a particular
method will accept the argument. A parameter can have two types of
restrictions: type and query. A type restriction constrains the classes
of arguments that will be accepted for a parameter. A query restriction
is a user-defined boolean test which must be satisfied for an argument
to be acceptable. The complexity of parameter restrictions directly
affects the speed of the generic dispatch.

A parameter that has no restrictions means that the method will accept
any argument in that position. However, each method of a generic
function must have parameter restrictions that make it distinguishable
from all of the other methods so that the generic dispatch can tell
which one to call at run-time. If there are no applicable methods for a
particular generic function call, CLIPS will generate an error (see
section 8.5.4 for more detail).

A type restriction allows the user to specify a list of types (or
classes), one of which must match (or be a superclass of) the class of
the generic function argument. If COOL is not installed in the current
CLIPS configuration, the only types (or classes) available are: OBJECT,
PRIMITIVE, LEXEME, SYMBOL, STRING, NUMBER, INTEGER, FLOAT, MULTIFIELD,
FACT-ADDRESS and EXTERNAL-ADDRESS. Section 9 describes each of these
system classes. With COOL, INSTANCE, INSTANCE-ADDRESS, INSTANCE-NAME,
USER, INITIAL-OBJECT and any user-defined classes are also available.
Generic functions that use only the first group of types in their
methods will work the same whether COOL is installed or not. The classes
in a type restriction must be defined already, since they are used to
predetermine the precedence between a generic function?s methods (see
section 8.5.2 for more detail). Redundant classes are not allowed in
restriction class lists. For example, the following method parameter?s
type restriction is redundant since INTEGER is a subclass of NUMBER.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmethod foo ((?a INTEGER NUMBER)))
\end{sphinxVerbatim}

If the type restriction (if any) is satisfied for an argument, then a
query restriction (if any) will be applied. The query restriction must
either be a global variable or a function call. CLIPS evaluates this
expression, and if it evaluates to anything but the symbol FALSE, the
restriction is considered satisfied. Since a query restriction is not
always satisfied, queries should \sphinxstyleemphasis{not} have any side-effects, for they
will be evaluated for a method that may not end up being applicable to
the generic function call. Since parameter restrictions are examined
from left to right, queries that involve multiple parameters should be
included with the rightmost parameter. This insures that all parameter
type restrictions have already been satisfied. For example, the
following method delays evaluation of the query restriction until the
classes of both arguments have been verified.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmethod foo ((?a INTEGER) (?b INTEGER (\PYGZgt{} ?a ?b))))
\end{sphinxVerbatim}

If the argument passes all these tests, it is deemed acceptable to a
method. If \sphinxstyleemphasis{all} generic function arguments are accepted by a method?s
restrictions, the method itself is deemed \sphinxstylestrong{applicable} to the set of
arguments. When more than one method is applicable to a set of
arguments, the generic dispatch must determine an ordering among them
and execute the first one in that ordering. Method precedence is used
for this purpose and will be discussed in section 8.5.2.

Example

In the following example, the first call to the generic function ?+?
executes the system operator ?+?, an implicit method for numerical
addition. The second call executes the explicit method for string
concatenation, since there are two arguments and they are both strings.
The third call generates an error because the explicit method for string
concatenation only accepts two arguments and the implicit method for
numerical addition does not accept strings at all.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  CLIPS\PYGZgt{} (clear)
  CLIPS\PYGZgt{} (defmethod + ((?a STRING) (?b STRING))
(str\PYGZhy{}cat ?a ?b))

  CLIPS\PYGZgt{} (+ 1 2)
  3

  CLIPS\PYGZgt{} (+ \PYGZdq{}foo\PYGZdq{} \PYGZdq{}bar\PYGZdq{})
  \PYGZdq{}foobar\PYGZdq{}

  CLIPS\PYGZgt{} (+ \PYGZdq{}foo\PYGZdq{} \PYGZdq{}bar\PYGZdq{} \PYGZdq{}woz\PYGZdq{})
  [GENRCEXE1] No applicable methods for +.
  FALSE
  CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{8.4.4 Method Wildcard Parameter}
\label{\detokenize{generic:method-wildcard-parameter}}
A method may accept \sphinxstyleemphasis{exactly} or \sphinxstyleemphasis{at least} a specified number of
arguments, depending on whether a wildcard parameter is used or not. The
regular parameters specify the minimum number of arguments that must be
passed to the method. Each of these parameters may be referenced like a
normal single-field variable within the actions of the method. If a
wildcard parameter is present, the method may be passed any number of
arguments greater than or equal to the minimum. If no wildcard parameter
is present, then the method must be passed exactly the number of
arguments specified by the regular parameters. Method arguments that do
not correspond to a regular parameter can be grouped into a multifield
value that can be referenced by the wildcard parameter within the body
of the method. The standard CLIPS multifield functions, such as length\$
and expand\$, can be applied to the wildcard parameter.

If multifield values are passed as extra arguments, they will all be
merged into one multifield value referenced by the wildcard parameter.
This is because CLIPS does not support nested multifield values.

Type and query restrictions can be applied to arguments grouped in the
wildcard parameter similarly to regular parameters. Such restrictions
apply to each individual field of the resulting multifield value (not
the entire multifield). However, expressions involving the wildcard
parameter variable may be used in the query. In addition, a special
variable may be used in query restrictions on the wildcard parameter to
refer to the individual arguments grouped into the wildcard:
\sphinxstylestrong{?current-argument}. This variable is only in scope within the query
and has no meaning in the body of the method. For example, to create a
version of the ?+? operator which acts differently for sums of all even
integers:

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (defmethod + ((\PYGZdl{}?any INTEGER (evenp ?current\PYGZhy{}argument)))
  (div (call\PYGZhy{}next\PYGZhy{}method) 2))

CLIPS\PYGZgt{} (+ 1 2)
3

CLIPS\PYGZgt{} (+ 4 6 4)
7
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

It is important to emphasize that query and type restrictions on the
wildcard parameter are applied to every argument grouped in the
wildcard. Thus in the following example, the \sphinxstylestrong{\textgreater{}} and \sphinxstylestrong{length\$}
functions are actually called three times, since there are three
arguments:

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (defmethod foo ((\PYGZdl{}?any (\PYGZgt{} (length\PYGZdl{} ?any) 2))) yes)
CLIPS\PYGZgt{} (foo 1 red 3)
yes
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

In addition, a query restriction will never be examined if there are no
arguments in the wildcard parameter range. For example, the the previous
method\sphinxstyleemphasis{would} be applicable to a call to the generic function with no
arguments because the query restriction is never evaluated:

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{foo}\PYG{p}{)}
\PYG{n}{yes}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Typically query restrictions applied to the entire wildcard parameter
are testing the cardinality (the number of arguments passed to the
method). In cases like this where the type is irrelevant to the test,
the query restriction can be attached to a regular parameter instead to
improve performance (see section 8.5.1). Thus the previous method could
be improved as follows:

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{} (defmethod foo ((?arg (\PYGZgt{} (length\PYGZdl{} ?any) 1)) \PYGZdl{}?any) yes)
CLIPS\PYGZgt{} (foo)
[GENRCEXE1] No applicable methods for foo.
FALSE
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

This approach should not be used if the types of the arguments grouped
by the wildcard must be verified prior to safely evaluating the query
restriction.


\section{8.5 Generic Dispatch}
\label{\detokenize{generic:generic-dispatch}}
When a generic function is called, CLIPS selects the method for that
generic function with highest precedence for which parameter
restrictions are satisfied by the arguments. This method is executed,
and its value is returned as the value of the generic function. This
entire process is referred to as the \sphinxstylestrong{generic dispatch}. Below is a
flow diagram summary:

{\color{red}\bfseries{}\textbar{}image1\textbar{}}

The solid arrows indicate automatic control transfer by the generic
dispatch. The dashed arrows indicate control transfer that can only be
accomplished by the use or lack of the use of call-next-method or
override-next-method.


\subsection{8.5.1 Applicability of Methods Summary}
\label{\detokenize{generic:applicability-of-methods-summary}}
An explicit (user-defined) method is applicable to a generic function
call if the following three conditions are met:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
its name matches that of the generic function,

\item {} 
it accepts at least as many arguments as were passed to the generic
function, and

\item {} 
every argument of the generic function satisfies the corresponding
parameter restriction (if any) of the method.

\end{enumerate}

Method restrictions are examined from left to right. As soon as one
restriction is not satisfied, the method is abandoned, and the rest of
the restrictions (if any) are not examined.

When a standard CLIPS system function is overloaded, CLIPS forms an
implicit method definition corresponding to that system function. This
implicit method is derived from the argument restriction string for the
external \sphinxstylestrong{DefineFunction2} call defining that function to CLIPS (see
the \sphinxstyleemphasis{Advanced Programming Guide}). This string can be accessed with the
function \sphinxstylestrong{get-function-restrictions}. The specification of this
implicit method can be examined with the \sphinxstylestrong{list-defmethods} or
\sphinxstylestrong{get-method-restrictions} functions. The method that CLIPS will form
for a system function can be derived by the user from the BNF given in
this document. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{+} \PYG{o}{\PYGZlt{}}\PYG{n}{number}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{number}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

would yield the following method for the ?+? function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmethod + ((?first NUMBER) (?second NUMBER) (\PYGZdl{}?rest NUMBER)) ...)
\end{sphinxVerbatim}

The method definition is used to determine the applicability and
precedence of the system function to the generic function call.

The following system functions cannot be overloaded, and CLIPS will
generate an error if an attempt is made to do so.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{active-duplicate-instance}
&
\sphinxstylestrong{find-instance}
\\
\hline
\sphinxstylestrong{active-initialize-instance}
&
\sphinxstylestrong{foreach}
\\
\hline
\sphinxstylestrong{active-make-instance}
&
\sphinxstylestrong{if}
\\
\hline
\sphinxstylestrong{active-message-duplicate-instance}
&
\sphinxstylestrong{make-instance}
\\
\hline
\sphinxstylestrong{active-message-modify-instance}
&
\sphinxstylestrong{initialize-instance}
\\
\hline
\sphinxstylestrong{active-modify-instance}
&
\sphinxstylestrong{loop-for-count}
\\
\hline
\sphinxstylestrong{any-instancep}
&
\sphinxstylestrong{message-duplicate-instance}
\\
\hline
\sphinxstylestrong{assert}
&
\sphinxstylestrong{message-modify-instance}
\\
\hline
\sphinxstylestrong{bind}
&
\sphinxstylestrong{modify}
\\
\hline
\sphinxstylestrong{break}
&
\sphinxstylestrong{modify-instance}
\\
\hline
\sphinxstylestrong{call-next-handler}
&
\sphinxstylestrong{next-handlerp}
\\
\hline
\sphinxstylestrong{call-next-method}
&
\sphinxstylestrong{next-methodp}
\\
\hline
\sphinxstylestrong{call-specific-method}
&
\sphinxstylestrong{object-pattern-match-delay}
\\
\hline
\sphinxstylestrong{delayed-do-for-all-instances}
&
\sphinxstylestrong{override-next-handler}
\\
\hline
\sphinxstylestrong{do-for-all-instances}
&
\sphinxstylestrong{override-next-method}
\\
\hline
\sphinxstylestrong{do-for-instance}
&
\sphinxstylestrong{progn}
\\
\hline
\sphinxstylestrong{duplicate}
&
\sphinxstylestrong{progn\$}
\\
\hline
\sphinxstylestrong{duplicate-instance}
&
\sphinxstylestrong{return}
\\
\hline
\sphinxstylestrong{expand\$}
&
\sphinxstylestrong{switch}
\\
\hline
\sphinxstylestrong{find-all-instances}
&
\sphinxstylestrong{while}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{8.5.2 Method Precedence}
\label{\detokenize{generic:method-precedence}}
When two or more methods are applicable to a particular generic function
call, CLIPS must pick the one with highest \sphinxstylestrong{precedence} for execution.
Method precedence is determined when a method is defined; the
\sphinxstylestrong{list-defmethods} function can be used to examine the precedence of
methods for a generic function (see section 13.10).

The precedence between two methods is determined by comparing their
parameter restrictions. In general, the method with the most specific
parameter restrictions has the highest precedence. For example, a method
that demands an integer for a particular argument will have higher
precedence than a method which only demands a number. The exact rules of
precedence between two methods are given in order below; the result of
the first rule that establishes precedence is taken.

1. The parameter restrictions of both methods are positionally compared
from left to right. In other words, the first parameter restriction in
the first method is matched against the first parameter restriction in
the second method, and so on. The comparisons between these pairs of
parameter restrictions from the two methods determine the overall
precedence between the two methods. The result of the first pair of
parameter restrictions that specifies precedence is taken. The following
rules are applied in order to a parameter pair; the result of the first
rule that establishes precedence is taken.
\begin{enumerate}
\def\theenumi{\alph{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
A regular parameter has precedence over a wildcard parameter.

\item {} 
The most specific type restriction on a particular parameter has priority.
A class is more specific than any of its superclasses.

\item {} 
A parameter with a query restriction has priority over one that does not.

\end{enumerate}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{1}
\item {} 
The method with the greater number of regular parameters has precedence.

\item {} 
A method without a wildcard parameter has precedence over one that does

\item {} 
A method defined before another one has priority.

\end{enumerate}

If there are multiple classes on a single restriction, determining
specificity is slightly more complicated. Since all precedence
determination is done when the new method is defined, and the actual
class of the generic function argument will not be known until run-time,
arbitrary (but deterministic) rules are needed for determining the
precedence between two class lists. The two class lists are examined by
pairs from left to right, e.g. the pair of first classes from both
lists, the pair of second classes from both lists and so on. The first
pair containing a class and its superclass specify precedence. The class
list containing the subclass has priority. If no class pairs specify
precedence, then the shorter class list has priority. Otherwise, the
class lists do not specify precedence between the parameter
restrictions.

Example 1

\begin{sphinxVerbatim}[commandchars=\\\{\}]
; The system operator \PYGZsq{}+\PYGZsq{} is an implicit method ; \PYGZsh{}1
; Its definition provided by the system is:
; (defmethod + ((?a NUMBER) (?b NUMBER) (\PYGZdl{}?rest NUMBER)))
(defmethod + ((?a NUMBER) (?b INTEGER))) ; \PYGZsh{}2
(defmethod + ((?a INTEGER) (?b INTEGER))) ; \PYGZsh{}3
(defmethod + ((?a INTEGER) (?b NUMBER))) ; \PYGZsh{}4
(defmethod + ((?a NUMBER) (?b NUMBER) ; \PYGZsh{}5
(\PYGZdl{}?rest PRIMITIVE)))
(defmethod + ((?a NUMBER) ; \PYGZsh{}6
(?b INTEGER (\PYGZgt{} ?b 2))))
(defmethod + ((?a INTEGER (\PYGZgt{} ?a 2)) ; \PYGZsh{}7
(?b INTEGER (\PYGZgt{} ?b 3))))
(defmethod + ((?a INTEGER (\PYGZgt{} ?a 2)) ; \PYGZsh{}8
(?b NUMBER)))
\end{sphinxVerbatim}

The precedence would be: \#7,\#8,\#3,\#4,\#6,\#2,\#1,\#5. The methods can be
immediately partitioned into three groups of decreasing precedence
according to their restrictions on the first parameter: A) methods which
have a query restriction and a type restriction of INTEGER (\#7,\#8), B)
methods which have a type restriction of INTEGER (\#3,\#4), and C) methods
which have a type restriction of NUMBER (\#1,\#2,\#5,\#6). Group A has
precedence over group B because parameters with query restrictions have
priority over those that do not. Group B has precedence over group C
because INTEGER is a subclass of NUMBER. Thus, the ordering so far is:
(\#7,\#8),(\#3,\#4),(\#1,\#2,\#5,\#6). Ordering between the methods in a
particular set of parentheses is not yet established.

The next step in determining precedence between these methods considers
their restrictions on the second parameter. \#7 has priority over \#8
because INTEGER is a subclass of NUMBER. \#3 has priority over \#4 because
INTEGER is a subclass of NUMBER. \#6 and \#2 have priority over \#1 and \#5
because INTEGER is a subclass of NUMBER. \#6 has priority over \#2 because
it has a query restriction and \#2 does not. Thus the ordering is now:
\#7,\#8,\#3,\#4,\#6,\#2,(\#1,\#5).

The restriction on the wildcard argument yields that \#1 (the system
function implicit method) has priority over \#5 since NUMBER is a
sublclass of PRIMITIVE. This gives the final ordering:
\#7,\#8,\#3,\#4,\#6,\#2,\#1,\#5.

Example 2

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmethod foo ((?a NUMBER STRING))) ; \PYGZsh{}1
(defmethod foo ((?a INTEGER LEXEME))) ; \PYGZsh{}2
\end{sphinxVerbatim}

The precedence would be \#2,\#1. Although STRING is a subclass of LEXEME,
the ordering is still \#2,\#1 because INTEGER is a subclass of NUMBER, and
NUMBER/INTEGER is the leftmost pair in the class lists.

Example 3

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmethod foo ((?a MULTIFIELD STRING))) ; \PYGZsh{}1
(defmethod foo ((?a LEXEME))) ; \PYGZsh{}2
\end{sphinxVerbatim}

The precedence would be \#2,\#1 because the classes of the first pair in
the type restriction (MULTIFIELD/LEXEME) are unrelated and \#2 has fewer
classes in its class list.

Example 4

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmethod foo ((?a INTEGER LEXEME))) ; \PYGZsh{}1
(defmethod foo ((?a STRING NUMBER))) ; \PYGZsh{}2
\end{sphinxVerbatim}

Both pairs of classes (INTEGER/STRING and LEXEME/NUMBER) are unrelated,
and the class lists are of equal length. Thus, the precedence is taken
from the order of definition: \#1,\#2.


\subsection{8.5.3 Shadowed Methods}
\label{\detokenize{generic:shadowed-methods}}
If one method must be called by another method in order to be executed,
the first function or method is a said to be \sphinxstylestrong{shadowed} by the second
method. Normally, only one method or system function will be applicable
to a particular generic function call. If there is more than one
applicable method, the generic dispatch will only execute the one with
highest precedence. Letting the generic dispatch automatically handle
the methods in this manner is called the \sphinxstylestrong{declarative} technique, for
the declarations of the method restrictions dictate which method gets
executed in specific circumstances. However, the functions
\sphinxstylestrong{call-next-method} and \sphinxstylestrong{override-next-method} (see section 12.15.6
and 12.15.7) may also be used which allow a method to execute the method
that it is shadowing. This is called the \sphinxstylestrong{imperative} technique, since
the method execution itself plays a role in the generic dispatch. This
is \sphinxstyleemphasis{not} recommended unless it is absolutely necessary. In most
circumstances, only one piece of code should need to be executed for a
particular set of arguments. Another imperative technique is to use the
function \sphinxstylestrong{call-specific-method} to override method precedence (see
section 12.15.8)


\subsection{8.5.4 Method Execution Errors}
\label{\detokenize{generic:method-execution-errors}}
If an error occurs while any method for a generic function call is
executing, any actions in the current method not yet executed will be
aborted, any methods not yet called will be aborted, and the generic
function will return the symbol FALSE. The lack of any applicable
methods for a set of generic function arguments is considered a method
execution error.


\subsection{8.5.5 Generic Function Return Value}
\label{\detokenize{generic:generic-function-return-value}}
The return value of a generic function is the return value of the
applicable method with the highest precedence. Each applicable method
that is executed can choose to ignore or capture the return value of any
method that it is shadowing.

The return value of a particular method is the last action evaluated by
that method.

\phantomsection\label{\detokenize{generic:section-6}}

\chapter{Section 9: CLIPS Object Oriented Language}
\label{\detokenize{cool:section-9-clips-object-oriented-language}}\label{\detokenize{cool::doc}}
This section provides the comprehensive details of the CLIPS
Object-Oriented Language (COOL). Sections 2.3.1, 2.4.2 and 2.5.2.3
explain object references and structure. Section 2.6 gives a high level
overview of COOL. This section assumes a complete understanding of the
material given in the listed sections.


\section{9.1 Background}
\label{\detokenize{cool:background}}
COOL is a hybrid of features from many different OOP systems as well as
new ideas. For example, object encapsulation concepts are similar to
those in Smalltalk, and the Common Lisp Object System (CLOS) provides
the basis for multiple inheritance rules. A mixture of ideas from
Smalltalk, CLOS and other systems form the foundation of messages.
Section 8.1 explains an important contrast between the terms \sphinxstylestrong{method}
and \sphinxstylestrong{message-handler} in CLIPS.


\section{9.2 Predefined System Classes}
\label{\detokenize{cool:predefined-system-classes}}
COOL provides seventeen system classes: OBJECT, USER, INITIAL-OBJECT,
PRIMITIVE, NUMBER, INTEGER, FLOAT, INSTANCE, INSTANCE-NAME,
INSTANCE-ADDRESS, ADDRESS, FACT-ADDRESS, EXTERNAL-ADDRESS, MULTIFIELD,
LEXEME, SYMBOL and STRING. The user may not delete or modify any of
these classes. The diagram illustrates the inheritance relationships
between these classes.

{\color{red}\bfseries{}\textbar{}image2\textbar{}}

All of these system classes except INITIAL-OBJECT are \sphinxstylestrong{abstract}
classes, which means that their only use is for inheritance (\sphinxstylestrong{direct}
instances of this class are illegal). None of these classes have slots,
and, except for the class USER, none of them have message-handlers.
However, the user may explicitly attach message-handlers to all of the
system classes except for INSTANCE, INSTANCE-ADDRESS and INSTANCE-NAME.
The OBJECT class is a superclass of all other classes, including
user-defined classes. All user-defined classes should (but are not
required to) inherit directly or indirectly from the class USER, since
this class has all of the standard system message-handlers, such as
initialization and deletion, attached to it. Section 9.4 describes these
system message-handlers.

The PRIMITIVE system class and all of its subclasses are provided mostly
for use in generic function method restrictions, but message-handlers
and new subclasses may be attached if desired. However, the three
primitive system classes INSTANCE, INSTANCE-ADDRESS and INSTANCE-NAME
are provided strictly for use in methods (particularly in forming
implicit methods for overloaded system functions - see section 8.5.1)
and as such cannot have subclasses or message-handlers attached to them.

The INITIAL-OBJECT class is provided for use by the default
\sphinxstylestrong{definstances} initial-object in creating the default instance
{[}initial-object{]} during the \sphinxstylestrong{reset} command. This system class is
\sphinxstylestrong{concrete} and \sphinxstylestrong{reactive} to pattern-matching on the LHS of rules
but is in other respects exactly like the system class USER. The
instance {[}initial-object{]} is for use by the initial-object pattern (see
section 5.4.9).


\section{9.3 Defclass Construct}
\label{\detokenize{cool:defclass-construct}}
A \sphinxstylestrong{defclass} is a construct for specifying the properties (slots) and
behavior (message-handlers) of a class of objects. A defclass consists
of five elements: 1) a name, 2) a list of superclasses from which the
new class inherits slots and message-handlers, 3) a specifier saying
whether or not the creation of direct instances of the new class is
allowed, 4) a specifier saying whether or not instances of this class
can match object patterns on the LHS of rules and 5) a list of slots
specific to the new class. All user-defined classes must inherit from at
least one class, and to this end COOL provides predefined system classes
for use as a base in the derivation of new classes.

Any slots explicitly given in the defclass override those gotten from
inheritance. COOL applies rules to the list of superclasses to generate
a class precedence list (see section 9.3.1) for the new class. Facets
(see section 9.3.3) further describe slots. Some examples of facets
include: default value, cardinality, and types of access allowed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Defaults are in **xxxxx**.

(defclass \PYGZlt{}name\PYGZgt{} [\PYGZlt{}comment\PYGZgt{}]
  (is\PYGZhy{}a \PYGZlt{}superclass\PYGZhy{}name\PYGZgt{}+)
  [\PYGZlt{}role\PYGZgt{}]
  [\PYGZlt{}pattern\PYGZhy{}match\PYGZhy{}role\PYGZgt{}]
  \PYGZlt{}slot\PYGZgt{}*
  \PYGZlt{}handler\PYGZhy{}documentation\PYGZgt{}*)

\PYGZlt{}role\PYGZgt{} ::= (role concrete \textbar{} abstract)

\PYGZlt{}pattern\PYGZhy{}match\PYGZhy{}role\PYGZgt{} ::= (pattern\PYGZhy{}match reactive \textbar{} non\PYGZhy{}reactive)

\PYGZlt{}slot\PYGZgt{} ::= (slot \PYGZlt{}name\PYGZgt{} \PYGZlt{}facet\PYGZgt{}*) \textbar{} (single\PYGZhy{}slot \PYGZlt{}name\PYGZgt{} \PYGZlt{}facet\PYGZgt{}*) \textbar{}
           (multislot \PYGZlt{}name\PYGZgt{} \PYGZlt{}facet\PYGZgt{}*)

\PYGZlt{}facet\PYGZgt{} ::= \PYGZlt{}default\PYGZhy{}facet\PYGZgt{} \textbar{} \PYGZlt{}storage\PYGZhy{}facet\PYGZgt{} \textbar{}
            \PYGZlt{}access\PYGZhy{}facet\PYGZgt{} \textbar{} \PYGZlt{}propagation\PYGZhy{}facet\PYGZgt{} \textbar{}
            \PYGZlt{}source\PYGZhy{}facet\PYGZgt{} \textbar{} \PYGZlt{}pattern\PYGZhy{}match\PYGZhy{}facet\PYGZgt{} \textbar{}
            \PYGZlt{}visibility\PYGZhy{}facet\PYGZgt{} \textbar{} \PYGZlt{}create\PYGZhy{}accessor\PYGZhy{}facet\PYGZgt{}
            \PYGZlt{}override\PYGZhy{}message\PYGZhy{}facet\PYGZgt{} \textbar{} \PYGZlt{}constraint\PYGZhy{}attributes\PYGZgt{}

\PYGZlt{}default\PYGZhy{}facet\PYGZgt{} ::= (default **?DERIVE** \textbar{} ?NONE \textbar{} \PYGZlt{}expression\PYGZgt{}*) \textbar{}
                    (default\PYGZhy{}dynamic \PYGZlt{}expression\PYGZgt{}*)

\PYGZlt{}storage\PYGZhy{}facet\PYGZgt{} ::= (storage **local** \textbar{} shared)

\PYGZlt{}access\PYGZhy{}facet\PYGZgt{} ::= (access **read\PYGZhy{}write** \textbar{} read\PYGZhy{}only \textbar{} initialize\PYGZhy{}only)

\PYGZlt{}propagation\PYGZhy{}facet\PYGZgt{} ::= (propagation **inherit** \textbar{} no\PYGZhy{}inherit)

\PYGZlt{}source\PYGZhy{}facet\PYGZgt{} ::= (source **exclusive** \textbar{} composite)

\PYGZlt{}pattern\PYGZhy{}match\PYGZhy{}facet\PYGZgt{} ::= (pattern\PYGZhy{}match **reactive** \textbar{} non\PYGZhy{}reactive)

\PYGZlt{}visibility\PYGZhy{}facet\PYGZgt{} ::= (visibility **private** \textbar{} public)

\PYGZlt{}create\PYGZhy{}accessor\PYGZhy{}facet\PYGZgt{} ::= (create\PYGZhy{}accessor ?NONE \textbar{} read \textbar{} write \textbar{}
                             **read\PYGZhy{}write**)

\PYGZlt{}override\PYGZhy{}message\PYGZhy{}facet\PYGZgt{} ::= (override\PYGZhy{}message **?DEFAULT** \textbar{} \PYGZlt{}message\PYGZhy{}name\PYGZgt{})

\PYGZlt{}handler\PYGZhy{}documentation\PYGZgt{} ::= (message\PYGZhy{}handler \PYGZlt{}name\PYGZgt{} [\PYGZlt{}handler\PYGZhy{}type\PYGZgt{}])

\PYGZlt{}handler\PYGZhy{}type\PYGZgt{} ::= **primary** \textbar{} around \textbar{} before \textbar{} after
\end{sphinxVerbatim}

Redefining an existing class deletes the current subclasses and all
associated message-handlers. An error will occur if instances of the
class or any of its subclasses exist.


\subsection{9.3.1 Multiple Inheritance}
\label{\detokenize{cool:multiple-inheritance}}
If one class inherits from another class, the first class is a
\sphinxstylestrong{subclass} of the second class, and the second class is a
\sphinxstylestrong{superclass} of the first class. Every user-defined class must have at
least one direct superclass, i.e. at least one class must appear in the
\sphinxstyleemphasis{is-a} portion of the defclass. Multiple inheritance occurs when a class
has more than one direct superclass. COOL examines the direct superclass
list for a new class to establish a linear ordering called the \sphinxstylestrong{class
precedence list}. The new class inherits slots and message-handlers
from each of the classes in the class precedence list. The word
precedence implies that slots and message-handlers of a class in the
list override conflicting definitions of another class found later in
the list. A class that comes before another class in the list is said to
be more \sphinxstylestrong{specific}. All class precedence lists will terminate in the
system class OBJECT, and most (if not all) class precedence lists for
user-defined classes will terminate in the system classes USER and
OBJECT. The class precedence list can be listed using the
\sphinxstylestrong{describe-class} function (see section 13.11.1.4).


\subsubsection{9.3.1.1 Multiple Inheritance Rules}
\label{\detokenize{cool:multiple-inheritance-rules}}
COOL uses the inheritance hierarchy of the direct superclasses to
determine the class precedence list for a new class. COOL recursively
applies the following two rules to the direct superclasses:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
A class has higher precedence than any of its superclasses.

\item {} 
A class specifies the precedence between its direct superclasses.

\end{enumerate}

If more than one class precedence list would satisfy these rules, COOL
chooses the one most similar to a strict preorder depth-first traversal.
This heuristic attempts to preserve ?family trees? to the greatest
extent possible. For example, if a child inherited genetic traits from a
mother and father, and the mother and father each inherited traits from
their parents, the child?s class precedence list would be: child mother
maternal-grandmother maternal-grandfather father paternal-grandmother
paternal-grandfather. There are other orderings which would satisfy the
rules (such as child mother father paternal-grandfather
maternal-grandmother paternal-grandmother maternal-grandfather), but
COOL chooses the one which keeps the family trees together as much as
possible.

Example 1

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Class A directly inherits information from the class USER. The class
precedence list for A is: A USER OBJECT.

Example 2

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{B} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Class B directly inherits information from the class USER. The class
precedence list for B is: B USER OBJECT.

Example 3

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{C} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{A} \PYG{n}{B}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Class C directly inherits information from the classes A and B. The
class precedence list for C is: C A B USER OBJECT.

Example 4

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{D} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{B} \PYG{n}{A}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Class D directly inherits information from the classes B and A. The
class precedence list for D is: D B A USER OBJECT.

Example 5

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{E} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{A} \PYG{n}{C}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

By rule \#2, A must precede C. However, C is a subclass of A and cannot
succeed A in a precedence list without violating rule \#1. Thus, this is
an error.

Example 6

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{E} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{C} \PYG{n}{A}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Specifying that E inherits from A is extraneous, since C inherits from
A. However, this definition does not violate any rules and is
acceptable. The class precedence list for E is: E C A B USER OBJECT.

Example 7

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{F} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{C} \PYG{n}{B}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Specifying that F inherits from B is extraneous, since C inherits from
B. The class precedence list for F is: F C A B USER OBJECT. The
superclass list says B must follow C in F?s class precedence list but
\sphinxstyleemphasis{not} that B must \sphinxstyleemphasis{immediately} follow C.

Example 8

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{G} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{C} \PYG{n}{D}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

This is an error, for it violates rule \#2. The class precedence of C
says that A should precede B, but the class precedence list of D says
the opposite.

Example 9

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{H} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{A}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{I} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{B}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{J} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{H} \PYG{n}{I} \PYG{n}{A} \PYG{n}{B}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

The respective class precedence lists of H and I are: \sphinxcode{\sphinxupquote{H A USER OBJECT}}
and \sphinxcode{\sphinxupquote{I B USER OBJECT}}. If J did not have A and B as direct superclasses, J
could have one of three possible class precedence lists: \sphinxcode{\sphinxupquote{J H A I B USER
OBJECT}}, \sphinxcode{\sphinxupquote{J H I A B USER OBJECT}} or \sphinxcode{\sphinxupquote{J H I B A USER OBJECT}}. COOL would
normally pick the first list since it preserves the family trees (H A
and I B) to the greatest extent possible. However, since J inherits
directly from A and B, rule \#2 dictates that the class precedence list
must be \sphinxcode{\sphinxupquote{J H I A B USER OBJECT}}.

Usage Note

For most practical applications of multiple inheritance, the order in
which the superclasses are specified should not matter. If you create a
class using multiple inheritance and the order of the classes specified
in the \sphinxstyleemphasis{is-a} attribute effects the behavior of the class, you should
consider whether your program design is needlessly complex.


\subsection{9.3.2 Class Specifiers}
\label{\detokenize{cool:class-specifiers}}

\subsubsection{9.3.2.1 Abstract and Concrete Classes}
\label{\detokenize{cool:abstract-and-concrete-classes}}
An \sphinxstylestrong{abstract} class is intended for inheritance only, and no direct
instances of this class can be created. A \sphinxstylestrong{concrete} class can have
direct instances. Using the abstract role specifier in a defclass will
cause COOL to generate an error if \sphinxstylestrong{make-instance} is ever called for
this class. If the abstract or concrete descriptor for a class is not
specified, it is determined by inheritance. For the purpose of role
inheritance, system defined classes behave as concrete classes. Thus a
class which inherits from USER will be concrete if no role is specified.


\subsubsection{9.3.2.2 Reactive and Non-Reactive Classes}
\label{\detokenize{cool:reactive-and-non-reactive-classes}}
Objects of a \sphinxstylestrong{reactive} class can match object patterns in a rule.
Objects of a \sphinxstylestrong{non-reactive} class cannot match object patterns in a
rule and are not considered when the list of applicable classes are
determined for an object pattern. An \sphinxstylestrong{abstract} class cannot be
\sphinxstylestrong{reactive}. If the reactive or non-reactive descriptor for a class is
not specified, it is determined by inheritance. For the purpose of
pattern-match inheritance, system defined classes behave as reactive
classes unless the inheriting class is \sphinxstylestrong{abstract}.


\subsection{9.3.3 Slots}
\label{\detokenize{cool:slots}}
Slots are placeholders for values associated with instances of a
user-defined class. Each instance has a copy of the set of slots
specified by the immediate class as well as any obtained from
inheritance. Only available memory limits the number of slots. The name
of a slot may be any symbol with the exception of the keywords \sphinxstyleemphasis{is-a}
and \sphinxstyleemphasis{name} which are reserved for use in object patterns.

To determine the set of slots for an instance, the class precedence list
for the instance?s class is examined in order from most specific to most
general (left to right). A class is more specific than its superclasses.
Slots specified in any of the classes in the class precedence list are
given to the instance, with the exception of no-inherit slots (see
section 9.3.3.5). If a slot is inherited from more than one class, the
definition given by the more specific class takes precedence, with the
exception of composite slots (see section 9.3.3.6).

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{fooA}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{barA}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{B} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{A}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{fooB}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{barB}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

The class precedence list of A is: A USER OBJECT. Instances of A will
have two slots: fooA and barA. The class precedence list of B is: B A
USER OBJECT. Instances of B will have four slots: fooB, barB, fooA and
barA.

Just as slots make up classes, \sphinxstylestrong{facets} make up slots. Facets describe
various features of a slot that hold true for all objects which have the
slot: default value, storage, access, inheritance propagation, source of
other facets, pattern-matching reactivity, visibility to subclass
message-handlers, the automatic creation of message-handlers to access
the slot, the name of the message to send to set the slot and constraint
information. Each object can still have its own value for a slot, with
the exception of shared slots (see section 9.3.3.3).


\subsubsection{9.3.3.1 Slot Field Type}
\label{\detokenize{cool:slot-field-type}}
A slot can hold either a single-field or multifield value. By default, a
slot is single-field. The keyword \sphinxstylestrong{multislot} specifies that a slot
can hold a multifield value comprised of zero or more fields, and the
keywords \sphinxstylestrong{slot} or \sphinxstylestrong{single-slot} specify that the slot can hold one
value. Multifield slot values are stored as multifield values and can be
manipulated with the standard multifield functions, such as \sphinxstylestrong{nth\$} and
\sphinxstylestrong{length\$}, once they are retrieved via messages. COOL also provides
functions for setting multifield slots, such as \sphinxstylestrong{slot-insert\$} (see
section 12.16.4.12.2). Single-field slots are stored as a CLIPS
primitive type, such as integer or string.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass A (is\PYGZhy{}a USER)
  (multislot foo
  (default abc def ghi)))
CLIPS\PYGZgt{} (make\PYGZhy{}instance a of A)
[a]
CLIPS\PYGZgt{} (nth\PYGZdl{} 2 (send [a] get\PYGZhy{}foo))
def
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{9.3.3.2 Default Value Facet}
\label{\detokenize{cool:default-value-facet}}
The \sphinxstylestrong{default} and \sphinxstylestrong{default-dynamic} facets can be used to specify an
initial value given to a slot when an instance of the class is created
or initialized. By default, a slot will have a default value that is
derived from the slot?s constraint facets (see sections 9.3.3.11 and
11.5). Default values are directly assigned to slots without the use of
messages, unlike slot overrides in a \sphinxstylestrong{make-instance} call (see section
9.6.1).

The \sphinxstylestrong{default} facet is a static default: the specified expression is
evaluated once when the class is defined, and the result is stored with
the class. This result is assigned to the appropriate slot when a new
instance is created. If the keyword ?DERIVE is used for the default
value, then a default value is derived from the constraints for the slot
(see section 11.5 for more details). By default, the default attribute
for a slot is (default ?DERIVE). If the keyword ?NONE is used for the
default value, then the slot is not assigned a default value. Using this
keyword causes make-instance to require a slot-override for that slot
when an instance is created. Note that in CLIPS 6.0, a slot now has a
default even if one is not explicitly specified (unlike CLIPS 5.1). This
could cause different behavior for CLIPS 5.1 programs using the
initialize-instance function. The ?NONE keyword can be used to recover
the original behavior for classes.

The \sphinxstylestrong{default-dynamic} facet is a dynamic default: the specified
expression is evaluated every time an instance is created, and the
result is assigned to the appropriate slot.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{setgen} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{l+m+mi}{1}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{foo} \PYG{p}{(}\PYG{n}{default}\PYG{o}{\PYGZhy{}}\PYG{n}{dynamic} \PYG{p}{(}\PYG{n}{gensym}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a1} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a2} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a2}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{]} \PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{foo}\PYG{p}{)}
\PYG{n}{gen1}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{a2}\PYG{p}{]} \PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{foo}\PYG{p}{)}
\PYG{n}{gen2}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{9.3.3.3 Storage Facet}
\label{\detokenize{cool:storage-facet}}
The actual value of an instance?s copy of a slot can either be stored
with the instance or with the class. The \sphinxstylestrong{local} facet specifies that
the value be stored with the instance, and this is the default. The
\sphinxstylestrong{shared} facet specifies that the value be stored with the class. If
the slot value is locally stored, then each instance can have a separate
value for the slot. However, if the slot value is stored with the class,
all instances will have the same value for the slot. Anytime the value
is changed for a shared slot, it will be changed for all instances with
that slot.

A shared slot will always pick up a dynamic default value from a
defclass when an instance is created or initialized, but the shared slot
will ignore a static default value unless it does not currently have a
value. Any changes to a shared slot will cause pattern-matching for
rules to be updated for all reactive instances containing that slot.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{foo} \PYG{p}{(}\PYG{n}{storage} \PYG{n}{shared}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{default} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{bar} \PYG{p}{(}\PYG{n}{storage} \PYG{n}{shared}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{default}\PYG{o}{\PYGZhy{}}\PYG{n}{dynamic} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{woz} \PYG{p}{(}\PYG{n}{storage} \PYG{n}{local}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n+nb}{print}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{p}{(}\PYG{n}{foo} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{bar} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{woz} \PYG{n}{nil}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{foo} \PYG{l+m+mi}{56}\PYG{p}{)}
\PYG{l+m+mi}{56}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{bar} \PYG{l+m+mi}{104}\PYG{p}{)}
\PYG{l+m+mi}{104}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{b} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{n+nb}{print}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{p}{(}\PYG{n}{foo} \PYG{l+m+mi}{56}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{bar} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{woz} \PYG{n}{nil}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{foo} \PYG{l+m+mi}{34}\PYG{p}{)}
\PYG{l+m+mi}{34}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{woz} \PYG{l+m+mi}{68}\PYG{p}{)}
\PYG{l+m+mi}{68}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n+nb}{print}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{p}{(}\PYG{n}{foo} \PYG{l+m+mi}{34}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{bar} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{woz} \PYG{n}{nil}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{n+nb}{print}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{p}{(}\PYG{n}{foo} \PYG{l+m+mi}{34}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{bar} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{woz} \PYG{l+m+mi}{68}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{9.3.3.4 Access Facet}
\label{\detokenize{cool:access-facet}}
There are three types of access facets which can be specified for a
slot: \sphinxstylestrong{read-write}, \sphinxstylestrong{read-only}, and \sphinxstylestrong{initialize-only}. The
\sphinxstylestrong{read-write} facet is the default and says that a slot can be both
written and read. The \sphinxstylestrong{read-only} facet says the slot can only be
read; the only way to set this slot is with default facets in the class
definition. The \sphinxstylestrong{initialize-only} facet is like \sphinxstylestrong{read-only} except
that the slot can also be set by slot overrides in a \sphinxstylestrong{make-instance}
call (see section 9.6.1) and \sphinxstylestrong{init} message-handlers (see section
9.4). These privileges apply to indirect access via messages as well as
direct access within message-handler bodies (see section 9.4). Note: a
\sphinxstylestrong{read-only} slot that has a static default value will implicitly have
the \sphinxstylestrong{shared} storage facet.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass A (is\PYGZhy{}a USER)
  (slot foo (access read\PYGZhy{}write))
  (slot bar (access read\PYGZhy{}only) (default abc))
  (slot woz (access initialize\PYGZhy{}only)))
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler A put\PYGZhy{}bar (?value)
  (dynamic\PYGZhy{}put (sym\PYGZhy{}cat bar) ?value))
CLIPS\PYGZgt{} (make\PYGZhy{}instance a of A (bar 34))
[MSGFUN3] bar slot in [a] of A: write access denied.
[PRCCODE4] Execution halted during the actions of message\PYGZhy{}handler
put\PYGZhy{}bar primary in class A
FALSE
CLIPS\PYGZgt{} (make\PYGZhy{}instance a of A (foo 34) (woz 65))
[a]
CLIPS\PYGZgt{} (send [a] put\PYGZhy{}bar 1)
[MSGFUN3] bar slot in [a] of A: write access denied.
[PRCCODE4] Execution halted during the actions of message\PYGZhy{}handler
put\PYGZhy{}bar primary in class A
FALSE
CLIPS\PYGZgt{} (send [a] put\PYGZhy{}woz 1)
[MSGFUN3] woz slot in [a] of A: write access denied.
[PRCCODE4] Execution halted during the actions of message\PYGZhy{}handler
put\PYGZhy{}bar primary in class A
FALSE
CLIPS\PYGZgt{} (send [a] print)
[a] of A
(foo 34)
(bar abc)
(woz 65)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{9.3.3.5 Inheritance Propagation Facet}
\label{\detokenize{cool:inheritance-propagation-facet}}
An \sphinxstylestrong{inherit} facet says that a slot in a class can be given to
instances of other classes that inherit from the first class. This is
the default. The \sphinxstylestrong{no-inherit} facet says that only direct instances of
this class will get the slot.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{foo} \PYG{p}{(}\PYG{n}{propagation} \PYG{n}{inherit}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{bar} \PYG{p}{(}\PYG{n}{propagation} \PYG{n}{no}\PYG{o}{\PYGZhy{}}\PYG{n}{inherit}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defclass} \PYG{n}{B} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{A}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{b} \PYG{n}{of} \PYG{n}{B}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n+nb}{print}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{p}{(}\PYG{n}{foo} \PYG{n}{nil}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{bar} \PYG{n}{nil}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{n+nb}{print}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{n}{of} \PYG{n}{B}
\PYG{p}{(}\PYG{n}{foo} \PYG{n}{nil}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{9.3.3.6 Source Facet}
\label{\detokenize{cool:source-facet}}
When obtaining slots from the class precedence list during instance
creation, the default behavior is to take the facets from the most
specific class that gives the slot and give default values to any
unspecified facets. This is the behavior specified by the \sphinxstylestrong{exclusive}
facet. The \sphinxstylestrong{composite} facet causes facets which are not explicitly
specified by the most specific class to be taken from the next most
specific class. Thus, in an overlay fashion, the facets of an instance?s
slot can be specified by more than one class. Note that even though
facets may be taken from superclasses, the slot is still considered to
reside in the new class for purposes of visibility (see section
9.3.3.8). One good example of a use of this feature is to pick up a slot
definition and change only its default value for a new derived class.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{multislot} \PYG{n}{foo} \PYG{p}{(}\PYG{n}{access} \PYG{n}{read}\PYG{o}{\PYGZhy{}}\PYG{n}{only}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{default} \PYG{n}{a} \PYG{n}{b} \PYG{n}{c}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{B} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{A}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{foo} \PYG{p}{(}\PYG{n}{source} \PYG{n}{composite}\PYG{p}{)} \PYG{p}{;} \PYG{n}{multiple} \PYG{o+ow}{and} \PYG{n}{read}\PYG{o}{\PYGZhy{}}\PYG{n}{only}
  \PYG{p}{;} \PYG{k+kn}{from} \PYG{n+nn}{class} \PYG{n}{A}
  \PYG{p}{(}\PYG{n}{default} \PYG{n}{d} \PYG{n}{e} \PYG{n}{f}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{describe}\PYG{o}{\PYGZhy{}}\PYG{k}{class} \PYG{n+nc}{B}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
\PYG{n}{Concrete}\PYG{p}{:} \PYG{n}{direct} \PYG{n}{instances} \PYG{n}{of} \PYG{n}{this} \PYG{k}{class} \PYG{n+nc}{can} \PYG{n}{be} \PYG{n}{created}\PYG{o}{.}
\PYG{n}{Reactive}\PYG{p}{:} \PYG{n}{direct} \PYG{n}{instances} \PYG{n}{of} \PYG{n}{this} \PYG{k}{class} \PYG{n+nc}{can} \PYG{n}{match} \PYG{n}{defrule} \PYG{n}{patterns}\PYG{o}{.}
\PYG{n}{Direct} \PYG{n}{Superclasses}\PYG{p}{:} \PYG{n}{A}
\PYG{n}{Inheritance} \PYG{n}{Precedence}\PYG{p}{:} \PYG{n}{B} \PYG{n}{A} \PYG{n}{USER} \PYG{n}{OBJECT}
\PYG{n}{Direct} \PYG{n}{Subclasses}\PYG{p}{:}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{SLOTS} \PYG{p}{:} \PYG{n}{FLD} \PYG{n}{DEF} \PYG{n}{PRP} \PYG{n}{ACC} \PYG{n}{STO} \PYG{n}{MCH} \PYG{n}{SRC} \PYG{n}{VIS} \PYG{n}{CRT} \PYG{n}{OVRD}\PYG{o}{\PYGZhy{}}\PYG{n}{MSG} \PYG{n}{SOURCE}\PYG{p}{(}\PYG{n}{S}\PYG{p}{)}
\PYG{n}{foo} \PYG{p}{:} \PYG{n}{MLT} \PYG{n}{STC} \PYG{n}{INH} \PYG{n}{R} \PYG{n}{SHR} \PYG{n}{RCT} \PYG{n}{CMP} \PYG{n}{PRV} \PYG{n}{R} \PYG{n}{NIL} \PYG{n}{A} \PYG{n}{B}
\PYG{n}{Constraint} \PYG{n}{information} \PYG{k}{for} \PYG{n}{slots}\PYG{p}{:}
\PYG{n}{SLOTS} \PYG{p}{:} \PYG{n}{SYM} \PYG{n}{STR} \PYG{n}{INN} \PYG{n}{INA} \PYG{n}{EXA} \PYG{n}{FTA} \PYG{n}{INT} \PYG{n}{FLT}
\PYG{n}{foo} \PYG{p}{:} \PYG{o}{+} \PYG{o}{+} \PYG{o}{+} \PYG{o}{+} \PYG{o}{+} \PYG{o}{+} \PYG{o}{+} \PYG{o}{+} \PYG{n}{RNG}\PYG{p}{:}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{oo}\PYG{o}{.}\PYG{o}{.}\PYG{o}{+}\PYG{n}{oo}\PYG{p}{]} \PYG{n}{CRD}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{o}{.}\PYG{o}{+}\PYG{n}{oo}\PYG{p}{]}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{Recognized} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{handlers}\PYG{p}{:}
\PYG{n}{init} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{delete} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{create} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n+nb}{print} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{direct}\PYG{o}{\PYGZhy{}}\PYG{n}{modify} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{modify} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{direct}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{foo} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{A}
\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{foo} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{B}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{9.3.3.7 Pattern-Match Reactivity Facet}
\label{\detokenize{cool:pattern-match-reactivity-facet}}
Normally, any change to a slot of an instance will be considered as a
change to the instance for purposes of pattern-matching. However, it is
possible to indicate that changes to a slot of an instance should not
cause pattern-matching. The \sphinxstylestrong{reactive} facet specifies that changes to
a slot trigger pattern-matching, and this is the default. The
\sphinxstylestrong{non-reactive} facet specifies that changes to a slot do not affect
pattern-matching.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass A (is\PYGZhy{}a USER)
  (slot foo (pattern\PYGZhy{}match non\PYGZhy{}reactive)))
CLIPS\PYGZgt{}
(defclass B (is\PYGZhy{}a USER)
  (slot foo))
CLIPS\PYGZgt{}
(defrule Create
  ?ins\PYGZlt{}\PYGZhy{}(object (is\PYGZhy{}a A \textbar{} B))
  =\PYGZgt{}
  (printout t \PYGZdq{}Create \PYGZdq{} (instance\PYGZhy{}name ?ins) crlf))
CLIPS\PYGZgt{}
(defrule Foo\PYGZhy{}Access
  ?ins\PYGZlt{}\PYGZhy{}(object (is\PYGZhy{}a A \textbar{} B) (foo ?))
  =\PYGZgt{}
  (printout t \PYGZdq{}Foo\PYGZhy{}Access \PYGZdq{} (instance\PYGZhy{}name ?ins) crlf))
CLIPS\PYGZgt{} (make\PYGZhy{}instance a of A)
[a]
CLIPS\PYGZgt{} (make\PYGZhy{}instance b of B)
[b]
CLIPS\PYGZgt{} (run)
Create [b]
Foo\PYGZhy{}Access [b]
Create [a]
CLIPS\PYGZgt{} (send [a] put\PYGZhy{}foo 1)
1
CLIPS\PYGZgt{} (send [b] put\PYGZhy{}foo 1)
1
CLIPS\PYGZgt{} (run)
Foo\PYGZhy{}Access [b]
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{9.3.3.8 Visibility Facet}
\label{\detokenize{cool:visibility-facet}}
Normally, only message-handlers attached to the class in which a slot is
defined may directly access the slot. However, it is possible to allow
message-handlers attached to superclasses or subclasses which inherit
the slot to directly access the slot as well. Declaring the
\sphinxstylestrong{visibility} facet to be \sphinxstylestrong{private} specifies that only the
message-handlers of the defining class may directly access the slot, and
this is the default. Declaring the \sphinxstylestrong{visibility} facet to be \sphinxstylestrong{public}
specifies that the message-handlers and subclasses that inherit the slot
and superclasses may also directly access the slot.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass A (is\PYGZhy{}a USER)
  (slot foo (visibility private)))
CLIPS\PYGZgt{}
(defclass B (is\PYGZhy{}a A))
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler B get\PYGZhy{}foo ()
  ?self:foo)
[MSGFUN6] Private slot foo of class A cannot be accessed directly by
handlers attached to class B
[PRCCODE3] Undefined variable self:foo referenced in message\PYGZhy{}handler.
ERROR:
(defmessage\PYGZhy{}handler MAIN::B get\PYGZhy{}foo
()
?self:foo)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{9.3.3.9 Create-Accessor Facet}
\label{\detokenize{cool:create-accessor-facet}}
The \sphinxstylestrong{create-accessor} facet instructs CLIPS to automatically create
\sphinxstyleemphasis{explicit} message-handlers for reading and/or writing a slot. By
default, implicit slot-accessor message-handlers are created for every
slot. While these message-handlers are real message-handlers and can be
manipulated as such, they have no pretty-print form and cannot be
directly modified by the user.

If the value \sphinxstylestrong{?NONE} is specified for the facet, no message-handlers
are created.

If the value \sphinxstylestrong{read} is specified for the facet, CLIPS creates the
following message-handler:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmessage\PYGZhy{}handler \PYGZlt{}class\PYGZgt{} get\PYGZhy{}\PYGZlt{}slot\PYGZhy{}name\PYGZgt{} primary ()
  ?self:\PYGZlt{}slot\PYGZhy{}name\PYGZgt{})
\end{sphinxVerbatim}

If the value \sphinxstylestrong{write} is specified for the facet, CLIPS creates the
following message-handler for single-field slots:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmessage\PYGZhy{}handler \PYGZlt{}class\PYGZgt{} put\PYGZhy{}\PYGZlt{}slot\PYGZhy{}name\PYGZgt{} primary (?value)
  (bind ?self:\PYGZlt{}slot\PYGZhy{}name\PYGZgt{} ?value)
\end{sphinxVerbatim}

or the following message-handler for multifield slots:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmessage\PYGZhy{}handler \PYGZlt{}class\PYGZgt{} put\PYGZhy{}\PYGZlt{}slot\PYGZhy{}name\PYGZgt{} primary (\PYGZdl{}?value)
  (bind ?self:\PYGZlt{}slot\PYGZhy{}name\PYGZgt{} ?value)
\end{sphinxVerbatim}

If the value \sphinxstylestrong{read-write} is specified for the facet, both the get-
and one of the put- message-handlers are created.

If accessors are required that do not use static slot references (see
sections 9.4.2, 9.6.3 and 9.6.4), then user must define them explicitly
with the defmessage-handler construct.

The \sphinxstylestrong{access} facet affects the default value for the
\sphinxstylestrong{create-accessor} facet. If the \sphinxstylestrong{access} facet is \sphinxstylestrong{read-write},
then the default value for the \sphinxstylestrong{create-accessor} facet is
\sphinxstylestrong{read-write}. If the \sphinxstylestrong{access} facet is \sphinxstylestrong{read-only}, then the
default value is \sphinxstylestrong{read}. If the access facet is \sphinxstylestrong{initialize-only},
then the default is \sphinxstylestrong{?NONE}.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{foo} \PYG{p}{(}\PYG{n}{create}\PYG{o}{\PYGZhy{}}\PYG{n}{accessor} \PYG{n}{write}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{bar} \PYG{p}{(}\PYG{n}{create}\PYG{o}{\PYGZhy{}}\PYG{n}{accessor} \PYG{n}{read}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A} \PYG{p}{(}\PYG{n}{foo} \PYG{l+m+mi}{36}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{b} \PYG{n}{of} \PYG{n}{A} \PYG{p}{(}\PYG{n}{bar} \PYG{l+m+mi}{45}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{MSGFUN1}\PYG{p}{]} \PYG{n}{No} \PYG{n}{applicable} \PYG{n}{primary} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{handlers} \PYG{n}{found} \PYG{k}{for} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{bar}\PYG{o}{.}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{9.3.3.10 Override-Message Facet}
\label{\detokenize{cool:override-message-facet}}
There are several COOL support functions that set slots via use of
message-passing, e.g., \sphinxstylestrong{make-instance}, \sphinxstylestrong{initialize-instance},
\sphinxstylestrong{message-modify-instance} and \sphinxstylestrong{message-duplicate-instance}. By
default, all these functions attempt to set a slot with the message
called \sphinxstylestrong{put-\textless{}slot-name\textgreater{}}. However, if the user has elected not to use
standard slot-accessors and wishes these functions to be able to perform
slot-overrides, then the \sphinxstylestrong{override-message} facet can be used to
indicate what message to send instead.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass A (is\PYGZhy{}a USER)
  (slot special (override\PYGZhy{}message special\PYGZhy{}put)))
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler A special\PYGZhy{}put primary (?value)
  (bind ?self:special ?value))
CLIPS\PYGZgt{} (watch messages)
CLIPS\PYGZgt{} (make\PYGZhy{}instance a of A (special 65))
MSG \PYGZgt{}\PYGZgt{} create ED:1 (\PYGZlt{}Instance\PYGZhy{}a\PYGZgt{})
MSG \PYGZlt{}\PYGZlt{} create ED:1 (\PYGZlt{}Instance\PYGZhy{}a\PYGZgt{})
MSG \PYGZgt{}\PYGZgt{} special\PYGZhy{}put ED:1 (\PYGZlt{}Instance\PYGZhy{}a\PYGZgt{} 65)
MSG \PYGZlt{}\PYGZlt{} special\PYGZhy{}put ED:1 (\PYGZlt{}Instance\PYGZhy{}a\PYGZgt{} 65)
MSG \PYGZgt{}\PYGZgt{} init ED:1 (\PYGZlt{}Instance\PYGZhy{}a\PYGZgt{})
MSG \PYGZlt{}\PYGZlt{} init ED:1 (\PYGZlt{}Instance\PYGZhy{}a\PYGZgt{})
[a]
CLIPS\PYGZgt{} (unwatch messages)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{9.3.3.11 Constraint Facets}
\label{\detokenize{cool:constraint-facets}}
The syntax and functionality of single and multifield constraint facets
(attributes) are described in detail in Section 11. Static and dynamic
constraint checking for classes and their instances is supported. Static
checking is performed when constructs or commands that specify slot
information are being parsed. Object patterns used on the LHS of a rule
are also checked to determine if constraint conflicts exist among
variables used in more that one slot. Errors for inappropriate values
are immediately signaled. Static checking is enabled by default. This
behavior can be changed using the \sphinxstylestrong{set-static-constraint-checking}
function. Dynamic checking is also supported. If dynamic checking is
enabled, then new instances have their values checked whenever they are
set (e.g. initialization, slot-overrides, and put- access). This dynamic
checking is disabled by default. This behavior can be changed using the
\sphinxstylestrong{set-dynamic-constraint-checking} function. If an violation occurs
when dynamic checking is being performed, then execution will be halted.

Regardless of whether static or dynamic checking is enabled, multifield
values can never be stored in single-field slots. Single-field values
are converted to a multifield value of length one when storing in a
multifield slot. In addition, the evaluation of a function that has no
return value is always illegal as a slot value.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{multislot} \PYG{n}{foo} \PYG{p}{(}\PYG{n+nb}{type} \PYG{n}{SYMBOL}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{cardinality} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A} \PYG{p}{(}\PYG{n}{foo} \PYG{l+m+mi}{45}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{dynamic}\PYG{o}{\PYGZhy{}}\PYG{n}{constraint}\PYG{o}{\PYGZhy{}}\PYG{n}{checking} \PYG{n}{TRUE}\PYG{p}{)}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A} \PYG{p}{(}\PYG{n}{foo} \PYG{n}{red} \PYG{l+m+mf}{5.0}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{CSTRNCHK1}\PYG{p}{]} \PYG{p}{(}\PYG{n}{red} \PYG{l+m+mf}{5.0}\PYG{p}{)} \PYG{k}{for} \PYG{n}{slot} \PYG{n}{foo} \PYG{n}{of} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n}{found} \PYG{o+ow}{in} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{foo}
\PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{A} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{match} \PYG{n}{the} \PYG{n}{allowed} \PYG{n}{types}\PYG{o}{.}
\PYG{p}{[}\PYG{n}{PRCCODE4}\PYG{p}{]} \PYG{n}{Execution} \PYG{n}{halted} \PYG{n}{during} \PYG{n}{the} \PYG{n}{actions} \PYG{n}{of} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{handler}
\PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{foo} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{A}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A} \PYG{p}{(}\PYG{n}{foo} \PYG{n}{red}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{CSTRNCHK1}\PYG{p}{]} \PYG{p}{(}\PYG{n}{red}\PYG{p}{)} \PYG{k}{for} \PYG{n}{slot} \PYG{n}{foo} \PYG{n}{of} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n}{found} \PYG{o+ow}{in} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{foo} \PYG{n}{primary}
\PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{A} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{satisfy} \PYG{n}{the} \PYG{n}{cardinality} \PYG{n}{restrictions}\PYG{o}{.}
\PYG{p}{[}\PYG{n}{PRCCODE4}\PYG{p}{]} \PYG{n}{Execution} \PYG{n}{halted} \PYG{n}{during} \PYG{n}{the} \PYG{n}{actions} \PYG{n}{of} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{handler}
\PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{foo} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{A}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{9.3.4 Message-handler Documentation}
\label{\detokenize{cool:message-handler-documentation}}
COOL allows the user to forward declare the message-handlers for a class
within the defclass statement. These declarations are for documentation
only and are ignored by CLIPS. The defmessage-handler construct must be
used to actually add message-handlers to a class. Message-handlers can
later be added which are not documented in the defclass.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass rectangle (is\PYGZhy{}a USER)
  (slot side\PYGZhy{}a (default 1))
  (slot side\PYGZhy{}b (default 1))
  (message\PYGZhy{}handler find\PYGZhy{}area))
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler rectangle find\PYGZhy{}area ()
  (* ?self:side\PYGZhy{}a ?self:side\PYGZhy{}b))
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler rectangle print\PYGZhy{}area ()
  (printout t (send ?self find\PYGZhy{}area) crlf))
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\section{9.4 Defmessage-handler Construct}
\label{\detokenize{cool:defmessage-handler-construct}}
Objects are manipulated by sending them messages via the function
\sphinxstylestrong{send}. The result of a message is a useful return-value or
side-effect. A \sphinxstylestrong{defmessage-handler} is a construct for specifying the
behavior of a class of objects in response to a particular message. The
implementation of a message is made up of pieces of procedural code
called message-handlers (or handlers for short). Each class in the class
precedence list of an object?s class can have handlers for a message. In
this way, the object?s class and all its superclasses share the labor of
handling the message. Each class?s handlers handle the part of the
message that is appropriate to that class. Within a class, the handlers
for a particular message can be further subdivided into four types or
categories: \sphinxstylestrong{primary}, \sphinxstylestrong{before}, \sphinxstylestrong{after} and \sphinxstylestrong{around}. The
intended purposes of each type are summarized in the chart below:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Type}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Role for the Class}
\\
\hline
primary
&
Performs the majority of the work for the message
\\
\hline
before
&
Does auxiliary work for a message before the primary handler executes
\\
\hline
after
&
Does auxiliary work for a message after the primary handler executes
\\
\hline
around
&
Sets up an environment for the execution of the rest of the handlers
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Before and after handlers are for side-effects only; their return values
are always ignored. Before handlers execute before the primary ones, and
after message-handlers execute after the primary ones. The return value
of a message is generally given by the primary message-handlers, but
around handlers can also return a value. Around message-handlers allow
the user to wrap code around the rest of the handlers. They begin
execution before the other handlers and pick up again after all the
other message-handlers have finished.

A primary handler provides the part of the message implementation which
is most specific to an object, and thus the primary handler attached to
the class closest to the immediate class of the object overrides other
primary handlers. Before and after handlers provide the ability to pick
up behavior from classes that are more general than the immediate class
of the object, thus the message implementation uses all handlers of this
type from all the classes of an object. When only the roles of the
handlers specify which handlers get executed and in what order, the
message is said to be \sphinxstylestrong{declaratively} implemented. However, some
message implementations may not fit this model well. For example, the
results of more than one primary handler may be needed. In cases like
this, the handlers themselves must take part in deciding which handlers
get executed and in what order. This is called the \sphinxstylestrong{imperative}
technique. Around handlers provide imperative control over all other
types of handlers except more specific around handlers. Around handlers
can change the environment in which other handlers execute and modify
the return value for the entire message. A message implementation should
use the declarative technique if at all possible because this allows the
handlers to be more independent and modular.

A defmessage-handler is comprised of seven elements: 1) a class name to
which to attach the handler (the class must have been previously
defined), 2) a message name to which the handler will respond, 3) an
optional type (the default is primary), 4) an optional comment, 5) a
list of parameters that will be passed to the handler during execution,
6) an optional wildcard parameter and 7) a series of expressions which
are executed in order when the handler is called. The return-value of a
message-handler is the evaluation of the last expression in the body.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Defaults} \PYG{n}{are} \PYG{o+ow}{in} \PYG{o}{*}\PYG{o}{*}\PYG{n}{xxxx}\PYG{o}{*}\PYG{o}{*}\PYG{o}{.}

\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}
  \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{handler}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{type}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{comment}\PYG{o}{\PYGZgt{}}\PYG{p}{]}
  \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}\PYG{o}{*} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{wildcard}\PYG{o}{\PYGZhy{}}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
  \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}

\PYG{o}{\PYGZlt{}}\PYG{n}{handler}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{type}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{n}{around} \PYG{o}{\textbar{}} \PYG{n}{before} \PYG{o}{\textbar{}} \PYG{o}{*}\PYG{o}{*}\PYG{n}{primary}\PYG{o}{*}\PYG{o}{*} \PYG{o}{\textbar{}} \PYG{n}{after}

\PYG{o}{\PYGZlt{}}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{single}\PYG{o}{\PYGZhy{}}\PYG{n}{field}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{wildcard}\PYG{o}{\PYGZhy{}}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{multifield}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Message-handlers are uniquely identified by class, name and type.
Message-handlers are never called directly. When the user sends a
message to an object, CLIPS selects and orders the applicable
message-handlers attached to the object?s class(es) and then executes
them. This process is termed the \sphinxstylestrong{message dispatch}.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{A} \PYG{n}{delete} \PYG{n}{before} \PYG{p}{(}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Deleting an instance of the class A...}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{crlf}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{USER} \PYG{n}{delete} \PYG{n}{after} \PYG{p}{(}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{System completed deletion of an instance.}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{crlf}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{watch} \PYG{n}{instances}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n}{delete}\PYG{p}{)}
\PYG{n}{Deleting} \PYG{n}{an} \PYG{n}{instance} \PYG{n}{of} \PYG{n}{the} \PYG{k}{class} \PYG{n+nc}{A}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{o}{==} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{n}{System} \PYG{n}{completed} \PYG{n}{deletion} \PYG{n}{of} \PYG{n}{an} \PYG{n}{instance}\PYG{o}{.}
\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{unwatch} \PYG{n}{instances}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{9.4.1 Message-handler Parameters}
\label{\detokenize{cool:message-handler-parameters}}
A message-handler may accept \sphinxstyleemphasis{exactly} or \sphinxstyleemphasis{at least} a specified number
of arguments, depending on whether a wildcard parameter is used or not.
The regular parameters specify the minimum number of arguments that must
be passed to the handler. Each of these parameters may be referenced
like a normal single-field variable within the actions of the handler.
If a wildcard parameter is present, the handler may be passed any number
of arguments greater than or equal to the minimum. If no wildcard
parameter is present, then the handler must be passed exactly the number
of arguments specified by the regular parameters. All arguments to a
handler that do not correspond to a regular parameter are grouped into a
multifield value that can be referenced by the wildcard parameter. The
standard CLIPS multifield functions, such as \sphinxstylestrong{length\$} and
\sphinxstylestrong{expand\$}, can be applied to the wildcard parameter.

Handler parameters have no bearing on the applicability of a handler to
a particular message (see section 9.5.1). However, if the number of
arguments is inappropriate, a message execution error (see section
9.5.4) will be generated when the handler is called. Thus, the number of
arguments accepted should be consistent for all message-handlers
applicable to a particular message.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass CAR (is\PYGZhy{}a USER)
  (slot front\PYGZhy{}seat)
  (multislot trunk)
  (slot trunk\PYGZhy{}count))
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler CAR put\PYGZhy{}items\PYGZhy{}in\PYGZhy{}car (?item \PYGZdl{}?rest)
  (bind ?self:front\PYGZhy{}seat ?item)
  (bind ?self:trunk ?rest)
  (bind ?self:trunk\PYGZhy{}count (length\PYGZdl{} ?rest)))
CLIPS\PYGZgt{} (make\PYGZhy{}instance Pinto of CAR)
[Pinto]
CLIPS\PYGZgt{} (send [Pinto] put\PYGZhy{}items\PYGZhy{}in\PYGZhy{}car bag\PYGZhy{}of\PYGZhy{}groceries tire suitcase)
2
CLIPS\PYGZgt{} (send [Pinto] print)
[Pinto] of CAR
(front\PYGZhy{}seat bag\PYGZhy{}of\PYGZhy{}groceries)
(trunk tire suitcase)
(trunk\PYGZhy{}count 2)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{9.4.1.1 Active Instance Parameter}
\label{\detokenize{cool:active-instance-parameter}}
The term \sphinxstylestrong{active instance} refers to an instance that is responding to
a message. All message-handlers have an implicit parameter called
\sphinxstylestrong{?self} which binds the active instance for a message. This parameter
name is reserved and cannot be explicitly listed in the
message-handler?s parameters, nor can it be rebound within the body of a
message-handler.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{} (defclass A (is\PYGZhy{}a USER))
CLIPS\PYGZgt{} (make\PYGZhy{}instance a of A)
[a]
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler A print\PYGZhy{}args (?a ?b \PYGZdl{}?c)
  (printout t (instance\PYGZhy{}name ?self) \PYGZdq{} \PYGZdq{} ?a \PYGZdq{} \PYGZdq{} ?b
   \PYGZdq{} and \PYGZdq{} (length\PYGZdl{} ?c) \PYGZdq{} extras: \PYGZdq{} ?c crlf))
CLIPS\PYGZgt{} (send [a] print\PYGZhy{}args 1 2)
[a] 1 2 and 0 extras: ()
CLIPS\PYGZgt{} (send [a] print\PYGZhy{}args a b c d)
[a] a b and 2 extras: (c d)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{9.4.2 Message-handler Actions}
\label{\detokenize{cool:message-handler-actions}}
The body of a message-handler is a sequence of expressions that are
executed in order when the handler is called. The return value of the
message-handler is the result of the evaluation of the last expression
in the body.

Handler actions may \sphinxstyleemphasis{directly} manipulate slots of the active instance.
Normally, slots can only be manipulated by sending the object
slot-accessor messages (see sections 9.3.3.9 and 9.4.3). However,
handlers are considered part of the encapsulation (see section 2.6.2) of
an object, and thus can directly view and change the slots of the
object. There are several functions which operate implicitly on the
active instance (without the use of messages) and can only be called
from within a message-handler. These functions are discussed in section
12.16.

A shorthand notation is provided for accessing slots of the active
instance from within a message-handler.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
?self:\PYGZlt{}slot\PYGZhy{}name\PYGZgt{}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass A (is\PYGZhy{}a USER)
  (slot foo (default 1))
  (slot bar (default 2)))
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler A print\PYGZhy{}all\PYGZhy{}slots ()
  (printout t ?self:foo \PYGZdq{} \PYGZdq{} ?self:bar crlf))
CLIPS\PYGZgt{} (make\PYGZhy{}instance a of A)
[a]
CLIPS\PYGZgt{} (send [a] print\PYGZhy{}all\PYGZhy{}slots)
1 2
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

The \sphinxstylestrong{bind} function can also take advantage of this shorthand notation
to set the value of a slot.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(bind ?self:\PYGZlt{}slot\PYGZhy{}name\PYGZgt{} \PYGZlt{}value\PYGZgt{}*)
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler A set\PYGZhy{}foo (?value)
(bind ?self:foo ?value))

CLIPS\PYGZgt{} (send [a] set\PYGZhy{}foo 34)
34
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

Direct slot accesses are statically bound to the appropriate slot in the
defclass when the message-handler is defined. Care must be taken when
these direct slot accesses can be executed as the result of a message
sent to an instance of a subclass of the class to which the
message-handler is attached. If the subclass has redefined the slot, the
direct slot access contained in the message-handler attached to the
superclass will fail. That message-handler accesses the slot in the
superclass, not the subclass.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass A (is\PYGZhy{}a USER)
  (slot foo (create\PYGZhy{}accessor read)))
CLIPS\PYGZgt{}
(defclass B (is\PYGZhy{}a A)
  (slot foo (create\PYGZhy{}accessor ?NONE)))
CLIPS\PYGZgt{} (make\PYGZhy{}instance b of B)
[b]
CLIPS\PYGZgt{} (send [b] get\PYGZhy{}foo)
[MSGPASS3] Static reference to slot foo of class A does not apply to [b]
of B
[PRCCODE4] Execution halted during the actions of message\PYGZhy{}handler
get\PYGZhy{}foo primary in class A
FALSE
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

In order for direct slot accesses in a superclass message-handler to
apply to new versions of the slot in subclasses, the dynamic-put and
dynamic-get (see sections 12.16.4.10 and 12.16.4.11) must be used.
However, the subclass slot must have public visibility for this to work
(see section 9.3.3.8).

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass A (is\PYGZhy{}a USER)
  (slot foo (create\PYGZhy{}accessor ?NONE)))
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler A get\PYGZhy{}foo ()
  (dynamic\PYGZhy{}get foo))
CLIPS\PYGZgt{}
(defclass B (is\PYGZhy{}a A)
  (role concrete)
  (slot foo (visibility public)))
CLIPS\PYGZgt{} (make\PYGZhy{}instance b of B)
[b]
CLIPS\PYGZgt{} (send [b] get\PYGZhy{}foo)
nil
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{9.4.3 Daemons}
\label{\detokenize{cool:daemons}}
Daemons are pieces of code which execute implicitly whenever some basic
action is taken upon an instance, such as initialization, deletion, or
reading and writing of slots. All these basic actions are implemented
with primary handlers attached to the class of the instance. Daemons may
be easily implemented by defining other types of message-handlers, such
as before or after, which will recognize the same messages. These pieces
of code will then be executed whenever the basic actions are performed
on the instance.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{A} \PYG{n}{init} \PYG{n}{before} \PYG{p}{(}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Initializing a new instance of class A...}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{crlf}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{n}{Initializing} \PYG{n}{a} \PYG{n}{new} \PYG{n}{instance} \PYG{n}{of} \PYG{k}{class} \PYG{n+nc}{A}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{9.4.4 Predefined System Message-handlers}
\label{\detokenize{cool:predefined-system-message-handlers}}
CLIPS defines eight primary message-handlers that are attached to the
class USER. These handlers cannot be deleted or modified.


\subsubsection{9.4.4.1 Instance Initialization}
\label{\detokenize{cool:instance-initialization}}
\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{USER} \PYG{n}{init} \PYG{n}{primary} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

This handler is responsible for initializing instances with class
default values after creation. The \sphinxstylestrong{make-instance} and
\sphinxstylestrong{initialize-instance} functions send the \sphinxstylestrong{init} message to an
instance (see sections 9.6.1 and 9.6.2); the user should never send this
message directly. This handler is implemented using the \sphinxstylestrong{init-slots}
function (see section 12.13). User-defined \sphinxstylestrong{init} handlers should not
prevent the system message-handler from responding to an \sphinxstylestrong{init}
message (see section 9.5.3).

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{CAR} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{price} \PYG{p}{(}\PYG{n}{default} \PYG{l+m+mi}{75000}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{model} \PYG{p}{(}\PYG{n}{default} \PYG{n}{Corniche}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{watch} \PYG{n}{messages}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{watch} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{handlers}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce} \PYG{n}{of} \PYG{n}{CAR}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{create} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{create} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{create} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{create} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{init} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{init} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{init} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{init} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{9.4.4.2 Instance Deletion}
\label{\detokenize{cool:instance-deletion}}
\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{USER} \PYG{n}{delete} \PYG{n}{primary} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

This handler is responsible for deleting an instance from the system.
The user must directly send a \sphinxstylestrong{delete} message to an instance.
User-defined \sphinxstylestrong{delete} message-handlers should not prevent the system
message-handler from responding to a \sphinxstylestrong{delete} message (see section
9.5.3). The handler returns the symbol TRUE if the instance was
successfully deleted, otherwise it returns the symbol FALSE.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{p}{]} \PYG{n}{delete}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{delete} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{delete} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{delete} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Stale} \PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{delete} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Stale} \PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{9.4.4.3 Instance Display}
\label{\detokenize{cool:instance-display}}
\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{USER} \PYG{n+nb}{print} \PYG{n}{primary} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

This handler prints out slots and their values for an instance.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce} \PYG{n}{of} \PYG{n}{CAR}\PYG{p}{)}

    \PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{create} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
    \PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{create} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
    \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
    \PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{create} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
    \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
    \PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{create} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
    \PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{init} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
    \PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{init} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
    \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
    \PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{init} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
    \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
    \PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{init} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
    \PYG{p}{[}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{p}{]}
    \PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{p}{]} \PYG{n+nb}{print}\PYG{p}{)}
    \PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n+nb}{print} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
    \PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n+nb}{print} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
    \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
    \PYG{p}{[}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{p}{]} \PYG{n}{of} \PYG{n}{CAR}
    \PYG{p}{(}\PYG{n}{price} \PYG{l+m+mi}{75000}\PYG{p}{)}
    \PYG{p}{(}\PYG{n}{model} \PYG{n}{Corniche}\PYG{p}{)}
    \PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n+nb}{print} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
    \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
    \PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n+nb}{print} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{Rolls}\PYG{o}{\PYGZhy{}}\PYG{n}{Royce}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
    \PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{unwatch} \PYG{n}{messages}\PYG{p}{)}
    \PYG{n}{CLIPS}\PYG{o}{.} \PYG{p}{(}\PYG{n}{unwatch} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{handlers}\PYG{p}{)}
    \PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{9.4.4.4 Directly Modifying an Instance}
\label{\detokenize{cool:directly-modifying-an-instance}}
\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmessage\PYGZhy{}handler USER direct\PYGZhy{}modify primary
  (?slot\PYGZhy{}override\PYGZhy{}expressions))
\end{sphinxVerbatim}

This handler modifies the slots of an instance directly rather than
using put- override messages to place the slot values. The slot-override
expressions are passed as an EXTERNAL\_ADDRESS data object to the
direct-modify handler. This message is used by the functions
\sphinxstylestrong{modify-instance} and \sphinxstylestrong{active-modify-instance}.

Example

The following around message-handler could be used to insure that all
modify message slot-overrides are handled using put- messages.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmessage\PYGZhy{}handler USER direct\PYGZhy{}modify around (?overrides)
  (send ?self message\PYGZhy{}modify ?overrides))
\end{sphinxVerbatim}


\subsubsection{9.4.4.5 Modifying an Instance using Messages}
\label{\detokenize{cool:modifying-an-instance-using-messages}}
\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmessage\PYGZhy{}handler USER message\PYGZhy{}modify primary
  (?slot\PYGZhy{}override\PYGZhy{}expressions)
\end{sphinxVerbatim}

This handler modifies the slots of an instance using put- messages for
each slot update. The slot-override expressions are passed as an
EXTERNAL\_ADDRESS data object to the message-modify handler. This message
is used by the functions \sphinxstylestrong{message-modify-instance} and
\sphinxstylestrong{active-message-modify-instance}.


\subsubsection{9.4.4.6 Directly Duplicating an Instance}
\label{\detokenize{cool:directly-duplicating-an-instance}}
\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmessage\PYGZhy{}handler USER direct\PYGZhy{}duplicate primary
  (?new\PYGZhy{}instance\PYGZhy{}name ?slot\PYGZhy{}override\PYGZhy{}expressions))
\end{sphinxVerbatim}

This handler duplicates an instance without using put- messages to
assign the slot-overrides. Slot values from the original instance and
slot overrides are directly copied. If the name of the new instance
created matches a currently existing instance-name, then the currently
existing instance is deleted without use of a message. The slot-override
expressions are passed as an EXTERNAL\_ADDRESS data object to the
direct-duplicate handler. This message is used by the functions
\sphinxstylestrong{duplicate-instance} and \sphinxstylestrong{active-duplicate-instance}.

Example

The following around message-handler could be used to insure that all
duplicate message slot-overrides are handled using put- messages.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmessage\PYGZhy{}handler USER direct\PYGZhy{}duplicate around (?new\PYGZhy{}name ?overrides)
  (send ?self message\PYGZhy{}duplicate ?new\PYGZhy{}name ?overrides))
\end{sphinxVerbatim}


\subsubsection{9.4.4.7 Duplicating an Instance using Messages}
\label{\detokenize{cool:duplicating-an-instance-using-messages}}
\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmessage\PYGZhy{}handler USER message\PYGZhy{}duplicate primary
  (?new\PYGZhy{}instance\PYGZhy{}name ?slot\PYGZhy{}override\PYGZhy{}expressions)
\end{sphinxVerbatim}

This handler duplicates an instance using messages. Slot values from the
original instance and slot overrides are copied using put- and get-
messages. If the name of the new instance created matches a currently
existing instance-name, then the currently existing instance is deleted
using a delete message. After creation, the new instance is sent a
create message and then an init message. The slot-override expressions
are passed as an EXTERNAL\_ADDRESS data object to the message-duplicate
handler. This message is used by the functions
\sphinxstylestrong{message-duplicate-instance} and
\sphinxstylestrong{active-message-duplicate-instance}.


\subsubsection{9.4.4.8 Instance Creation}
\label{\detokenize{cool:instance-creation}}
\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{USER} \PYG{n}{create} \PYG{n}{primary} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

This handler is called after an instance is created , but before any
slot initialization has occurred. The newly created instance is sent a
\sphinxstylestrong{create} message. This handler performs no actions?It is provided so
that instance creation can be detected by user-defined message-handlers.
The handler returns the symbol TRUE if the instance was successfully
created, otherwise it returns the symbol FALSE.


\section{9.5 Message Dispatch}
\label{\detokenize{cool:message-dispatch}}
When a message is sent to an object using the \sphinxstylestrong{send} function, CLIPS
examines the class precedence list of the active instance?s class to
determine a complete set of message-handlers which are applicable to the
message. CLIPS uses the roles (around, before, primary or after) and
specificity of these message-handlers to establish an ordering and then
executes them. A handler that is attached to a subclass of another
message-handler?s class is said to be more specific. This entire process
is referred to as the \sphinxstylestrong{message dispatch}. Following is a flow diagram
summary:

{\color{red}\bfseries{}\textbar{}image3\textbar{}}

The solid arrows indicate automatic control transfer by the message
dispatch system. The dashed arrows indicate control transfer that can
only be accomplished by the use or lack of the use of
\sphinxstylestrong{call-next-handler} (or \sphinxstylestrong{override-next-handler}).


\subsection{9.5.1 Applicability of Message-handlers}
\label{\detokenize{cool:applicability-of-message-handlers}}
A message-handler is applicable to a message if its name matches the
message, and it is attached to a class which is in the class precedence
list of the class of the instance receiving the message.


\subsection{9.5.2 Message-handler Precedence}
\label{\detokenize{cool:message-handler-precedence}}
The set of all applicable message-handlers are sorted into four groups
according to role, and these four groups are further sorted by class
specificity. The around, before and primary handlers are ordered from
most specific to most general, whereas after handlers are ordered from
most general to most specific.

The order of execution is as follows: 1) around handlers begin execution
from most specific to most general (each around handler must explicitly
allow execution of other handlers), 2) before handlers execute (one
after the other) from most specific to most general 3) primary handlers
begin execution from most specific to most general (more specific
primary handlers must explicitly allow execution of more general ones),
4) primary handlers finish execution from most general to most specific,
5) after handlers execute (one after the other) from most general to
most specific and 6) around handlers finish execution from most general
to most specific.

There must be at least one applicable primary handler for a message, or
a message execution error will be generated (see section 9.5.4).


\subsection{9.5.3 Shadowed Message-handlers}
\label{\detokenize{cool:shadowed-message-handlers}}
When one handler must be called by another handler in order to be
executed, the first handler is said to be \sphinxstylestrong{shadowed} by the second. An
around handler shadows all handlers except more specific around
handlers. A primary handler shadows all more general primary handlers.

Messages should be implemented using the declarative technique, if
possible. Only the handler roles will dictate which handlers get
executed; only before and after handlers and the most specific primary
handler are used. This allows each handler for a message to be
completely independent of the other message-handlers. However, if around
handlers or shadowed primary handlers are necessary, then the handlers
must explicitly take part in the message dispatch by calling other
handlers they are shadowing. This is called the imperative technique.
The functions \sphinxstylestrong{call-next-handler} and \sphinxstylestrong{override-next-handler} (see
section 12.16.2) allow a handler to execute the handler it is shadowing.
A handler can call the same shadowed handler multiple times.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{USER} \PYG{n}{my}\PYG{o}{\PYGZhy{}}\PYG{n}{message} \PYG{n}{around} \PYG{p}{(}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{call}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{next}\PYG{o}{\PYGZhy{}}\PYG{n}{handler}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{USER} \PYG{n}{my}\PYG{o}{\PYGZhy{}}\PYG{n}{message} \PYG{n}{before} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{USER} \PYG{n}{my}\PYG{o}{\PYGZhy{}}\PYG{n}{message} \PYG{p}{(}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{call}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{next}\PYG{o}{\PYGZhy{}}\PYG{n}{handler}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{USER} \PYG{n}{my}\PYG{o}{\PYGZhy{}}\PYG{n}{message} \PYG{n}{after} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{OBJECT} \PYG{n}{my}\PYG{o}{\PYGZhy{}}\PYG{n}{message} \PYG{n}{around} \PYG{p}{(}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{call}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{next}\PYG{o}{\PYGZhy{}}\PYG{n}{handler}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{OBJECT} \PYG{n}{my}\PYG{o}{\PYGZhy{}}\PYG{n}{message} \PYG{n}{before} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{OBJECT} \PYG{n}{my}\PYG{o}{\PYGZhy{}}\PYG{n}{message} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{n}{OBJECT} \PYG{n}{my}\PYG{o}{\PYGZhy{}}\PYG{n}{message} \PYG{n}{after} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

For a message sent to an instance of a class which inherits from USER,
the following diagram illustrates the order of execution for the
handlers attached to the classes USER and OBJECT. The brackets indicate
where a particular handler begins and ends execution. Handlers enclosed
within a bracket are shadowed.

{\color{red}\bfseries{}\textbar{}image4\textbar{}}


\subsection{9.5.4 Message Execution Errors}
\label{\detokenize{cool:message-execution-errors}}
If an error occurs at any time during the execution of a
message-handler, any currently executing handlers will be aborted, any
handlers which have not yet started execution will be ignored, and the
\sphinxstylestrong{send} function will return the symbol FALSE.

A lack of applicable of primary message-handlers and a handler being
called with the wrong number of arguments are common message execution
errors.


\subsection{9.5.5 Message Return Value}
\label{\detokenize{cool:message-return-value}}
The return value of call to the \sphinxstylestrong{send} function is the return value of
the most specific around handler, or the most specific primary handler
if there are no around handlers. The return value of a handler is the
result of the evaluation of the last action in the handler.

The return values of the before and after handlers are ignored; they are
for side-effects only. An around handler can choose to ignore or capture
the return value of the next most specific around or primary handler. A
primary handler can choose to ignore or capture the return value of a
more general primary handler.


\section{9.6 Manipulating Instances}
\label{\detokenize{cool:manipulating-instances}}
Objects are manipulated by sending them messages. This is achieved by
using the \sphinxstylestrong{send} function, which takes as arguments the destination
object for the message, the message itself and any arguments which are
to be passed to handlers.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{send} \PYG{o}{\PYGZlt{}}\PYG{n+nb}{object}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Section 2.4.2 explains object references. The return value of \sphinxstylestrong{send}
is the result of the message as explained in section 9.5.5.

The slots of an object may be read or set directly only within the body
of a message-handler that is executing on behalf of a message that was
sent to that object. This is how COOL implements the notion of
encapsulation (see Section 2.6.2). Any action performed on an object by
an external source, such as a rule or function, must be done with
messages. There are two major exceptions: 1) objects which are not
instances of user-defined classes (floating-point and integer numbers,
symbols, strings, multifield values, fact-addresses and
external-addresses) can be manipulated in the standard non-OOP manner of
previous versions of CLIPS as well and 2) creation and initialization of
an instance of a user-defined class are performed via the function
\sphinxstylestrong{make-instance}.


\subsection{9.6.1 Creating Instances}
\label{\detokenize{cool:creating-instances}}
Like facts, instances of user-defined classes must be explicitly created
by the user. Likewise, all instances are deleted during the \sphinxstylestrong{reset}
command, and they can be loaded and saved similarly to facts. All
operations involving instances require message-passing using the
\sphinxstylestrong{send} function except for creation, since the object does not yet
exist. A function called \sphinxstylestrong{make-instance} is used to create and
initialize a new instance. This function implicitly sends first a create
message and then an initialization message to the new object after
allocation. The user can customize instance initialization with daemons.
\sphinxstylestrong{make-instance} also allows slot-overrides to change any predefined
initialization for a particular instance. \sphinxstylestrong{make-instance}
automatically delays all object pattern-matching activities for rules
until all slot overrides have been processed. The function
\sphinxstylestrong{active-make-instance} can be used if delayed pattern-matching is not
desired. \sphinxstylestrong{active-make-instance} remembers the current state of delayed
pattern-matching, explicitly turns delay on, and then restores it to its
previous state once all slot overrides have been processed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{definition}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{active}\PYG{o}{\PYGZhy{}}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{definition}\PYG{o}{\PYGZgt{}}\PYG{p}{)}

\PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{definition}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{n}{of}
  \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{override}\PYG{o}{\PYGZgt{}}\PYG{o}{*}

\PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{override}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

The return value of \sphinxstylestrong{make-instance} is the name of the new instance on
success or the symbol FALSE on failure. The evaluation of
\textless{}instance-name-expression\textgreater{} can either be an instance-name or a symbol.
If \textless{}instance-name-expression\textgreater{} is not specified, then the function
\sphinxstylestrong{gensym*} will be called to generate the instance-name.

The \sphinxstylestrong{make-instance} function performs the following steps in order:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
If an instance of the specified name already exists, that instance
receives a \sphinxstylestrong{delete} message, e.g. (send \textless{}instance-name\textgreater{} delete). If
this fails for any reason, the new instance creation is aborted.
Normally, the handler attached to class USER will respond to this
message (see section 9.4.5.2).

\item {} 
A new and uninitialized instance of the specified class is created
with the specified name.

\item {} 
The new instance receives the \sphinxstylestrong{create} message, e.g. (send
\textless{}instance-name\textgreater{} create). Normally, the handler attached to class USER
will respond to this message (see section 9.4.4.8), although it
performs no actions.

\item {} 
All slot-overrides are immediately evaluated and placed via \sphinxstylestrong{put-}
messages (see section 9.3.3.10), e.g. (send \textless{}instance-name\textgreater{}
put-\textless{}slot-name\textgreater{} \textless{}expression\textgreater{}*). If there are any errors, the new
instance is deleted.

\item {} 
The new instance receives the \sphinxstylestrong{init} message, e.g. (send
\textless{}instance-name\textgreater{} init). Normally, the handler attached to class USER will
respond to this message (see section 9.4.4.1). This handler calls the
\sphinxstylestrong{init-slots} function (see section 12.16.4.1). This function uses
defaults from the class definition (if any) for any slots which do not
have slot-overrides. The class defaults are placed directly without the
use of messages. If there are any errors, the new instance is deleted.

\end{enumerate}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass A (is\PYGZhy{}a USER)
  (slot x (default 34))
  (slot y (default abc)))
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler A put\PYGZhy{}x before (?value)
  (printout t \PYGZdq{}Slot x set with message.\PYGZdq{} crlf))
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler A delete after ()
  (printout t \PYGZdq{}Old instance deleted.\PYGZdq{} crlf))
CLIPS\PYGZgt{} (make\PYGZhy{}instance a of A)
[a]
CLIPS\PYGZgt{} (send [a] print)
[a] of A
(x 34)
(y abc)
CLIPS\PYGZgt{} (make\PYGZhy{}instance [a] of A (x 65))
Old instance deleted.
Slot x set with message.
[a]
CLIPS\PYGZgt{} (send [a] print)
a of A
(x 65)
(y abc)
CLIPS\PYGZgt{} (send [a] delete)
Old instance deleted.
TRUE
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{9.6.1.1 Definstances Construct}
\label{\detokenize{cool:definstances-construct}}
Similar to deffacts, the \sphinxstylestrong{definstances} construct allows the
specification of instances which will be created every time the
\sphinxstylestrong{reset} command is executed. On every reset all current instances
receive a \sphinxstylestrong{delete} message, and the equivalent of a \sphinxstylestrong{make-instance}
function call is made for every instance specified in definstances
constructs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{definstances} \PYG{o}{\PYGZlt{}}\PYG{n}{definstances}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{active}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{comment}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}

\PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{definition}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

A definstances cannot use classes that have not been previously defined.
The instances of a definstances are created in order, and if any
individual creation fails, the remainder of the definstances will be
aborted. Normally, definstances just use the \sphinxstylestrong{make-instance} function
(which means delayed Rete activity) to create the instances. However, if
this is not desired, then the \sphinxstyleemphasis{active} keyword can be specified after
the definstances name so that the \sphinxstylestrong{active-make-instance} function will
be used.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{x} \PYG{p}{(}\PYG{n}{default} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{definstances} \PYG{n}{A}\PYG{o}{\PYGZhy{}}\PYG{n}{OBJECTS}
  \PYG{p}{(}\PYG{n}{a1} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{of} \PYG{n}{A} \PYG{p}{(}\PYG{n}{x} \PYG{l+m+mi}{65}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{watch} \PYG{n}{instances}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{reset}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{o}{==} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{object}\PYG{p}{]} \PYG{n}{of} \PYG{n}{INITIAL}\PYG{o}{\PYGZhy{}}\PYG{n}{OBJECT}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{object}\PYG{p}{]} \PYG{n}{of} \PYG{n}{INITIAL}\PYG{o}{\PYGZhy{}}\PYG{n}{OBJECT}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{gen1}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{reset}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{o}{==} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{object}\PYG{p}{]} \PYG{n}{of} \PYG{n}{INITIAL}\PYG{o}{\PYGZhy{}}\PYG{n}{OBJECT}
\PYG{o}{\PYGZlt{}}\PYG{o}{==} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{o}{\PYGZlt{}}\PYG{o}{==} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{gen1}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{object}\PYG{p}{]} \PYG{n}{of} \PYG{n}{INITIAL}\PYG{o}{\PYGZhy{}}\PYG{n}{OBJECT}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{gen2}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{unwatch} \PYG{n}{instances}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Upon startup and after a \sphinxstylestrong{clear} command, CLIPS automatically
constructs the following definstances.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{definstances} \PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{object} \PYG{p}{(}\PYG{n}{initial}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{object} \PYG{n}{of} \PYG{n}{INITIAL}\PYG{o}{\PYGZhy{}}\PYG{n}{OBJECT}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

The class INITIAL-OBJECT is a predefined system class that is a direct
subclass of USER.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{INITIAL}\PYG{o}{\PYGZhy{}}\PYG{n}{OBJECT} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{role} \PYG{n}{concrete}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{pattern}\PYG{o}{\PYGZhy{}}\PYG{n}{match} \PYG{n}{reactive}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

The initial-object definstances and the INITIAL-OBJECT class are only
defined if both the object system and defrules are enabled (see section
2 of the \sphinxstyleemphasis{Advanced Programming Guide}). The INITIAL-OBJECT class cannot
be deleted, but the \sphinxstyleemphasis{initial-object} definstances can. See section 5.4.9
for details on default patterns which pattern-match against the
\sphinxstyleemphasis{initial-object} instance.


\subsection{9.6.2 Reinitializing Existing Instances}
\label{\detokenize{cool:reinitializing-existing-instances}}
The \sphinxstylestrong{initialize-instance} function provides the ability to
reinitialize an existing instance with class defaults and new
slot-overrides. The return value of \sphinxstylestrong{initialize-instance} is the name
of the instance on success or the symbol FALSE on failure. The
evaluation of \textless{}instance-name-expression\textgreater{} can either be an instance-name,
instance-address or a symbol. \sphinxstylestrong{initialize-instance} automatically
delays all object pattern-matching activities for rules until all slot
overrides have been processed. The function
\sphinxstylestrong{active-initialize-instance} can be used if delayed pattern-matching
is not desired.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{initialize}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{override}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

The \sphinxstylestrong{initialize-instance} function performs the following steps in
order:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
All slot-overrides are immediately evaluated and placed via \sphinxstylestrong{put-}
messages (see section 9.3.3.10), e.g. (send \textless{}instance-name\textgreater{}
put-\textless{}slot-name\textgreater{} \textless{}expression\textgreater{}*).

\item {} 
The instance receives the \sphinxstylestrong{init} message, e.g. (send
\textless{}instance-name\textgreater{} init). Normally, the handler attached to class USER will
respond to this message (see section 9.4.5.1). This handler calls the
\sphinxstylestrong{init-slots} function (see section 12.16.4.1). This function uses
defaults from the class definition (if any) for any slots that do not
have slot-overrides. The class defaults are placed directly without the
use of messages.

\end{enumerate}

If no slot-override or class default specifies the value of a slot, that
value will remain the same. Empty class default values allow
\sphinxstylestrong{initialize-instance} to clear a slot.

If an error occurs, the instance will \sphinxstyleemphasis{not} be deleted, but the slot
values may be in an inconsistent state.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass A (is\PYGZhy{}a USER)
  (slot x (default 34))
  (slot y (default abc))
  (slot z))
CLIPS\PYGZgt{} (make\PYGZhy{}instance a of A (y 100))
[a]
CLIPS\PYGZgt{} (send [a] print)
[a] of A
(x 34)
(y 100)
(z nil)
CLIPS\PYGZgt{} (send [a] put\PYGZhy{}x 65)
65
CLIPS\PYGZgt{} (send [a] put\PYGZhy{}y abc)
abc
CLIPS\PYGZgt{} (send [a] put\PYGZhy{}z \PYGZdq{}Hello world.\PYGZdq{})
?Hello world.?
CLIPS\PYGZgt{} (send [a] print)
[a] of A
(x 65)
(y abc)
(z \PYGZdq{}Hello world.\PYGZdq{})
CLIPS\PYGZgt{} (initialize\PYGZhy{}instance a)
[a]
CLIPS\PYGZgt{} (send [a] print)
a of A
(x 34)
(y abc)
(z nil)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{9.6.3 Reading Slots}
\label{\detokenize{cool:reading-slots}}
Sources external to an object, such as a rule or deffunction, can read
an object?s slots only by sending the object a message. Message-handlers
executing on the behalf of an object can either use messages or direct
access to read the object?s slots (see section 9.4.2). Several functions
also exist which operate implicitly on the active instance for a message
that can only be called by message-handlers, such as \sphinxstylestrong{dynamic-get}
(see section 12.16.4.10).

Section 12.16 describes ways of testing for the existence of slots and
their values.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{slot} \PYG{n}{x} \PYG{p}{(}\PYG{n}{default} \PYG{n}{abc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{sym}\PYG{o}{\PYGZhy{}}\PYG{n}{cat} \PYG{p}{(}\PYG{n}{send} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)} \PYG{n}{def}\PYG{p}{)}
\PYG{n}{abcdef}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{9.6.4 Setting Slots}
\label{\detokenize{cool:setting-slots}}
Sources external to an object, such as a rule or deffunction, can write
an object?s slots only by sending the object a message. Several
functions also exist which operate implicitly on the active instance for
a message that can only be called by message-handlers, such as
\sphinxstylestrong{dynamic-put} (see section 12.16.4.11). The \sphinxstylestrong{bind} function can also
be used to set a slot’s value from within a message-handler (see section
9.4.2).

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{}
(defclass A (is\PYGZhy{}a USER)
(slot x (default abc)))
CLIPS\PYGZgt{} (make\PYGZhy{}instance a of A)
[a]
CLIPS\PYGZgt{} (send [a] put\PYGZhy{}x \PYGZdq{}New value.\PYGZdq{})
?New value.?
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{9.6.5 Deleting Instances}
\label{\detokenize{cool:deleting-instances}}
Sending the \sphinxstylestrong{delete} message to an instance removes it from the
system. Within a message-handler, the \sphinxstylestrong{delete-instance} function (see
section 12.16) can be used to delete the active instance for a message.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{send} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZgt{}} \PYG{n}{delete}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{9.6.6 Delayed Pattern-Matching When Manipulating Instances}
\label{\detokenize{cool:delayed-pattern-matching-when-manipulating-instances}}
While manipulating instances (either by creating, modifying, or
deleting), it is possible to delay pattern-matching activities for rules
until after all of the manipulations have been made. This can be
accomplished using the \sphinxstylestrong{object-pattern-match-delay} function. This
function acts identically to the \sphinxstylestrong{progn} function, however, any
actions that could affect object pattern-matching for rules are delayed
until the function is exited. This function?s primary purpose is to
provide some control over performance.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{object}\PYG{o}{\PYGZhy{}}\PYG{n}{pattern}\PYG{o}{\PYGZhy{}}\PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{delay} \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{A}
  \PYG{p}{(}\PYG{n+nb}{object} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{A}\PYG{p}{)}\PYG{p}{)}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{p}{:} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{1} \PYG{n}{activation}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{b} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{p}{:} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{p}{:} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{2} \PYG{n}{activations}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n+nb}{object}\PYG{o}{\PYGZhy{}}\PYG{n}{pattern}\PYG{o}{\PYGZhy{}}\PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{delay}
  \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{c} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{After c...}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{crlf}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{d} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{After d...}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{crlf}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{After} \PYG{n}{c}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{p}{:} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{p}{:} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{2} \PYG{n}{activations}\PYG{o}{.}
\PYG{n}{After} \PYG{n}{d}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{p}{:} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{p}{:} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{2} \PYG{n}{activations}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{agenda}\PYG{p}{)}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{p}{:} \PYG{p}{[}\PYG{n}{d}\PYG{p}{]}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{p}{:} \PYG{p}{[}\PYG{n}{c}\PYG{p}{]}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{p}{:} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]}
\PYG{l+m+mi}{0} \PYG{n}{match}\PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{p}{:} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{4} \PYG{n}{activations}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{9.6.7 Modifying Instances}
\label{\detokenize{cool:modifying-instances}}
Four functions are provided for modifying instances. These functions
allow instance slot updates to be performed in blocks without requiring
a series of put- messages. Each of these functions returns the symbol
TRUE if successful, otherwise the symbol FALSE is returned.


\subsubsection{9.6.7.1 Directly Modifying an Instance with Delayed Pattern-Matching}
\label{\detokenize{cool:directly-modifying-an-instance-with-delayed-pattern-matching}}
The \sphinxstylestrong{modify-instance} function uses the \sphinxstylestrong{direct-modify} message to
change the values of the instance. Object pattern-matching is delayed
until all of the slot modifications have been performed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{modify}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{override}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{foo}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{bar}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{watch} \PYG{n+nb}{all}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{modify}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{p}{(}\PYG{n}{foo} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{direct}\PYG{o}{\PYGZhy{}}\PYG{n}{modify} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0019}\PYG{n}{CD5A}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{direct}\PYG{o}{\PYGZhy{}}\PYG{n}{modify} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}\PYG{o}{.}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0019}\PYG{n}{CD5A}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{n}{local} \PYG{n}{slot} \PYG{n}{foo} \PYG{o+ow}{in} \PYG{n}{instance} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{0}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{direct}\PYG{o}{\PYGZhy{}}\PYG{n}{modify} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}\PYG{o}{.}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0019}\PYG{n}{CD5A}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{direct}\PYG{o}{\PYGZhy{}}\PYG{n}{modify} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0019}\PYG{n}{CD5A}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{unwatch} \PYG{n+nb}{all}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{9.6.7.2 Directly Modifying an Instance with Immediate Pattern-Matching}
\label{\detokenize{cool:directly-modifying-an-instance-with-immediate-pattern-matching}}
The \sphinxstylestrong{active-modify-instance} function uses the \sphinxstylestrong{direct-modify}
message to change the values of the instance. Object pattern-matching
occurs as slot modifications are being performed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{active}\PYG{o}{\PYGZhy{}}\PYG{n}{modify}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{override}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{9.6.7.3 Modifying an Instance using Messages with Delayed Pattern-Matching}
\label{\detokenize{cool:modifying-an-instance-using-messages-with-delayed-pattern-matching}}
The \sphinxstylestrong{message-modify-instance} function uses the \sphinxstylestrong{message-modify}
message to change the values of the instance. Object pattern-matching is
delayed until all of the slot modifications have been performed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{modify}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{override}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{foo}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{bar}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{watch} \PYG{n+nb}{all}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{modify}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{p}{(}\PYG{n}{bar} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{modify} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{009}\PYG{n}{F04A0}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{modify} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{009}\PYG{n}{F04A0}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{bar} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{bar} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{A}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{n}{local} \PYG{n}{slot} \PYG{n}{bar} \PYG{o+ow}{in} \PYG{n}{instance} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{bar} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{A}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{bar} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{modify} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{009}\PYG{n}{F04A0}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{modify} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{009}\PYG{n}{F04A0}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{unwatch} \PYG{n+nb}{all}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{9.6.7.4 Modifying an Instance using Messages with Immediate Pattern-Matching}
\label{\detokenize{cool:modifying-an-instance-using-messages-with-immediate-pattern-matching}}
The \sphinxstylestrong{active-message-modify-instance} function uses the
\sphinxstylestrong{message-modify} message to change the values of the instance. Object
pattern-matching occurs as slot modifications are being performed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{active}\PYG{o}{\PYGZhy{}}\PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{modify}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{override}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{9.6.8 Duplicating Instances}
\label{\detokenize{cool:duplicating-instances}}
Four functions are provided for duplicating instances. These functions
allow instance duplication and slot updates to be performed in blocks
without requiring a series of put- messages. Each of these functions
return the instance-name of the new duplicated instance if successful,
otherwise the symbol FALSE is returned.

Each of the duplicate functions can optionally specify the name of the
instance to which the old instance will be copied. If the name is not
specified, the function will generate the name using the (gensym*)
function. If the target instance already exists, it will be deleted
directly or with a delete message depending on which function was
called.


\subsubsection{9.6.8.1 Directly Duplicating an Instance with Delayed Pattern-Matching}
\label{\detokenize{cool:directly-duplicating-an-instance-with-delayed-pattern-matching}}
The \sphinxstylestrong{duplicate-instance} function uses the \sphinxstylestrong{direct-duplicate}
message to change the values of the instance. Object pattern-matching is
delayed until all of the slot modifications have been performed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{duplicate}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{to} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{override}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{setgen} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{l+m+mi}{1}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{foo}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{bar}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A} \PYG{p}{(}\PYG{n}{foo} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{(}\PYG{n}{bar} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{watch} \PYG{n+nb}{all}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{duplicate}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{direct}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{gen1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{00000000}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{direct}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{gen1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{00000000}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{gen1}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{n}{local} \PYG{n}{slot} \PYG{n}{foo} \PYG{o+ow}{in} \PYG{n}{instance} \PYG{n}{gen1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{0}
\PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{n}{local} \PYG{n}{slot} \PYG{n}{bar} \PYG{o+ow}{in} \PYG{n}{instance} \PYG{n}{gen1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{direct}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{gen1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{00000000}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{direct}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{gen1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{00000000}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{gen1}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{unwatch} \PYG{n+nb}{all}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{9.6.8.2 Directly Duplicating an Instance with Immediate Pattern-Matching}
\label{\detokenize{cool:directly-duplicating-an-instance-with-immediate-pattern-matching}}
The \sphinxstylestrong{active-duplicate-instance} function uses the \sphinxstylestrong{direct-duplicate}
message to change the values of the instance. Object pattern-matching
occurs as slot modifications are being performed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{active}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{to} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{override}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{9.6.8.3 Duplicating an Instance using Messages with Delayed Pattern-Matching}
\label{\detokenize{cool:duplicating-an-instance-using-messages-with-delayed-pattern-matching}}
The \sphinxstylestrong{message-duplicate-instance} function uses the
\sphinxstylestrong{message-duplicate} message to change the values of the instance.
Object pattern-matching is delayed until all of the slot modifications
have been performed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{to} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{override}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defclass} \PYG{n}{A} \PYG{p}{(}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{USER}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{foo}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{slot} \PYG{n}{bar}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{of} \PYG{n}{A} \PYG{p}{(}\PYG{n}{foo} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{(}\PYG{n}{bar} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{make}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{b} \PYG{n}{of} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{watch} \PYG{n+nb}{all}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{n}{a} \PYG{n}{to} \PYG{n}{b} \PYG{p}{(}\PYG{n}{bar} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{009}\PYG{n}{F04A0}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{009}\PYG{n}{F04A0}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{delete} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{delete} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{o}{==} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{delete} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Stale} \PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{delete} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Stale} \PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{instance} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{n}{of} \PYG{n}{A}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{create} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{create} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{create} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{create} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{bar} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{bar} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{A}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{n}{local} \PYG{n}{slot} \PYG{n}{bar} \PYG{o+ow}{in} \PYG{n}{instance} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{6}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{bar} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{A}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{bar} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{foo} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{foo} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{A}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{n}{local} \PYG{n}{slot} \PYG{n}{foo} \PYG{o+ow}{in} \PYG{n}{instance} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{0}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{foo} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{A}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{put}\PYG{o}{\PYGZhy{}}\PYG{n}{foo} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{init} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{init} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{init} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{init} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{HND} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate} \PYG{n}{primary} \PYG{o+ow}{in} \PYG{k}{class} \PYG{n+nc}{USER}
\PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{009}\PYG{n}{F04A0}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{MSG} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate} \PYG{n}{ED}\PYG{p}{:}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Instance}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{Pointer}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{009}\PYG{n}{F04A0}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{unwatch} \PYG{n+nb}{all}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsubsection{9.6.8.4 Duplicating an Instance using Messages with Immediate Pattern-Matching}
\label{\detokenize{cool:duplicating-an-instance-using-messages-with-immediate-pattern-matching}}
The \sphinxstylestrong{active-message-duplicate-instance} function uses the
\sphinxstylestrong{message-duplicate} message to change the values of the instance.
Object pattern-matching occurs as slot modifications are being
performed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{active}\PYG{o}{\PYGZhy{}}\PYG{n}{message}\PYG{o}{\PYGZhy{}}\PYG{n}{duplicate}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{to} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}
   \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{override}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}


\section{9.7 Instance-set Queries and Distributed Actions}
\label{\detokenize{cool:instance-set-queries-and-distributed-actions}}\label{\detokenize{cool:instanceset-queries-and-distributed-actions-1}}
COOL provides a useful query system for determining and performing
actions on sets of instances of user-defined classes that satisfy
user-defined queries. The instance query system in COOL provides six
functions, each of which operate on instance-sets determined by
user-defined criteria:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Function}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Purpose}
\\
\hline
any-instancep
&
Determines if one or more instance-sets satisfy a query
\\
\hline
find-instance
&
Returns the first instance-set that satisfies a query
\\
\hline
find-all-instances
&
Groups and returns all instance-sets which satisfy a query
\\
\hline
do-for-instance
&
Performs an action for the first instance-set which satisfies a query
\\
\hline
do-for-all-instances
&
Performs an action for every instance-set which satisfies a query as they are found
\\
\hline
delayed-do-for-all-instances
&
Groups all instance-sets which satisfy a query and then iterates an action over this group
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Explanations on how to form instance-set templates, queries and actions
immediately follow, for these definitions are common to all of the query
functions. The specific details of each query function will then be
given. The following is a complete example of an instance-set query
function:

Example

{\color{red}\bfseries{}\textbar{}image5\textbar{}}

For all of the examples in this section, assume that the commands below
have already been entered:

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{}
(defclass PERSON (is\PYGZhy{}a USER)
  (role abstract)
  (slot sex (access read\PYGZhy{}only)
  (storage shared))
  (slot age (type NUMBER)
  (create\PYGZhy{}accessor ?NONE)
  (visibility public)))
CLIPS\PYGZgt{}
(defmessage\PYGZhy{}handler PERSON put\PYGZhy{}age (?value)
  (dynamic\PYGZhy{}put age ?value))
CLIPS\PYGZgt{}
(defclass FEMALE (is\PYGZhy{}a PERSON)
  (role abstract)
  (slot sex (source composite)
  (default female)))
CLIPS\PYGZgt{}
(defclass MALE (is\PYGZhy{}a PERSON)
  (role abstract)
  (slot sex (source composite)
  (default male)))
CLIPS\PYGZgt{}
(defclass GIRL (is\PYGZhy{}a FEMALE)
  (role concrete)
  (slot age (source composite)
  (default 4)
  (range 0.0 17.9)))
CLIPS\PYGZgt{}
(defclass WOMAN (is\PYGZhy{}a FEMALE)
  (role concrete)
  (slot age (source composite)
  (default 25)
  (range 18.0 100.0)))
CLIPS\PYGZgt{}
(defclass BOY (is\PYGZhy{}a MALE)
  (role concrete)
  (slot age (source composite)
  (default 4)
  (range 0.0 17.9)))
CLIPS\PYGZgt{}
(defclass MAN (is\PYGZhy{}a MALE)
  (role concrete)
  (slot age (source composite)
  (default 25)
  (range 18.0 100.0)))
CLIPS\PYGZgt{}
(definstances PEOPLE
  (Man\PYGZhy{}1 of MAN (age 18))
  (Man\PYGZhy{}2 of MAN (age 60))
  (Woman\PYGZhy{}1 of WOMAN (age 18))
  (Woman\PYGZhy{}2 of WOMAN (age 60))
  (Woman\PYGZhy{}3 of WOMAN)
  (Boy\PYGZhy{}1 of BOY (age 8))
  (Boy\PYGZhy{}2 of BOY)
  (Boy\PYGZhy{}3 of BOY)
  (Boy\PYGZhy{}4 of BOY)
  (Girl\PYGZhy{}1 of GIRL (age 8))
  (Girl\PYGZhy{}2 of GIRL))
CLIPS\PYGZgt{} (reset)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{9.7.1 Instance-set Definition}
\label{\detokenize{cool:instance-set-definition}}
An \sphinxstylestrong{instance-set} is an ordered collection of instances. Each
\sphinxstylestrong{instance-set member} is an instance of a set of classes, called
\sphinxstylestrong{class restrictions}, defined by the user. The class restrictions can
be different for each instance-set member. The query functions use
\sphinxstylestrong{instance-set templates} to generate instance-sets. An instance-set
template is a set of \sphinxstylestrong{instance-set member variables} and their
associated class restrictions. Instance-set member variables reference
the corresponding members in each instance-set that matches a template.
Variables may be used to specify the classes for the instance-set
template, but if the constant names of the classes are specified, the
classes must already be defined. Module specifiers may be included with
the class names; the classes need not be in scope of the current module.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{member}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}

\PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{member}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{member}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{restrictions}\PYG{o}{\PYGZgt{}}\PYG{p}{)}

\PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{member}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{single}\PYG{o}{\PYGZhy{}}\PYG{n}{field}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{restrictions}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}
\end{sphinxVerbatim}

Example

One instance-set template might be the ordered pairs of boys or men and
girls or women.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
((?man\PYGZhy{}or\PYGZhy{}boy BOY MAN) (?woman\PYGZhy{}or\PYGZhy{}girl GIRL WOMAN))
\end{sphinxVerbatim}

This instance-set template could have been written equivalently:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
((?man\PYGZhy{}or\PYGZhy{}boy MALE) (?woman\PYGZhy{}or\PYGZhy{}girl FEMALE))
\end{sphinxVerbatim}

Instance-set member variables (e.g. ?man-or-boy) are bound to
instance-names.


\subsection{9.7.2 Instance-set Determination}
\label{\detokenize{cool:instance-set-determination}}
COOL uses straightforward permutations to generate instance-sets that
match an instance-set template from the actual instances in the system.
The rules are as follows:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
When there is more than one member in an instance-set template, vary
the rightmost members first.

\item {} 
When there is more than one class that an instance-set member can be,
iterate through the classes from left to right.

\item {} 
Examine instances of a class in the order that they were defined.

\item {} 
Recursively examine instances of subclasses in the order that the
subclasses were defined. If the specified query class was in scope of
the current module, then only subclasses that are also in scope will be
examined. Otherwise, only subclasses that are in scope of the module to
which the query class belongs will be examined.

\end{enumerate}

Example

For the instance-set template given in section 9.7.1, thirty
instance-sets would be generated in the following order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{=} \PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{=}
\PYG{l+m+mf}{1.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}   \PYG{l+m+mf}{16.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{2.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}   \PYG{l+m+mf}{17.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{l+m+mf}{3.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{l+m+mf}{18.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{4.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{l+m+mf}{19.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{l+m+mf}{5.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}  \PYG{l+m+mf}{20.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{l+m+mf}{6.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}   \PYG{l+m+mf}{21.} \PYG{p}{[}\PYG{n}{Man}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{7.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}   \PYG{l+m+mf}{22.} \PYG{p}{[}\PYG{n}{Man}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{l+m+mf}{8.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{l+m+mf}{23.} \PYG{p}{[}\PYG{n}{Man}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{9.} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{l+m+mf}{24.} \PYG{p}{[}\PYG{n}{Man}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{l+m+mf}{10.}\PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}  \PYG{l+m+mf}{25.} \PYG{p}{[}\PYG{n}{Man}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{l+m+mf}{11.}\PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}   \PYG{l+m+mf}{26.} \PYG{p}{[}\PYG{n}{Man}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{12.}\PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}   \PYG{l+m+mf}{27.} \PYG{p}{[}\PYG{n}{Man}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{l+m+mi}{13} \PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{l+m+mf}{28.} \PYG{p}{[}\PYG{n}{Man}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{14.}\PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{l+m+mf}{29.} \PYG{p}{[}\PYG{n}{Man}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{l+m+mf}{15.}\PYG{p}{[}\PYG{n}{Boy}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}  \PYG{l+m+mf}{30.} \PYG{p}{[}\PYG{n}{Man}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{=} \PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{=}
\end{sphinxVerbatim}

Example

Consider the following instance-set template:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
((?f1 FEMALE) (?f2 FEMALE))
\end{sphinxVerbatim}

Twenty-five instance-sets would be generated in the following order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==} \PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\PYG{l+m+mf}{1.} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}   \PYG{l+m+mf}{14.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{l+m+mf}{2.} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}   \PYG{l+m+mf}{15.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{l+m+mf}{3.} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{l+m+mf}{16.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{4.} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{l+m+mf}{17.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{l+m+mf}{5.} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}  \PYG{l+m+mf}{18.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{6.} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}   \PYG{l+m+mf}{19.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{l+m+mf}{7.} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}   \PYG{l+m+mf}{20.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{l+m+mf}{8.} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{l+m+mf}{21.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{9.} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{l+m+mf}{22.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{l+m+mf}{10.}\PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}  \PYG{l+m+mf}{23.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{11.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{l+m+mf}{24.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{l+m+mf}{12.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Girl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{l+m+mf}{25.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{l+m+mf}{13.}\PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Woman}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==} \PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\end{sphinxVerbatim}

The instances of class GIRL are examined before the instances of class
WOMAN because GIRL was defined before WOMAN.


\subsection{9.7.3 Query Definition}
\label{\detokenize{cool:query-definition}}
A \sphinxstylestrong{query} is a user-defined boolean expression applied to an
instance-set to determine if the instance-set meets further user-defined
restrictions. If the evaluation of this expression for an instance-set
is anything but the symbol FALSE, the instance-set is said to satisfy
the query.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{boolean}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Example

Continuing the previous example, one query might be that the two
instances in an ordered pair have the same age.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(= (send ?man\PYGZhy{}or\PYGZhy{}boy get\PYGZhy{}age) (send ?woman\PYGZhy{}or\PYGZhy{}girl get\PYGZhy{}age))
\end{sphinxVerbatim}

Within a query, slots of instance-set members can be directly read with
a shorthand notation similar to that used in message-handlers (see
section 9.4.2). If message-passing is not explicitly required for
reading a slot (i.e. there are no accessor daemons for reads), then this
second method of slot access should be used, for it gives a significant
performance benefit.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{member}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Example

The previous example could be rewritten as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(= ?man\PYGZhy{}or\PYGZhy{}boy:age ?woman\PYGZhy{}or\PYGZhy{}girl:age)
\end{sphinxVerbatim}

Since only instance-sets that satisfy a query are of interest, and the
query is evaluated for all possible instance-sets, the query should not
have any side-effects.


\subsection{9.7.4 Distributed Action Definition}
\label{\detokenize{cool:distributed-action-definition}}
A \sphinxstylestrong{distributed action} is a user-defined expression evaluated for each
instance-set which satisfies a query. Unlike queries, distributed
actions must use messages to read slots of instance-set members. If more
than one action is required, use the \sphinxstylestrong{progn} function (see section
12.6.5) to group them.

Action \sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Example

Continuing the previous example, one distributed action might be to
simply print out the ordered pair to the screen.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(printout t \PYGZdq{}(\PYGZdq{} ?man\PYGZhy{}or\PYGZhy{}boy \PYGZdq{},\PYGZdq{} ?woman\PYGZhy{}or\PYGZhy{}girl \PYGZdq{})\PYGZdq{} crlf)
\end{sphinxVerbatim}


\subsection{9.7.5 Scope in Instance-set Query Functions}
\label{\detokenize{cool:scope-in-instance-set-query-functions}}
An instance-set query function can be called from anywhere that a
regular function can be called. If a variable from an outer scope is not
masked by an instance-set member variable, then that variable may be
referenced within the query and action. In addition, rebinding variables
within an instance-set function action is allowed. However, attempts to
rebind instance-set member variables will generate errors. Binding
variables is not allowed within a query. Instance-set query functions
can be nested.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{}
(deffunction count\PYGZhy{}instances (?class)
  (bind ?count 0)
  (do\PYGZhy{}for\PYGZhy{}all\PYGZhy{}instances ((?ins ?class)) TRUE
  (bind ?count (+ ?count 1)))
  ?count)
CLIPS\PYGZgt{}
(deffunction count\PYGZhy{}instances\PYGZhy{}2 (?class)
  (length (find\PYGZhy{}all\PYGZhy{}instances ((?ins ?class)) TRUE)))
CLIPS\PYGZgt{} (count\PYGZhy{}instances WOMAN)
3
CLIPS\PYGZgt{} (count\PYGZhy{}instances\PYGZhy{}2 BOY)
4
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

Instance-set member variables are only in scope within the instance-set
query function. Attempting to use instance-set member variables in an
outer scope will generate an error.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{}
    (deffunction last\PYGZhy{}instance (?class)
      (any\PYGZhy{}instancep ((?ins ?class)) TRUE)
      ?ins)
    [PRCCODE3] Undefined variable ins referenced in deffunction.
    ERROR:
    (deffunction MAIN::last\PYGZhy{}instance
      (?class)
      (any\PYGZhy{}instancep ((?ins ?class))
      TRUE)
      ?ins)
    CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{9.7.6 Errors during Instance-set Query Functions}
\label{\detokenize{cool:errors-during-instance-set-query-functions}}
If an error occurs during an instance-set query function, the function
will be immediately terminated and the return value will be the symbol
FALSE.


\subsection{9.7.7 Halting and Returning Values from Query Functions}
\label{\detokenize{cool:halting-and-returning-values-from-query-functions}}
The functions \sphinxstylestrong{break} and \sphinxstylestrong{return} are now valid inside the action
of the instance-set query functions \sphinxstylestrong{do-for-instance},
\sphinxstylestrong{do-for-all-instances} and \sphinxstylestrong{delayed-do-for-all-instances}. The
\sphinxstylestrong{return} function is only valid if it is applicable in the outer
scope, whereas the \sphinxstylestrong{break} function actually halts the query.


\subsection{9.7.8 Instance-set Query Functions}
\label{\detokenize{cool:instance-set-query-functions}}
The instance query system in COOL provides six functions. For a given
set of instances, all six query functions will iterate over these
instances in the same order (see section 9.7.2). However, if a
particular instance is deleted and recreated, the iteration order will
change.


\subsubsection{9.7.8.1 Testing if Any Instance-set Satisfies a Query}
\label{\detokenize{cool:testing-if-any-instance-set-satisfies-a-query}}
This function applies a query to each instance-set that matches the
template. If an instance-set satisfies the query, then the function is
immediately terminated, and the return value is the symbol TRUE.
Otherwise, the return value is the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{any}\PYG{o}{\PYGZhy{}}\PYG{n}{instancep} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

Are there any men over age 30?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (any\PYGZhy{}instancep ((?man MAN)) (\PYGZgt{} ?man:age 30))
TRUE
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{9.7.8.2 Determining the First Instance-set Satisfying a Query}
\label{\detokenize{cool:determining-the-first-instance-set-satisfying-a-query}}
This function applies a query to each instance-set that matches the
template. If an instance-set satisfies the query, then the function is
immediately terminated, and the instance-set is returned in a multifield
value. Otherwise, the return value is a zero-length multifield value.
Each field of the multifield value is an instance-name representing an
instance-set member.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{find}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

Find the first pair of a man and a woman who have the same age.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{}
(find\PYGZhy{}instance ((?m MAN) (?w WOMAN)) (= ?m:age ?w:age))

([Man\PYGZhy{}1] [Woman\PYGZhy{}1])
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{9.7.8.3 Determining All Instance-sets Satisfying a Query}
\label{\detokenize{cool:determining-all-instance-sets-satisfying-a-query}}
This function applies a query to each instance-set that matches the
template. Each instance-set that satisfies the query is stored in a
multifield value. This multifield value is returned when the query has
been applied to all possible instance-sets. If there are n instances in
each instance-set, and m instance-sets satisfied the query, then the
length of the returned multifield value will be n * m. The first n
fields correspond to the first instance-set, and so on. Each field of
the multifield value is an instance-name representing an instance-set
member. The multifield value can consume a large amount of memory due to
permutational explosion, so this function should be used judiciously.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{find}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{instances} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

Find all pairs of a man and a woman who have the same age.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{}
(find\PYGZhy{}all\PYGZhy{}instances ((?m MAN) (?w WOMAN)) (= ?m:age ?w:age))

([Man\PYGZhy{}1] [Woman\PYGZhy{}1] [Man\PYGZhy{}2] [Woman\PYGZhy{}2])
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{9.7.8.4 Executing an Action for the First Instance-set Satisfying a Query}
\label{\detokenize{cool:executing-an-action-for-the-first-instance-set-satisfying-a-query}}
This function applies a query to each instance-set that matches the
template. If an instance-set satisfies the query, the specified action
is executed, and the function is immediately terminated. The return
value is the evaluation of the action. If no instance-set satisfied the
query, then the return value is the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{do}\PYG{o}{\PYGZhy{}}\PYG{k}{for}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

Print out the first triplet of different people that have the same age.
The calls to \sphinxstylestrong{neq} in the query eliminate the permutations where two
or more members of the instance-set are identical.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{}
(do\PYGZhy{}for\PYGZhy{}instance ((?p1 PERSON) (?p2 PERSON) (?p3 PERSON))
  (and (= ?p1:age ?p2:age ?p3:age)
  (neq ?p1 ?p2)
  (neq ?p1 ?p3)
  (neq ?p2 ?p3))
  (printout t ?p1 \PYGZdq{} \PYGZdq{} ?p2 \PYGZdq{} \PYGZdq{} ?p3 crlf))

  [Girl\PYGZhy{}2] [Boy\PYGZhy{}2] [Boy\PYGZhy{}3]
  CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{9.7.8.5 Executing an Action for All Instance-sets Satisfying a Query}
\label{\detokenize{cool:executing-an-action-for-all-instance-sets-satisfying-a-query}}
This function applies a query to each instance-set that matches the
template. If an instance-set satisfies the query, the specified action
is executed. The return value is the evaluation of the action for the
last instance-set that satisfied the query. If no instance-set satisfied
the query, then the return value is the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{do}\PYG{o}{\PYGZhy{}}\PYG{k}{for}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{instances} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

Print out all triplets of different people that have the same age. The
calls to \sphinxstylestrong{str-compare} limit the instance-sets that satisfy the query
to combinations instead of permutations. Without these restrictions, two
instance-sets that differed only in the order of their members would
both satisfy the query.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{}

    (do\PYGZhy{}for\PYGZhy{}all\PYGZhy{}instances ((?p1 PERSON) (?p2 PERSON) (?p3 PERSON))
      (and (= ?p1:age ?p2:age ?p3:age)
      (\PYGZgt{} (str\PYGZhy{}compare ?p1 ?p2) 0)
      (\PYGZgt{} (str\PYGZhy{}compare ?p2 ?p3) 0))
      (printout t ?p1 \PYGZdq{} \PYGZdq{} ?p2 \PYGZdq{} \PYGZdq{} ?p3 crlf))

    [Girl\PYGZhy{}2] [Boy\PYGZhy{}3] [Boy\PYGZhy{}2]
    [Girl\PYGZhy{}2] [Boy\PYGZhy{}4] [Boy\PYGZhy{}2]
    [Girl\PYGZhy{}2] [Boy\PYGZhy{}4] [Boy\PYGZhy{}3]
    [Boy\PYGZhy{}4] [Boy\PYGZhy{}3] [Boy\PYGZhy{}2]

    CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsubsection{9.7.8.6 Executing a Delayed Action for All Instance-sets Satisfying a Query}
\label{\detokenize{cool:executing-a-delayed-action-for-all-instance-sets-satisfying-a-query}}
This function is similar to \sphinxstylestrong{do-for-all-instances} except that it
groups all instance-sets that satisfy the query into an intermediary
multifield value. If there are no instance-sets which satisfy the query,
then the function returns the symbol FALSE. Otherwise, the specified
action is executed for each instance-set in the multifield value, and
the return value is the evaluation of the action for the last
instance-set to satisfy the query. The intermediary multifield value is
discarded. This function can consume large amounts of memory in the same
fashion as \sphinxstylestrong{find-all-instances}. This function should be used in lieu
of \sphinxstylestrong{do-for-all-instances} when the action applied to one instance-set
would change the result of the query for another instance-set (unless
that is the desired effect).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{delayed}\PYG{o}{\PYGZhy{}}\PYG{n}{do}\PYG{o}{\PYGZhy{}}\PYG{k}{for}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{instances} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

Delete all boys with the greatest age. The test in this case is another
query function that determines if there are any older boys than the one
currently being examined. The action needs to be delayed until all boys
have been processed, or the greatest age will decrease as the older boys
are deleted.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (watch instances)
CLIPS\PYGZgt{}
(delayed\PYGZhy{}do\PYGZhy{}for\PYGZhy{}all\PYGZhy{}instances ((?b1 BOY))
  (not (any\PYGZhy{}instancep ((?b2 BOY))
  (\PYGZgt{} ?b2:age ?b1:age)))
  (send ?b1 delete))
\PYGZlt{}== instance [Boy\PYGZhy{}1] of BOY
TRUE
CLIPS\PYGZgt{} (unwatch instances)
CLIPS\PYGZgt{} (reset)
CLIPS\PYGZgt{} (watch instances)
CLIPS\PYGZgt{}
(do\PYGZhy{}for\PYGZhy{}all\PYGZhy{}instances ((?b1 BOY))
  (not (any\PYGZhy{}instancep ((?b2 BOY))
  (\PYGZgt{} ?b2:age ?b1:age)))
  (send ?b1 delete))
\PYGZlt{}== instance [Boy\PYGZhy{}1] of BOY
\PYGZlt{}== instance [Boy\PYGZhy{}2] of BOY
\PYGZlt{}== instance [Boy\PYGZhy{}3] of BOY
\PYGZlt{}== instance [Boy\PYGZhy{}4] of BOY
TRUE
CLIPS\PYGZgt{} (unwatch instances)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{cool:section-7}}

\chapter{Section 10: Defmodule Construct}
\label{\detokenize{defmodule:section-10-defmodule-construct}}\label{\detokenize{defmodule::doc}}
CLIPS provides support for the modular development and execution of
knowledge bases with the \sphinxstylestrong{defmodule} construct. CLIPS modules allow a
set of constructs to be grouped together such that explicit control can
be maintained over restricting the access of the constructs by other
modules. This type of control is similar to global and local scoping
used in languages such as C or Ada (note, however, that the global
scoping used by CLIPS is strictly hierarchical and in one direction
only?if module A can see constructs from module B, then it is not
possible for module B to see any of module A?s constructs). By
restricting access to deftemplate and defclass constructs, modules can
function as blackboards, permitting only certain facts and instances to
be seen by other modules. Modules are also used by rules to provide
execution control.


\section{10.1 Defining Modules}
\label{\detokenize{defmodule:defining-modules}}
Modules are defined using the defmodule construct.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmodule \PYGZlt{}module\PYGZhy{}name\PYGZgt{} [\PYGZlt{}comment\PYGZgt{}] \PYGZlt{}port\PYGZhy{}specification\PYGZgt{}*)

\PYGZlt{}port\PYGZhy{}specification\PYGZgt{} ::= (export \PYGZlt{}port\PYGZhy{}item\PYGZgt{}) \textbar{}
  (import \PYGZlt{}module\PYGZhy{}name\PYGZgt{} \PYGZlt{}port\PYGZhy{}item\PYGZgt{})
  \PYGZlt{}port\PYGZhy{}item\PYGZgt{} ::= ?ALL \textbar{}
  ?NONE \textbar{}
  \PYGZlt{}port\PYGZhy{}construct\PYGZgt{} ?ALL \textbar{}
  \PYGZlt{}port\PYGZhy{}construct\PYGZgt{} ?NONE \textbar{}
  \PYGZlt{}port\PYGZhy{}construct\PYGZgt{} \PYGZlt{}construct\PYGZhy{}name\PYGZgt{}+
  \PYGZlt{}port\PYGZhy{}construct\PYGZgt{} ::= deftemplate \textbar{} defclass \textbar{}
  defglobal \textbar{} deffunction \textbar{}
  defgeneric
\end{sphinxVerbatim}

A defmodule cannot be redefined or even deleted once it is defined (with
the exception of the MAIN module which can be redefined once). The only
way to delete a module is with the \sphinxstylestrong{clear} command. Upon startup and
after a \sphinxstylestrong{clear} command, CLIPS automatically constructs the following
defmodule.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defmodule} \PYG{n}{MAIN}\PYG{p}{)}
\end{sphinxVerbatim}

All of the predefined system classes (see section 9.2) belong to the
MAIN module. However, it is not necessary to import or export the system
classes; they are always in scope. Discounting the previous exception,
the predefined MAIN module does not import or export any constructs.
However, unlike other modules, the MAIN module can be redefined once
after startup or a \sphinxstylestrong{clear} command.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmodule FOO
  (import BAR ?ALL)
  (import YAK deftemplate ?ALL)
  (import GOZ defglobal x y z)
  (export defgeneric +)
  (export defclass ?ALL))
\end{sphinxVerbatim}


\section{10.2 Specifying a Construct?s Module}
\label{\detokenize{defmodule:specifying-a-construct-s-module}}
The module in which a construct is placed can be specified when the
construct is defined. The deffacts, deftemplate, defrule, deffunction,
defgeneric, defclass, and definstances constructs all specify the module
for the construct by including it as part of the name. The module of a
defglobal construct is indicated by specifying the module name after the
defglobal keyword. The module of a defmessage-handler is specified as
part of the class specifier. The module of a defmethod is specified as
part of the generic function specifier. For example, the following
constructs would be placed in the DETECTION module.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defrule DETECTION::Find\PYGZhy{}Fault
  (sensor (name ?name) (value bad))
  =\PYGZgt{}
  (assert (fault (name ?name))))
  (defglobal DETECTION ?*count* = 0)
  (defmessage\PYGZhy{}handler DETECTION::COMPONENT get\PYGZhy{}charge ()
  (* ?self:flux ?self:flow))
  (defmethod DETECTION::+ ((?x STRING) (?y STRING))
  (str\PYGZhy{}cat ?x ?y))
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defmodule} \PYG{n}{A}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defmodule} \PYG{n}{B}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defrule} \PYG{n}{foo} \PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defrule} \PYG{n}{A}\PYG{p}{:}\PYG{p}{:}\PYG{n}{bar} \PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n+nb}{list}\PYG{o}{\PYGZhy{}}\PYG{n}{defrules}\PYG{p}{)}
\PYG{n}{bar}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{1} \PYG{n}{defrule}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{current}\PYG{o}{\PYGZhy{}}\PYG{n}{module} \PYG{n}{B}\PYG{p}{)}
\PYG{n}{A}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n+nb}{list}\PYG{o}{\PYGZhy{}}\PYG{n}{defrules}\PYG{p}{)}
\PYG{n}{foo}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{1} \PYG{n}{defrule}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{10.3 Specifying Modules}
\label{\detokenize{defmodule:specifying-modules}}
Commands such as \sphinxstylestrong{undefrule} and \sphinxstylestrong{ppdefrule} require the name of a
construct on which to operate. In previous versions of CLIPS, constructs
were always referred to by their name only, so it was sufficient just to
pass the name of the construct to these commands. With modules, however,
it is possible to have a construct with the same name in two different
modules. The modules associated with a name can be specified either
explicitly or implicitly. To explicitly specify a name?s module the
module name (a symbol) is listed followed by two colons, ::, and then
the name is listed. The module name followed by :: is referred to as a
\sphinxstylestrong{module specifier}. For example, MAIN::find-stuff, refers to the
find-stuff construct in the MAIN module. A module can also be implicitly
specified since there is always a ?current? module. The current module
is changed whenever a defmodule construct is defined or the
\sphinxstylestrong{set-current-module} function is used. The MAIN module is
automatically defined by CLIPS and by default is the current module when
CLIPS is started or after a \sphinxstylestrong{clear} command is issued. Thus the name
find-stuff would implicitly have the MAIN module as its module when
CLIPS is first started.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{} (defmodule A)
CLIPS\PYGZgt{} (defglobal A ?*x* = 0)
CLIPS\PYGZgt{} (defmodule B)
CLIPS\PYGZgt{} (defglobal B ?*y* = 1)
CLIPS\PYGZgt{} (ppdefglobal y)
(defglobal B ?*y* = 1)
CLIPS\PYGZgt{} (ppdefglobal B::y)
(defglobal B ?*y* = 1)
CLIPS\PYGZgt{} (ppdefglobal x)
[PRNTUTIL1] Unable to find defglobal x.
CLIPS\PYGZgt{} (ppdefglobal A::x)
(defglobal A ?*x* = 0)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\section{10.4 Importing and Exporting Constructs}
\label{\detokenize{defmodule:importing-and-exporting-constructs}}
Unless specifically \sphinxstylestrong{exported} and \sphinxstylestrong{imported}, the constructs of one
module may not be used by another module. A construct is said to be
visible or within scope of a module if that construct can be used by the
module. For example, if module \sphinxstyleemphasis{B} wants to use the \sphinxstyleemphasis{foo} deftemplate
defined in module \sphinxstyleemphasis{A}, then module \sphinxstyleemphasis{A} must export the \sphinxstyleemphasis{foo} deftemplate
and module \sphinxstyleemphasis{B} must import the \sphinxstyleemphasis{foo} deftemplate from module \sphinxstyleemphasis{A}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defmodule} \PYG{n}{A}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{deftemplate} \PYG{n}{A}\PYG{p}{:}\PYG{p}{:}\PYG{n}{foo} \PYG{p}{(}\PYG{n}{slot} \PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defmodule} \PYG{n}{B}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defrule} \PYG{n}{B}\PYG{p}{:}\PYG{p}{:}\PYG{n}{bar} \PYG{p}{(}\PYG{n}{foo} \PYG{p}{(}\PYG{n}{x} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{PRNTUTIL2}\PYG{p}{]} \PYG{n}{Syntax} \PYG{n}{Error}\PYG{p}{:} \PYG{n}{Check} \PYG{n}{appropriate} \PYG{n}{syntax} \PYG{k}{for} \PYG{n}{defrule}
\PYG{n}{ERROR}\PYG{p}{:}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{B}\PYG{p}{:}\PYG{p}{:}\PYG{n}{bar}
\PYG{p}{(}\PYG{n}{foo} \PYG{p}{(}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defmodule} \PYG{n}{A} \PYG{p}{(}\PYG{n}{export} \PYG{n}{deftemplate} \PYG{n}{foo}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{deftemplate} \PYG{n}{A}\PYG{p}{:}\PYG{p}{:}\PYG{n}{foo} \PYG{p}{(}\PYG{n}{slot} \PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defmodule} \PYG{n}{B} \PYG{p}{(}\PYG{k+kn}{import} \PYG{n+nn}{A} \PYG{n}{deftemplate} \PYG{n}{foo}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defrule} \PYG{n}{B}\PYG{p}{:}\PYG{p}{:}\PYG{n}{bar} \PYG{p}{(}\PYG{n}{foo} \PYG{p}{(}\PYG{n}{x} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

CLIPS will \sphinxstylestrong{not} allow a module or other construct to be defined that
causes two constructs with the same name to be visible within the same
module.


\subsection{10.4.1 Exporting Constructs}
\label{\detokenize{defmodule:exporting-constructs}}
The export specification in a defmodule definition is used to indicate
which constructs will be accessible to other modules importing from the
module being defined. Only deftemplates, defclasses, defglobals,
deffunctions, and defgenerics may be exported. A module may export any
valid constructs that are visible to it (not just constructs that it
defines).

There are three different types of export specifications. First, a
module may export all valid constructs that are visible to it. This
accomplished by following the \sphinxstyleemphasis{export} keyword with the \sphinxstyleemphasis{?ALL} keyword.
Second, a module may export all valid constructs of a particular type
that are visible to it. This accomplished by following the \sphinxstyleemphasis{export}
keyword with the name of the construct type followed by the \sphinxstyleemphasis{?ALL}
keyword. Third, a module may export specific constructs of a particular
type that are visible to it. This accomplished by following the \sphinxstyleemphasis{export}
keyword with the name of the construct type followed by the name of one
or more visible constructs of the specified type. In the following code,
defmodule \sphinxstyleemphasis{A} exports all of its constructs; defmodule \sphinxstyleemphasis{B} exports all
of its deftemplates; and defmodule \sphinxstyleemphasis{C} exports the \sphinxstyleemphasis{foo}, \sphinxstyleemphasis{bar}, and
\sphinxstyleemphasis{yak} defglobals.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmodule A (export ?ALL))

(defmodule B (export deftemplate ?ALL))

(defmodule C (export defglobal foo bar yak))
\end{sphinxVerbatim}

The ?NONE keyword may be used in place of the ?ALL keyword to indicate
either that no constructs are exported from a module or that no
constructs of a particular type are exported from a module.

Defmethods and defmessage-handlers cannot be explicitly exported.
Exporting a defgeneric automatically exports all associated defmethods.
Exporting a defclass automatically exports all associated
defmessage-handlers. Deffacts, definstances, and defrules cannot be
exported.


\subsection{10.4.2 Importing Constructs}
\label{\detokenize{defmodule:importing-constructs}}
The import specification in a defmodule definition is used to indicate
which constructs the module being defined will use from other modules.
Only deftemplates, defclasses, defglobals, deffunctions, and defgenerics
may be imported.

There are three different types of import specifications. First, a
module may import all valid constructs that are visible to a specified
module. This accomplished by following the \sphinxstyleemphasis{import} keyword with a
module name followed by the \sphinxstyleemphasis{?ALL} keyword. Second, a module may import
all valid constructs of a particular type that are visible to a
specified module. This accomplished by following the \sphinxstyleemphasis{import} keyword
with a module name followed by the name of the construct type followed
by the \sphinxstyleemphasis{?ALL} keyword. Third, a module may import specific constructs of
a particular type that are visible to it. This accomplished by following
the \sphinxstyleemphasis{import} keyword with a module name followed by the name of the
construct type followed by the name of one or more visible constructs of
the specified type. In the following code, defmodule \sphinxstyleemphasis{A} imports all of
module \sphinxstyleemphasis{D}?s constructs; defmodule \sphinxstyleemphasis{B} imports all of module \sphinxstyleemphasis{D}?s
deftemplates; and defmodule \sphinxstyleemphasis{C} imports the foo, bar, and \sphinxstyleemphasis{yak}
defglobals from module \sphinxstyleemphasis{D}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(defmodule A (import D ?ALL))

(defmodule B (import D deftemplate ?ALL))

(defmodule C (import D defglobal foo bar yak))
\end{sphinxVerbatim}

The ?NONE keyword may be used in place of the ?ALL keyword to indicate
either that no constructs are imported from a module or that no
constructs of a particular type are imported from a module.

Defmethods and defmessage-handlers cannot be explicitly imported.
Importing a defgeneric automatically imports all associated defmethods.
Importing a defclass automatically imports all associated
defmessage-handlers. Deffacts, definstances, and defrules cannot be
imported.

A module must be defined before it is used in an import specification.
In addition, if specific constructs are listed in the import
specification, they must already be defined in the module exporting
them. It is not necessary to import a construct from the module in which
it is defined in order to use it. A construct can be indirectly imported
from a module that directly imports and then exports the module to be
used.


\section{10.5 Importing and Exporting Facts and Instances}
\label{\detokenize{defmodule:importing-and-exporting-facts-and-instances}}
Facts and instances are ?owned? by the module in which their
corresponding deftemplate or defclass is defined, \sphinxstyleemphasis{not} by the module
which creates them. Facts and instances are thus visible only to those
modules that import the corresponding deftemplate or defclass. This
allows a knowledge base to be partitioned such that rules and other
constructs can only ?see? those facts and instances that are of interest
to them. Instance names, however, are global in scope, so it is still
possible to send messages to an instance of a class that is not in
scope.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defmodule} \PYG{n}{A} \PYG{p}{(}\PYG{n}{export} \PYG{n}{deftemplate} \PYG{n}{foo} \PYG{n}{bar}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{deftemplate} \PYG{n}{A}\PYG{p}{:}\PYG{p}{:}\PYG{n}{foo} \PYG{p}{(}\PYG{n}{slot} \PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{deftemplate} \PYG{n}{A}\PYG{p}{:}\PYG{p}{:}\PYG{n}{bar} \PYG{p}{(}\PYG{n}{slot} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{deffacts} \PYG{n}{A}\PYG{p}{:}\PYG{p}{:}\PYG{n}{info} \PYG{p}{(}\PYG{n}{foo} \PYG{p}{(}\PYG{n}{x} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)} \PYG{p}{(}\PYG{n}{bar} \PYG{p}{(}\PYG{n}{y} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defmodule} \PYG{n}{B} \PYG{p}{(}\PYG{k+kn}{import} \PYG{n+nn}{A} \PYG{n}{deftemplate} \PYG{n}{foo}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{reset}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{facts} \PYG{n}{A}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{n}{foo} \PYG{p}{(}\PYG{n}{x} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{p}{(}\PYG{n}{bar} \PYG{p}{(}\PYG{n}{y} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{2} \PYG{n}{facts}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{facts} \PYG{n}{B}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{(}\PYG{n}{foo} \PYG{p}{(}\PYG{n}{x} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{For} \PYG{n}{a} \PYG{n}{total} \PYG{n}{of} \PYG{l+m+mi}{1} \PYG{n}{fact}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{10.5.1 Specifying Instance-Names}
\label{\detokenize{defmodule:specifying-instance-names}}
Instance-names are required to be unique regardless of the module that
owns them. The syntax of instance-names has been extended to allow
module specifications (note that the left and right brackets in bold are
to be typed and do not indicate an optional part of the syntax).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{p}{[} \PYG{o}{\PYGZlt{}}\PYG{n}{symbol}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{o}{\textbar{}} \PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{symbol}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{o}{\textbar{}} \PYG{p}{[} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{symbol}\PYG{o}{\PYGZgt{}}\PYG{p}{]}
\end{sphinxVerbatim}

Specifying just a symbol as the instance-name, such as {[}Rolls-Royce{]},
will search for the instance in all modules. Specifying only the \sphinxcode{\sphinxupquote{::}}
before the name, such as \sphinxcode{\sphinxupquote{{[}::Rolls-Royce{]}}}, will search for the instance
first in the current module and then recursively in the imported modules
as defined in the module definition. Specifying both a symbol and a
module name, such as \sphinxcode{\sphinxupquote{{[}CARS::Rolls-Royce{]}}}, searches for the instance only
in the specified module.


\section{10.6 Modules and Rule Execution}
\label{\detokenize{defmodule:modules-and-rule-execution}}
Each module has its own pattern-matching network for its rules and its
own agenda. When a \sphinxstylestrong{run} command is given, the agenda of the module
that is the current focus is executed (note that the \sphinxstylestrong{reset} and
\sphinxstylestrong{clear} commands make the MAIN module the current focus). Rule
execution continues until another module becomes the current focus, no
rules are left on the agenda, or the \sphinxstylestrong{return} function is used from
the RHS of a rule. Whenever a module that was focused on runs out of
rules on its agenda, the current focus is removed from the focus stack
and the next module on the focus stack becomes the current focus. Before
a rule executes, the current module is changed to the module in which
the executing rule is defined (the current focus). The current focus can
be changed by using the \sphinxstylestrong{focus} command. See sections 5.2, 5.4.10.2,
12.12, and 13.12 for more details.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{clear}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defmodule} \PYG{n}{MAIN}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{MAIN}\PYG{p}{:}\PYG{p}{:}\PYG{n}{focus}\PYG{o}{\PYGZhy{}}\PYG{n}{example}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Firing rule in module MAIN.}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{crlf}\PYG{p}{)}
  \PYG{p}{(}\PYG{n}{focus} \PYG{n}{A} \PYG{n}{B}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defmodule} \PYG{n}{A}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{A}\PYG{p}{:}\PYG{p}{:}\PYG{n}{example}\PYG{o}{\PYGZhy{}}\PYG{n}{rule}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Firing rule in module A.}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{crlf}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{defmodule} \PYG{n}{B}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\PYG{p}{(}\PYG{n}{defrule} \PYG{n}{B}\PYG{p}{:}\PYG{p}{:}\PYG{n}{example}\PYG{o}{\PYGZhy{}}\PYG{n}{rule}
  \PYG{o}{=}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{n}{printout} \PYG{n}{t} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Firing rule in module B.}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{crlf}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{reset}\PYG{p}{)}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{run}\PYG{p}{)}
\PYG{n}{Firing} \PYG{n}{rule} \PYG{o+ow}{in} \PYG{n}{module} \PYG{n}{MAIN}\PYG{o}{.}
\PYG{n}{Firing} \PYG{n}{rule} \PYG{o+ow}{in} \PYG{n}{module} \PYG{n}{A}\PYG{o}{.}
\PYG{n}{Firing} \PYG{n}{rule} \PYG{o+ow}{in} \PYG{n}{module} \PYG{n}{B}\PYG{o}{.}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{defmodule:section-8}}

\chapter{Section 11: Constraint Attributes}
\label{\detokenize{constraints:section-11-constraint-attributes}}\label{\detokenize{constraints::doc}}
This section describes the constraint attributes that can be associated
with deftemplates and defclasses so that type checking can be performed
on slot values when template facts and instances are created. The
constraint information is also analyzed for the patterns on the LHS of a
rule to determine if the specified constraints prevent the rule from
ever firing.

Two types of constraint checking are supported: static and dynamic. When
static constraint checking is enabled, constraint violations are checked
when function calls and constructs are parsed. This includes constraint
checking between patterns on the LHS of a rule when variables are used
in more than one slot. When dynamic constraint checking is enabled,
newly created data objects (such as deftemplate facts and instances)
have their slot values checked for constraint violations. Essentially,
static constraint checking occurs when a CLIPS program is loaded and
dynamic constraint checking occurs when a CLIPS program is running. By
default, static constraint checking is enabled and dynamic constraint
checking is disabled. The default behavior can be changed by using the
\sphinxstylestrong{set-static-constraint-checking} and
\sphinxstylestrong{set-dynamic-constraint-checking} functions.

Unless dynamic constraint checking is enabled, constraint information
associated with constructs is not saved when a binary image is created
using the \sphinxstylestrong{bsave} command.

The general syntax for constraint attributes is shown following.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}constraint\PYGZhy{}attribute\PYGZgt{} ::= \PYGZlt{}type\PYGZhy{}attribute\PYGZgt{}?\textbar{}
  \PYGZlt{}allowed\PYGZhy{}constant\PYGZhy{}attribute\PYGZgt{} \textbar{}
  \PYGZlt{}range\PYGZhy{}attribute\PYGZgt{} \textbar{}
  \PYGZlt{}cardinality\PYGZhy{}attribute\PYGZgt{}
\end{sphinxVerbatim}


\section{11.1 Type Attribute}
\label{\detokenize{constraints:type-attribute}}
The type attribute allows the types of values to be stored in a slot to
be restricted.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}type\PYGZhy{}attribute\PYGZgt{} ::= (type \PYGZlt{}type\PYGZhy{}specification\PYGZgt{})

\PYGZlt{}type\PYGZhy{}specification\PYGZgt{} ::= \PYGZlt{}allowed\PYGZhy{}type\PYGZgt{}+ \textbar{} ?VARIABLE

\PYGZlt{}allowed\PYGZhy{}type\PYGZgt{} ::= SYMBOL \textbar{} STRING \textbar{} LEXEME \textbar{}
  INTEGER \textbar{} FLOAT \textbar{} NUMBER \textbar{}
  INSTANCE\PYGZhy{}NAME \textbar{} INSTANCE\PYGZhy{}ADDRESS \textbar{} INSTANCE \textbar{}
  EXTERNAL\PYGZhy{}ADDRESS \textbar{} FACT\PYGZhy{}ADDRESS
\end{sphinxVerbatim}

Using NUMBER for this attribute is equivalent to using both INTEGER and
FLOAT. Using LEXEME for this attribute is equivalent to using both
SYMBOL and STRING. Using INSTANCE for this attribute is equivalent to
using both INSTANCE-NAME and INSTANCE-ADDRESS. ?VARIABLE allows any type
to be stored.


\section{11.2 Allowed Constant Attributes}
\label{\detokenize{constraints:allowed-constant-attributes}}
The allowed constant attributes allow the constant values of a specific
type that can be stored in a slot to be restricted. The list of values
provided should either be a list of constants of the specified type or
the keyword ?VARIABLE which means any constant of that type is allowed.
The allowed-values attribute allows the slot to be restricted to a
specific set of values (encompassing all types). Note the difference
between using the attribute (allowed-symbols red green blue) and
(allowed-values red green blue). The allowed-symbols attribute states
that if the value is of type symbol, then its value must be one of the
listed symbols. The allowed-values attribute completely restricts the
allowed values to the listed values. The allowed-classes attribute does
not restrict the slot value in the same manner as the other allowed
constant attributes. Instead, if this attribute is specified and the
slot value is either an instance address or instance name, then the
class to which the instance belongs must be a class specified in the
allowed-classes attribute or be a subclass of one of the specified
classes.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}allowed\PYGZhy{}constant\PYGZhy{}attribute\PYGZgt{} ::= (allowed\PYGZhy{}symbols?\PYGZlt{}symbol\PYGZhy{}list\PYGZgt{}) \textbar{}
  (allowed\PYGZhy{}strings \PYGZlt{}string\PYGZhy{}list\PYGZgt{}) \textbar{}
  (allowed\PYGZhy{}lexemes \PYGZlt{}lexeme\PYGZhy{}list\PYGZgt{} \textbar{}
  (allowed\PYGZhy{}integers?\PYGZlt{}integer\PYGZhy{}list\PYGZgt{}) \textbar{}
  (allowed\PYGZhy{}floats?\PYGZlt{}float\PYGZhy{}list\PYGZgt{}) \textbar{}
  (allowed\PYGZhy{}numbers?\PYGZlt{}number\PYGZhy{}list\PYGZgt{}) \textbar{}
  (allowed\PYGZhy{}instance\PYGZhy{}names \PYGZlt{}instance\PYGZhy{}list\PYGZgt{}) \textbar{}
  (allowed\PYGZhy{}classes \PYGZlt{}class\PYGZhy{}name\PYGZhy{}list\PYGZgt{})
  (allowed\PYGZhy{}values?\PYGZlt{}value\PYGZhy{}list\PYGZgt{})


  \PYGZlt{}symbol\PYGZhy{}list\PYGZgt{} ::= \PYGZlt{}symbol\PYGZgt{}+ \textbar{} ?VARIABLE

  \PYGZlt{}string\PYGZhy{}list\PYGZgt{} ::= \PYGZlt{}string\PYGZgt{}+ \textbar{} ?VARIABLE

  \PYGZlt{}lexeme\PYGZhy{}list\PYGZgt{} ::= \PYGZlt{}lexeme\PYGZgt{}+ \textbar{} ?VARIABLE

  \PYGZlt{}integer\PYGZhy{}list\PYGZgt{} ::= \PYGZlt{}integer\PYGZgt{}+ \textbar{} ?VARIABLE

  \PYGZlt{}float\PYGZhy{}list\PYGZgt{} ::= \PYGZlt{}float\PYGZgt{}+ \textbar{} ?VARIABLE

  \PYGZlt{}number\PYGZhy{}list\PYGZgt{} ::= \PYGZlt{}number\PYGZgt{}+ \textbar{} ?VARIABLE

  \PYGZlt{}instance\PYGZhy{}name\PYGZhy{}list\PYGZgt{} ::= \PYGZlt{}instance\PYGZhy{}name\PYGZgt{}+ \textbar{} ?VARIABLE

  \PYGZlt{}class\PYGZhy{}name\PYGZhy{}list\PYGZgt{} ::= \PYGZlt{}class\PYGZhy{}name\PYGZgt{}+ \textbar{} ?VARIABLE

  \PYGZlt{}value\PYGZhy{}list\PYGZgt{} ::= \PYGZlt{}constant\PYGZgt{}+ \textbar{} ?VARIABLE
\end{sphinxVerbatim}

Specifying the allowed-lexemes attribute is equivalent to specifying
constant restrictions on both symbols and strings. A string or symbol
must match one of the constants in the attribute list. Type conversion
from symbols to strings and strings to symbols is not performed.
Similarly, specifying the allowed-numbers attribute is equivalent to
specifying constant restrictions on both integers and floats. In CLIPS
5.1, type conversion of integers to floats and floats to integers was
performed when using the allowed-numbers attribute (thus using
allowed-numbers was not equivalent to using both the allowed-integers
and allowed-floats attributes together). In CLIPS 6.0, this type
conversion is no longer performed. The allowed-instances attribute found
in CLIPS 5.1 is no longer supported. The allowed-instance-names
attribute should be used in its place.


\section{11.3 Range Attribute}
\label{\detokenize{constraints:range-attribute}}
The range attribute allows a numeric range to be specified for a slot
when a numeric value is used in that slot. If a numeric value is not
used in that slot, then no checking is performed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}range\PYGZhy{}attribute\PYGZgt{} ::= (range \PYGZlt{}range\PYGZhy{}specification\PYGZgt{} \PYGZlt{}range\PYGZhy{}specification\PYGZgt{})

\PYGZlt{}range\PYGZhy{}specification\PYGZgt{} ::= \PYGZlt{}number\PYGZgt{} \textbar{} ?VARIABLE
\end{sphinxVerbatim}

Either integers or floats can be used in the range specification with
the first value to the range attribute signifying the minimum allowed
value and the second value signifying the maximum value. Integers will
be temporarily converted to floats when necessary to perform range
comparisons. If the keyword ?VARIABLE is used for the minimum value,
then the minimum value is negative infinity (-8). If the keyword
?VARIABLE is used for the maximum value, then the maximum value is
positive infinity (+8). The range attribute cannot be used in
conjunction with the allowed-values, allowed-numbers, allowed-integers,
or allowed-floats attributes.


\section{11.4 Cardinality Attribute}
\label{\detokenize{constraints:cardinality-attribute}}
The cardinality attribute restricts the number of fields that can be
stored in a multifield slot. This attribute can not be used with a
single field slot.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}cardinality\PYGZhy{}attribute\PYGZgt{} ::= (cardinality \PYGZlt{}cardinality\PYGZhy{}specification\PYGZgt{}
                                \PYGZlt{}cardinality\PYGZhy{}specification\PYGZgt{})

\PYGZlt{}cardinality\PYGZhy{}specification\PYGZgt{} ::= \PYGZlt{}integer\PYGZgt{} \textbar{} ?VARIABLE
\end{sphinxVerbatim}

Only integers can be used in the cardinality specification with the
first value to the cardinality attribute signifying the minimum number
of fields that can be stored in the slot and the second value signifying
the maximum number of fields which can be stored in the slot. If the
keyword ?VARIABLE is used for the minimum value, then the minimum
cardinality is zero. If the keyword ?VARIABLE is used for the maximum
value, then the maximum cardinality is positive infinity (+8). If the
cardinality is not specified for a multifield slot, then it is assumed
to be zero to infinity.

The min-number-of-elements and max-number-of-elements attributes found
in CLIPS 5.1 are no longer supported. The cardinality attribute should
be used in their place.


\section{11.5 Deriving a Default Value From Constraints}
\label{\detokenize{constraints:deriving-a-default-value-from-constraints}}
Default values for deftemplate and instance slots are automatically
derived from the constraints for the slots if an explicit default value
is not specified. The following rules are used (in order) to determine
the default value for a slot with an unspecified default value.

1) The default type for the slot is chosen from the list of allowed
types for the slot in the following order of precedence: SYMBOL, STRING,
INTEGER, FLOAT, INSTANCE-NAME, INSTANCE-ADDRESS, FACT-ADDRESS,
EXTERNAL-ADDRESS.

2) If the default type has an allowed constant restriction specified
(such as the allowed-integers attribute for the INTEGER type), then the
first value specified in the allowed constant attribute is chosen as the
default value.

3) If the default value was not specified by step 2 and the default type
is INTEGER or FLOAT and the range attribute is specified, then the
minimum range value is used as the default value if it is not ?VARIABLE,
otherwise, the maximum range value is used if it is not ?VARIABLE.

4) If the default value was not specified by step 2 or 3, then the
default default value is used. This value is nil for type SYMBOL, “” for
type STRING, 0 for type INTEGER, 0.0 for type FLOAT, {[}nil{]} for type
INSTANCE-NAME, a pointer to a dummy instance for type INSTANCE-ADDRESS,
a pointer to a dummy fact for type FACT-ADDRESS, and the NULL pointer
for type EXTERNAL-ADDRESS.

5) If the default value is being derived for a single field slot, then
the default value derived from steps 1 through 4 is used. The default
value for a multifield slot is a multifield value of length zero.
However, if the multifield slot has a minimum cardinality greater than
zero, then a multifield value with a length of the minimum cardinality
is created and the default value that would be used for a single field
slot is stored in each field of the multifield value.


\section{11.6 Constraint Violation Examples}
\label{\detokenize{constraints:constraint-violation-examples}}
The following examples illustrate some of the types of constraint
violations that CLIPS can detect.

Example 1

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{}
(deftemplate bar
(slot a (type SYMBOL INTEGER))
(slot b (type INTEGER FLOAT))
(slot c (type SYMBOL STRING)))
CLIPS\PYGZgt{}
(defrule error
(bar (a ?x))
(bar (b ?x))
(bar (c ?x))
=\PYGZgt{})
[RULECSTR1] Variable ?x in CE \PYGZsh{}3 slot c
has constraint conflicts which make the pattern unmatchable
ERROR:
(defrule MAIN::error\PYGZhy{}4
(bar (a ?x))
(bar (b ?x))
(bar (c ?x))
=\PYGZgt{})
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

The first occurrence of the variable ?x in slot a of the first pattern
restricts its allowed types to either a symbol or integer. The second
occurrence of ?x in slot b of the second pattern further restricts its
allowed types to only integers. The final occurence of ?x in the third
pattern generates an error because slot c expects ?x to be either a
symbol or a string, but its only allowed type is an integer.

Example 2

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{}
(deftemplate foo (multislot x (cardinality ?VARIABLE 2)))
CLIPS\PYGZgt{}
(deftemplate bar (multislot y (cardinality ?VARIABLE 3)))
CLIPS\PYGZgt{}
(deftemplate woz (multislot z (cardinality 7 ?VARIABLE)))
CLIPS\PYGZgt{}
(defrule MAIN::error
(foo (x \PYGZdl{}?x))
(bar (y \PYGZdl{}?y))
(woz (z \PYGZdl{}?x \PYGZdl{}?y))
=\PYGZgt{})
[CSTRNCHK1] The group of restrictions found in CE \PYGZsh{}3
do not satisfy the cardinality restrictions for slot z
ERROR:
(defrule MAIN::error
(foo (x \PYGZdl{}?x))
(bar (y \PYGZdl{}?y))
(woz (z \PYGZdl{}?x \PYGZdl{}?y))
=\PYGZgt{})
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

The variable ?x, found in the first pattern, can have a maximum of two
fields. The variable ?y, found in the second pattern, can have a maximum
of three fields. Added together, both variables have a maximum of five
fields. Since slot z in the the third pattern has a minimum cardinality
of seven, the variables ?x and ?y cannot satisfy the minimum cardinality
restriction for this slot.

Example 3

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (clear)
CLIPS\PYGZgt{} (deftemplate foo (slot x (type SYMBOL)))
CLIPS\PYGZgt{}
(defrule error
(foo (x ?x))
(test (\PYGZgt{} ?x 10))
=\PYGZgt{})
[RULECSTR2] Previous variable bindings of ?x caused the type
restrictions for argument \PYGZsh{}1 of the expression (\PYGZgt{} ?x 10)
found in CE \PYGZsh{}2 to be violated
ERROR:
(defrule MAIN::error
(foo (x ?x))
(test (\PYGZgt{} ?x 10))
=\PYGZgt{})
CLIPS\PYGZgt{}
\end{sphinxVerbatim}

The variable ?x, found in slot x of the first pattern, must be a symbol.
Since the \sphinxstylestrong{\textgreater{}} function expects numeric values for its arguments, an
error occurs.

\phantomsection\label{\detokenize{constraints:section-9}}

\chapter{Section 12: Actions And Functions}
\label{\detokenize{actions:section-12-actions-and-functions}}\label{\detokenize{actions::doc}}
This section describes various actions and functions which may be used
on the LHS and RHS of rules, from the top-level command prompt, and from
other constructs such as deffunctions, defmessage-handlers, and
defmethods. The terms functions, actions, and commands should be thought
of interchangeably. However, when the term \sphinxstylestrong{function} is used it
generally refers to a function that returns a value. The term \sphinxstylestrong{action}
refers to a function having no return value but performing some basic
operation as a side effect (such as printout). The term \sphinxstylestrong{command}
refers to functions normally entered at the top-level command prompt
(such as the \sphinxstylestrong{reset} command, which does not return a value, and the
\sphinxstylestrong{set-strategy} command, which does return a value).


\section{12.1 Predicate Functions}
\label{\detokenize{actions:predicate-functions}}
The following functions perform predicate tests.


\subsection{12.1.1 Testing For Numbers}
\label{\detokenize{actions:testing-for-numbers}}
The \sphinxstylestrong{numberp} function returns the symbol TRUE if its argument is a
float or integer, otherwise it returns the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{numberp} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.1.2 Testing For Floats}
\label{\detokenize{actions:testing-for-floats}}
The \sphinxstylestrong{floatp} function returns the symbol TRUE if its argument is a
float, otherwise it returns the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{floatp} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.1.3 Testing For Integers}
\label{\detokenize{actions:testing-for-integers}}
The \sphinxstylestrong{integerp} function returns the symbol TRUE if its argument is an
integer, otherwise it returns the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{integerp} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.1.4 Testing For Strings Or Symbols}
\label{\detokenize{actions:testing-for-strings-or-symbols}}
The \sphinxstylestrong{lexemep} function returns the symbol TRUE if its argument is a
string or symbol, otherwise it returns the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{lexemep} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.1.5 Testing For Strings}
\label{\detokenize{actions:testing-for-strings}}
The \sphinxstylestrong{stringp} function returns the symbol TRUE if its argument is a
string, otherwise it returns the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{stringp} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.1.6 Testing For Symbols}
\label{\detokenize{actions:testing-for-symbols}}
The \sphinxstylestrong{symbolp} function returns the symbol TRUE if its argument is a
symbol, otherwise it returns the symbol FALSE. This function may also be
called using the name \sphinxstylestrong{wordp}.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{symbolp} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.1.7 Testing For Even Numbers}
\label{\detokenize{actions:testing-for-even-numbers}}
The \sphinxstylestrong{evenp} function returns the symbol TRUE if its argument is an
even number, otherwise it returns the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{evenp} \PYG{o}{\PYGZlt{}}\PYG{n}{integer}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.1.8 Testing For Odd Numbers}
\label{\detokenize{actions:testing-for-odd-numbers}}
The \sphinxstylestrong{oddp} function returns the symbol TRUE if its argument is an odd
number, otherwise it returns the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{oddp} \PYG{o}{\PYGZlt{}}\PYG{n}{integer}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.1.9 Testing For Multifield Values}
\label{\detokenize{actions:testing-for-multifield-values}}
The \sphinxstylestrong{multifieldp} function returns the symbol TRUE if its argument is
a multifield value, otherwise it returns the symbol FALSE. This function
may also be called using the name \sphinxstylestrong{sequencep}.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{multifieldp} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.1.10 Testing For External-Addresses}
\label{\detokenize{actions:testing-for-external-addresses}}
The \sphinxstylestrong{pointerp} function returns the symbol TRUE if its argument is an
external-address, otherwise it returns the symbol FALSE.
External-address;es are discussed in further detail in the \sphinxstyleemphasis{Advanced
Programming Guide}.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{pointerp} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.1.11 Comparing for Equality}
\label{\detokenize{actions:comparing-for-equality}}
The \sphinxstylestrong{eq} function returns the symbol TRUE if its first argument is
equal in value to all its subsequent arguments, otherwise it returns the
symbol FALSE. Note that \sphinxstylestrong{eq} compares types as well as values. Thus,
(eq 3 3.0) is FALSE since 3 is an integer and 3.0 is a float.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{eq} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{Example}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{eq} \PYG{n}{foo} \PYG{n}{bar} \PYG{n}{mumble} \PYG{n}{foo}\PYG{p}{)}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{eq} \PYG{n}{foo} \PYG{n}{foo} \PYG{n}{foo} \PYG{n}{foo}\PYG{p}{)}
\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{eq} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{12.1.12 Comparing for Inequality}
\label{\detokenize{actions:comparing-for-inequality}}
The \sphinxstylestrong{neq} function returns the symbol TRUE if its first argument is
not equal in value to all its subsequent arguments, otherwise it returns
the symbol FALSE. Note that \sphinxstylestrong{neq} compares types as well as values.
Thus, (neq 3 3.0) is TRUE since 3 is an integer and 3.0 is a float.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{neq} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{Example}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{neq} \PYG{n}{foo} \PYG{n}{bar} \PYG{n}{yak} \PYG{n}{bar}\PYG{p}{)}

\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{neq} \PYG{n}{foo} \PYG{n}{foo} \PYG{n}{yak} \PYG{n}{bar}\PYG{p}{)}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{neq} \PYG{l+m+mi}{3} \PYG{n}{a}\PYG{p}{)}
\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{12.1.13 Comparing Numbers for Equality}
\label{\detokenize{actions:comparing-numbers-for-equality}}
The \sphinxstylestrong{=} function returns the symbol TRUE if its first argument is
equal in value to all its subsequent arguments, otherwise it returns the
symbol FALSE. Note that \sphinxstylestrong{=} compares only numeric values and will
convert integers to floats when necessary for comparison.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (= 3 3.0)
TRUE
CLIPS\PYGZgt{} (= 4 4.1)
FALSE
CLIPS\PYGZgt{}
? Portability Note
\end{sphinxVerbatim}

Because the precision of floating point numbers varies from one machine
to another, it is possible for the numeric comparison functions to work
correctly one machine and incorrectly on another. In fact, you should be
aware, even if code is not being ported, that roundoff error can cause
erroneous results. For example, the following expression erroneously
returns the symbol TRUE because both numbers are rounded up to
0.6666666666666666667.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{=} \PYG{l+m+mf}{0.66666666666666666666} \PYG{l+m+mf}{0.66666666666666666667}\PYG{p}{)}
\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{12.1.14 Comparing Numbers for Inequality}
\label{\detokenize{actions:comparing-numbers-for-inequality}}
The \sphinxstylestrong{\textless{}\textgreater{}} function returns the symbol TRUE if its first argument is not
equal in value to all its subsequent arguments, otherwise it returns the
symbol FALSE. Note that \sphinxstylestrong{\textless{}\textgreater{}} compares only numeric values and will
convert integers to floats when necessary for comparison.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{3} \PYG{l+m+mf}{3.0}\PYG{p}{)}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{4} \PYG{l+m+mf}{4.1}\PYG{p}{)}
\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Portability Note

See portability note in section 12.1.13.


\subsection{12.1.15 Greater Than Comparison}
\label{\detokenize{actions:greater-than-comparison}}
The \sphinxstylestrong{\textgreater{}} function returns the symbol TRUE if for all its arguments,
argument n-1 is greater than argument n, otherwise it returns the symbol
FALSE. Note that \sphinxstylestrong{\textgreater{}} compares only numeric values and will convert
integers to floats when necessary for comparison.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{5} \PYG{l+m+mi}{4} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{5} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Portability Note

See portability note in section 12.1.13.


\subsection{12.1.16 Greater Than or Equal Comparison}
\label{\detokenize{actions:greater-than-or-equal-comparison}}
The \sphinxstylestrong{\textgreater{}=} function returns the symbol TRUE if for all its arguments,
argument n-1 is greater than or equal to argument n, otherwise it
returns the symbol FALSE. Note that \sphinxstylestrong{\textgreater{}=} compares only numeric values
and will convert integers to floats when necessary for comparison.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\PYG{n}{Example}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{5} \PYG{l+m+mi}{5} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{5} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Portability Note

See portability note in section 12.1.13.


\subsection{12.1.17 Less Than Comparison}
\label{\detokenize{actions:less-than-comparison}}
The \sphinxstylestrong{\textless{}} function returns the symbol TRUE if for all its arguments,
argument n-1 is less than argument n, otherwise it returns the symbol
FALSE. Note that \sphinxstylestrong{\textless{}} compares only numeric values and will convert
integers to floats when necessary for comparison.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\PYG{n}{Example}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Portability Note

See portability note in section 12.1.13.


\subsection{12.1.18 Less Than or Equal Comparison}
\label{\detokenize{actions:less-than-or-equal-comparison}}
The \sphinxstylestrong{\textless{}=} function returns the symbol TRUE if for all its arguments,
argument n-1 is less than or equal to argument n, otherwise it returns
the symbol FALSE. Note that \sphinxstylestrong{\textless{}=} compares only numeric values and will
convert integers to floats when necessary for comparison.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{TRUE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{5} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{FALSE}
\PYG{n}{CLIPS}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Portability Note

See portability note in section 12.1.13.


\subsection{12.1.19 Boolean And}
\label{\detokenize{actions:boolean-and}}
The \sphinxstylestrong{and} function returns the symbol TRUE if each of its arguments
evaluates to TRUE, otherwise it returns the symbol FALSE. The \sphinxstylestrong{and}
function performs short-circuited boolean logic. Each argument of the
function is evaluated from left to right. If any argument evaluates to
FALSE, then the symbol FALSE is immediately returned by the function.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o+ow}{and} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.1.20 Boolean Or}
\label{\detokenize{actions:boolean-or}}
The \sphinxstylestrong{or} function returns the symbol TRUE if any of its arguments
evaluates to TRUE, otherwise it returns the symbol FALSE. The \sphinxstylestrong{or}
function performs short-circuited boolean logic. Each argument of the
function is evaluated from left to right. If any argument evaluates to
TRUE, then the symbol TRUE is immediately returned by the function.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o+ow}{or} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.1.21 Boolean Not}
\label{\detokenize{actions:boolean-not}}
The \sphinxstylestrong{not} function returns the symbol TRUE if its argument evaluates
to FALSE, otherwise it returns the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o+ow}{not} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\section{12.2 Multifield Functions}
\label{\detokenize{actions:multifield-functions}}
The following functions operate on multifield values.


\subsection{12.2.1 Creating Multifield Values}
\label{\detokenize{actions:creating-multifield-values}}
This function appends any number of fields together to create a
multifield value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(create\PYGZdl{} \PYGZlt{}expression\PYGZgt{}*)
\end{sphinxVerbatim}

The return value of \sphinxstylestrong{create\$} is a multifield value regardless of the
number or types of arguments (single-field or multifield). Calling
\sphinxstylestrong{create\$} with no arguments creates a multifield value of length zero.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS (create\PYGZdl{} hammer drill saw screw pliers wrench)
(hammer drill saw screw pliers wrench)
CLIPS\PYGZgt{} (create\PYGZdl{} (+ 3 4) (\PYGZbs{}* 2 3) (/ 8 4))
(7 6 2.0)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.2 Specifying an Element}
\label{\detokenize{actions:specifying-an-element}}
The \sphinxstylestrong{nth\$} function will return a specified field from a multifield
value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(nth\PYGZdl{} \PYGZlt{}integer\PYGZhy{}expression\PYGZgt{} \PYGZlt{}multifield\PYGZhy{}expression\PYGZgt{})
\end{sphinxVerbatim}

where the first argument should be an integer from 1 to the number of
elements within the second argument. The symbol \sphinxstylestrong{nil} will be returned
if the first argument is greater than the number of fields in the second
argument.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (nth\PYGZdl{} 3 (create\PYGZdl{} a b c d e f g))
c
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.3 Finding an Element}
\label{\detokenize{actions:finding-an-element}}
The \sphinxstylestrong{member\$}?function will tell if a single field value is contained
in a multifield value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(member\PYGZdl{} \PYGZlt{}expression\PYGZgt{} \PYGZlt{}multifield\PYGZhy{}expression\PYGZgt{})
\end{sphinxVerbatim}

If the first argument is a single field value and is one of the fields
within the second argument, \sphinxstylestrong{member\$} will return the integer position
of the field (from 1 to the length of the second argument). If the first
argument is a multifield value and this value is embedded in the second
argument, then the return value is a two field multifield value
consisting of the starting and ending integer indices of the first
argument within the second argument. If neither of these situations is
satisfied, then FALSE is returned.

Example
\begin{quote}

CLIPS\textgreater{} (member\$ blue (create\$ red 3 “text” 8.7 blue))
5
CLIPS\textgreater{} (member\$ 4 (create\$ red 3 “text” 8.7 blue))
FALSE
CLIPS\textgreater{} (member\$ (create\$ b c) (create\$ a b c d))
(2 3)
CLIPS\textgreater{}
\end{quote}


\subsection{12.2.4 Comparing Multifield Values}
\label{\detokenize{actions:comparing-multifield-values}}
This function checks if one multifield value is a subset of another;
i.e., if all the fields in the first multifield value are also in the
second multifield value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{subsetp} \PYG{o}{\PYGZlt{}}\PYG{n}{multifield}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{multifield}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

If the first argument is a subset of the second argument, the function
returns TRUE; otherwise, it returns FALSE. The order of the fields is
not consi?dered. If the first argument is bound to a multifield of
length zero, the \sphinxstylestrong{subsetp} function always returns TRUE.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (subsetp (create\PYGZdl{} hammer saw drill)
(create\PYGZdl{} hammer drill wrench pliers saw))
TRUE
CLIPS\PYGZgt{} (subsetp (create\PYGZdl{} wrench crowbar)
(create\PYGZdl{} hammer drill wrench pliers saw))
FALSE
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.5 Deletion of Fields in Multifield Values}
\label{\detokenize{actions:deletion-of-fields-in-multifield-values}}
This function deletes the specified range from a multifield value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(delete\PYGZdl{} \PYGZlt{}multifield\PYGZhy{}expression\PYGZgt{}
  \PYGZlt{}begin\PYGZhy{}integer\PYGZhy{}expression\PYGZgt{}
  \PYGZlt{}end\PYGZhy{}integer\PYGZhy{}expression\PYGZgt{})
\end{sphinxVerbatim}

The modified multifield value is returned, which is the same as
\textless{}multifield-expression\textgreater{} with the fields ranging from
\textless{}begin-integer-expression\textgreater{} to \textless{}end-integer-expression\textgreater{} removed. To
delete a single field, the begin range field should equal the end range
field.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (delete\PYGZdl{} (create\PYGZdl{} hammer drill saw pliers wrench) 3 4)
(hammer drill wrench)
CLIPS\PYGZgt{} (delete\PYGZdl{} (create\PYGZdl{} computer printer hard\PYGZhy{}disk) 1 1)
(printer hard\PYGZhy{}disk)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.6 Creating Multifield Values from Strings.}
\label{\detokenize{actions:creating-multifield-values-from-strings}}
This function constructs a multifield value from a string by using each
field in a string as a field in a new multifield value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(explode\PYGZdl{} \PYGZlt{}string\PYGZhy{}expression\PYGZgt{})
\end{sphinxVerbatim}

A new multifield value is created in which each delimited field in order
in \textless{}string-expression\textgreater{} is taken to be a field in the new multifield
value that is returned. A string with no fields creates a multifield
value of length zero. Fields other than symbols, strings, integer,
floats, or instances names (such as parentheses or variables) are
converted to strings.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (explode\PYGZdl{} \PYGZdq{}hammer drill saw screw\PYGZdq{})
(hammer drill saw screw)
CLIPS\PYGZgt{} (explode\PYGZdl{} \PYGZdq{}1 2 abc 3 4 \PYGZbs{}\PYGZbs{}\PYGZdq{}abc\PYGZbs{}\PYGZdq{} \PYGZbs{}\PYGZbs{}\PYGZdq{}def\PYGZbs{}\PYGZdq{}\PYGZdq{})
(1 2 abc 3 4 \PYGZdq{}abc\PYGZdq{} \PYGZdq{}def\PYGZdq{})
CLIPS\PYGZgt{} (explode\PYGZdl{} \PYGZdq{}?x \PYGZti{} )\PYGZdq{})
(\PYGZdq{}?x\PYGZdq{} \PYGZdq{}\PYGZti{}\PYGZdq{} \PYGZdq{})\PYGZdq{})
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.7 Creating Strings from Multifield Values}
\label{\detokenize{actions:creating-strings-from-multifield-values}}
This function creates a single string from a multifield value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(implode\PYGZdl{} \PYGZlt{}multifield\PYGZhy{}expression\PYGZgt{})
\end{sphinxVerbatim}

Each field in \textless{}multifield-expression\textgreater{} in order is concatenated into a
string value with a single blank sepa?rating fields. The new string is
returned.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (implode\PYGZdl{} (create\PYGZdl{} hammer drill screwdriver))
\PYGZdq{}hammer drill screwdriver\PYGZdq{}
CLIPS\PYGZgt{} (implode\PYGZdl{} (create\PYGZdl{} 1 \PYGZdq{}abc\PYGZdq{} def \PYGZdq{}ghi\PYGZdq{} 2))
\PYGZdq{}1 \PYGZdq{}abc\PYGZdq{} def \PYGZdq{}ghi\PYGZdq{} 2\PYGZdq{}
CLIPS\PYGZgt{} (implode\PYGZdl{} (create\PYGZdl{} \PYGZdq{}abc def ghi\PYGZdq{}))
\PYGZdq{}\PYGZdq{}abc def ghi\PYGZdq{}\PYGZdq{}
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.8 Extracting a Sub-sequence from a Multifield Value}
\label{\detokenize{actions:extracting-a-sub-sequence-from-a-multifield-value}}
This function extracts a specified range from a multifield value and
returns a new mul?tifield value containing just the sub-sequence.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(subseq\PYGZdl{} \PYGZlt{}multifield\PYGZhy{}value\PYGZgt{}
  \PYGZlt{}begin\PYGZhy{}integer\PYGZhy{}expression\PYGZgt{}
  \PYGZlt{}end\PYGZhy{}integer\PYGZhy{}expression\PYGZgt{})
\end{sphinxVerbatim}

where the second and third arguments are integers specifying the begin
and end fields of the desired sub-sequence in \textless{}multifield-expression\textgreater{}.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (subseq\PYGZdl{} (create\PYGZdl{} hammer drill wrench pliers) 3 4)
(wrench pliers)
CLIPS\PYGZgt{} (subseq\PYGZdl{} (create\PYGZdl{} 1 \PYGZdq{}abc\PYGZdq{} def \PYGZdq{}ghi\PYGZdq{} 2) 1 1)
(1)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.9 Replacing Fields within a Multifield Value}
\label{\detokenize{actions:replacing-fields-within-a-multifield-value}}
This function replaces a range of field in a multifield value with a
series of single-field and/or multifield values and returns a new
mul?tifield value containing the replacement values within the original
multifield value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  (replace\PYGZdl{} \PYGZlt{}multifield\PYGZhy{}expression\PYGZgt{}
\PYGZlt{}begin\PYGZhy{}integer\PYGZhy{}expression\PYGZgt{}
    \PYGZlt{}end\PYGZhy{}integer\PYGZhy{}expression\PYGZgt{}
    \PYGZlt{}single\PYGZhy{}or\PYGZhy{}multi\PYGZhy{}field\PYGZhy{}expression\PYGZgt{}+)
\end{sphinxVerbatim}

where \textless{}begin-integer-expression\textgreater{} to \textless{}end-integer-expression\textgreater{} is the
range of values to be replaced.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (replace\PYGZdl{} (create\PYGZdl{} drill wrench pliers) 3 3 machete)
(drill wrench machete)
CLIPS\PYGZgt{} (replace\PYGZdl{} (create\PYGZdl{} a b c d) 2 3 x y (create\PYGZdl{} q r s))
(a x y q r s d)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.10 Inserting Fields within a Multifield Value}
\label{\detokenize{actions:inserting-fields-within-a-multifield-value}}
This function inserts a series of single-field and/or multifield values
at a specified location in a multifield value with and returns a new
mul?tifield value containing the inserted values within the original
multifield value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(insert\PYGZdl{} \PYGZlt{}multifield\PYGZhy{}expression\PYGZgt{}
  \PYGZlt{}integer\PYGZhy{}expression\PYGZgt{}
  \PYGZlt{}single\PYGZhy{}or\PYGZhy{}multi\PYGZhy{}field\PYGZhy{}expression\PYGZgt{}+)
\end{sphinxVerbatim}

where \textless{}integer-expression\textgreater{} is the location where the values are to be
inserted. This value must be greater than or equal to 1. A value of 1
inserts the new value(s) at the beginning of the
\textless{}multifield-expression\textgreater{}. Any value greater than the length of the
\textless{}multifield-expression\textgreater{} appends the new values to the end of the
\textless{}multifield-expression\textgreater{}.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (insert\PYGZdl{} (create\PYGZdl{} a b c d) 1 x)
(x a b c d)
CLIPS\PYGZgt{} (insert\PYGZdl{} (create\PYGZdl{} a b c d) 4 y z)
(a b c y z d)
CLIPS\PYGZgt{} (insert\PYGZdl{} (create\PYGZdl{} a b c d) 5 (create\PYGZdl{} q r))
(a b c d q r)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.11 Getting the First Field from a Multifield Value}
\label{\detokenize{actions:getting-the-first-field-from-a-multifield-value}}
This function returns the first field of a multifield value as a
multifield value

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(first\PYGZdl{} \PYGZlt{}multifield\PYGZhy{}expression\PYGZgt{})
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (first\PYGZdl{} (create\PYGZdl{} a b c))
(a)
CLIPS\PYGZgt{} (first\PYGZdl{} (create\PYGZdl{}))
()
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.12 Getting All but the First Field from a Multifield Value}
\label{\detokenize{actions:getting-all-but-the-first-field-from-a-multifield-value}}
This function returns all but the first field of a multifield value as a
multifield value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(rest\PYGZdl{} \PYGZlt{}multifield\PYGZhy{}expression\PYGZgt{})
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (rest\PYGZdl{} (create\PYGZdl{} a b c))
(b c)
CLIPS\PYGZgt{} (rest\PYGZdl{} (create\PYGZdl{}))
()
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.13 Determining the Number of Fields in a Multifield Value}
\label{\detokenize{actions:determining-the-number-of-fields-in-a-multifield-value}}
The \sphinxstylestrong{length\$} function returns an integer indicating the number of
fields contained in a multifield value. If the argument passed to
\sphinxstylestrong{length\$} is not the appropriate type, a negative one (-1) is
returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(length\PYGZdl{} \PYGZlt{}multifield\PYGZhy{}expression\PYGZgt{})
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (length\PYGZdl{} (create\PYGZdl{} a b c d e f g))
7
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.14 Deleting Specific Values within a Multifield Value}
\label{\detokenize{actions:deleting-specific-values-within-a-multifield-value}}
This function deletes specific values contained within a multifield
value and returns the modified multifield value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(delete\PYGZhy{}member\PYGZdl{} \PYGZlt{}multifield\PYGZhy{}expression\PYGZgt{} \PYGZlt{}expression\PYGZgt{}+)
\end{sphinxVerbatim}

where \textless{}expression\textgreater{}+ is one or more values to be deleted from
\textless{}multifield-expression\textgreater{}. If \textless{}expression\textgreater{} is a multifield value, the
entire sequence must be contained within the first argument in the
correct order.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (delete\PYGZhy{}member\PYGZdl{} (create\PYGZdl{} a b a c) b a)
(c)
CLIPS\PYGZgt{} (delete\PYGZhy{}member\PYGZdl{} (create\PYGZdl{} a b c c b a) (create\PYGZdl{} b a))
(a b c c)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\subsection{12.2.15 Replacing Specific Values within a Multifield Value}
\label{\detokenize{actions:replacing-specific-values-within-a-multifield-value}}
This function replaces specific values contained within a multifield
value and returns the modified multifield value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(replace\PYGZhy{}member\PYGZdl{} \PYGZlt{}multifield\PYGZhy{}expression\PYGZgt{} \PYGZlt{}substitute\PYGZhy{}expression\PYGZgt{}
   \PYGZlt{}search\PYGZhy{}expression\PYGZgt{}+)
\end{sphinxVerbatim}

where any \textless{}search-expression\textgreater{} that is contained within
\textless{}multifield-expression\textgreater{} is replaced by \textless{}substitute-expression\textgreater{}.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CLIPS\PYGZgt{} (replace\PYGZhy{}member\PYGZdl{} (create\PYGZdl{} a b a b) (create\PYGZdl{} a b a) a b)
(a b a a b a a b a a b a)
CLIPS\PYGZgt{} (replace\PYGZhy{}member\PYGZdl{} (create\PYGZdl{} a b a b) (create\PYGZdl{} a b a) (create\PYGZdl{} a b))
(a b a a b a)
CLIPS\PYGZgt{}
\end{sphinxVerbatim}


\section{12.3 String Functions}
\label{\detokenize{actions:string-functions}}
The following functions perform operations that are related to strings.


\subsection{12.3.1 String Concatenation}
\label{\detokenize{actions:string-concatenation}}
The \sphinxstylestrong{str-cat} function will concatenates its arguments into a single
string.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{str}\PYG{o}{\PYGZhy{}}\PYG{n}{cat} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Each \textless{}expression\textgreater{} should be one of the following types: symbol, string,
float, integer, or instance-name.

Example

CLIPS\textgreater{} (str-cat “foo” bar)

“foobar”

CLIPS\textgreater{}


\subsection{12.3.2 Symbol Concatenation}
\label{\detokenize{actions:symbol-concatenation}}
The \sphinxstylestrong{sym-cat} function will concatenate its arguments into a single
symbol. It is functionally identical to the str-cat function with the
exception that the returned value is a symbol and not a string.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{sym}\PYG{o}{\PYGZhy{}}\PYG{n}{cat} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Each \textless{}expression\textgreater{} should be one of the following types: symbol, string,
float, integer, or instance-name.


\subsection{12.3.3 Taking a String Apart}
\label{\detokenize{actions:taking-a-string-apart}}
The \sphinxstylestrong{sub-string} function will retrieve a portion of a string from
another string.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{sub}\PYG{o}{\PYGZhy{}}\PYG{n}{string} \PYG{o}{\PYGZlt{}}\PYG{n}{integer}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{integer}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\textless{}string-expression\textgreater{})

where the first argument, counting from one, must be a number marking
the begin?ning position in the string and the second argument must be a
number marking the ending position in the string. If the first argument
is greater than the second argument, a null string is returned.

Example

CLIPS\textgreater{} (sub-string 3 8 “abcdefghijkl”)

“cdefgh”

CLIPS\textgreater{}


\subsection{12.3.4 Searching a String}
\label{\detokenize{actions:searching-a-string}}
The \sphinxstylestrong{str-index} function will return the position of a string inside
another string.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{str}\PYG{o}{\PYGZhy{}}\PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{n}{lexeme}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{lexeme}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

where the second argument is searched for the first occurrence of the
first argument. The \sphinxstylestrong{str-index} function re?turns the integer starting
position, counting from one, of the first argument in the second
argument or returns the symbol FALSE if not found.

Example

CLIPS\textgreater{} (str-index “def” “abcdefghi”)

4

CLIPS\textgreater{} (str-index “qwerty” “qwertypoiuyt”)

1

CLIPS\textgreater{} (str-index “qwerty” “poiuytqwer”)

FALSE

CLIPS\textgreater{}


\subsection{12.3.5 Evaluating a Function within a String}
\label{\detokenize{actions:evaluating-a-function-within-a-string}}
The \sphinxstylestrong{eval} function evaluates the string as though it were entered at
the command prompt.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{eval} \PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{symbol}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

where the only argument is the command, constant, or global variable to
be executed. NOTE: \sphinxstylestrong{eval} does not permit the use of local variables
(except when the local variables are defined as part of the command such
as with an instance query function), nor will it evaluate any of the
construct definition forms (i.e., \sphinxstylestrong{defrule}, \sphinxstylestrong{deffacts}, etc.;). The
return value is the result of the evaluation of the string (or FALSE if
an error occurs).

The \sphinxstylestrong{eval} function is not available for binary-load only or run-time
CLIPS configurations (see the \sphinxstyleemphasis{Advanced Programming Guide}).

Example

CLIPS\textgreater{} (eval “(+ 3 4)”)

7

CLIPS\textgreater{} (eval “(create\$ a b c)”)

(a b c)

CLIPS\textgreater{}


\subsection{12.3.6 Evaluating a Construct within a String}
\label{\detokenize{actions:evaluating-a-construct-within-a-string}}
The \sphinxstylestrong{build} function evaluates the string as though it were entered at
the command prompt.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{build} \PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{symbol}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

where the only argument is the construct to be added. The return value
is TRUE if the construct was added (or FALSE if an error occurs).

The \sphinxstylestrong{build} function is not available for binary-load only or run-time
CLIPS configurations (see the \sphinxstyleemphasis{Advanced Programming Guide}).

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (build “(defrule foo (a) =\textgreater{} (assert (b)))”)

TRUE

CLIPS\textgreater{} (rules)

foo

For a total of 1 rule.

CLIPS\textgreater{}


\subsection{12.3.7 Converting a String to Uppercase}
\label{\detokenize{actions:converting-a-string-to-uppercase}}
The \sphinxstylestrong{upcase} function will return a string or symbol with uppercase
alphabetic characters.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{upcase} \PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{symbol}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (upcase “This is a test of upcase”)

“THIS IS A TEST OF UPCASE”

CLIPS\textgreater{} (upcase A\_Word\_Test\_for\_Upcase)

A\_WORD\_TEST\_FOR\_UPCASE

CLIPS\textgreater{}


\subsection{12.3.8 Converting a String to Lowercase}
\label{\detokenize{actions:converting-a-string-to-lowercase}}
The \sphinxstylestrong{lowcase} function will return a string or symbol with lowercase
alphabetic characters.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{lowcase} \PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{symbol}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (lowcase “This is a test of lowcase”)

“this is a test of lowcase”

CLIPS\textgreater{} (lowcase A\_Word\_Test\_for\_Lowcase)

a\_word\_test\_for\_lowcase

CLIPS\textgreater{}


\subsection{12.3.9 Comparing Two Strings}
\label{\detokenize{actions:comparing-two-strings}}
The \sphinxstylestrong{str-compare} function will compare two strings to determine their
logical relationship (i.e., equal to, less than, greater than). The
comparison is performed character-by-character until the strings are
exhausted (implying equal strings) or un?equal characters are found. The
positions of the unequal characters within the ASCII character set are
used to determine the logical relationship of unequal strings.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{str}\PYG{o}{\PYGZhy{}}\PYG{n}{compare} \PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{symbol}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\textless{}string-or-symbol-expression\textgreater{})

This function returns an integer representing the result of the
comparison (0 if the strings are equal, \textless{} 0 if the first argument \textless{} the
second argument, and \textgreater{} 0 if the first argument \textgreater{} the second argument).

Example

CLIPS\textgreater{} (\textless{} (str-compare “string1” “string2”) 0)

TRUE ; since “1” \textless{} “2” in ASCII character set

CLIPS\textgreater{} (str-compare “abcd” “abcd”)

0

CLIPS\textgreater{}


\subsection{12.3.10 Determining the Length of a String}
\label{\detokenize{actions:determining-the-length-of-a-string}}
The \sphinxstylestrong{str-length} function returns the length of a string as an
integer.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{str}\PYG{o}{\PYGZhy{}}\PYG{n}{length} \PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{symbol}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (str-length “abcd”)

4

CLIPS\textgreater{} (str-length xyz)

3

CLIPS\textgreater{}


\subsection{12.3.11 Checking the Syntax of a Construct or Function Call within a String}
\label{\detokenize{actions:checking-the-syntax-of-a-construct-or-function-call-within-a-string}}
The function \sphinxstylestrong{check-syntax} allows the text representation of a
construct or function call to be checked for syntax and semantic errors.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{check}\PYG{o}{\PYGZhy{}}\PYG{n}{syntax} \PYG{o}{\PYGZlt{}}\PYG{n}{construct}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

This function returns FALSE if there are no errors or warnings
encountered parsing the construct or function call. The symbol
MISSING-LEFT-PARENTHESIS is returned if the first token is not a left
parenthesis. The symbol EXTRANEOUS-INPUT-AFTER-LAST-PARENTHESIS is
returned if there are additional tokens after the closing right
parenthesis of the construct or function call. If errors or warnings are
encounted parsing, the a multifield of length two is returned. The first
field of the multifield is a string containing the text of the error
message (or the symbol FALSE if no errors were encountered). The second
field of the multifield is a string containing the text of the warning
message (or the symbol FALSE if no warnings were encountered).

Example

CLIPS\textgreater{} (check-syntax “(defrule example =\textgreater{})”)

FALSE

CLIPS\textgreater{} (check-syntax “(defrule foo (number 40000000000000000000) =\textgreater{})”)

(FALSE “{[}SCANNER1{]} WARNING: Over or underflow of long long integer.

“)

CLIPS\textgreater{} (check-syntax “(defrule example (3) =\textgreater{})”)

(“

{[}PRNTUTIL2{]} Syntax Error: Check appropriate syntax for the first field
of a pattern.

ERROR:

(defrule MAIN::example

(3

” FALSE)

CLIPS\textgreater{}


\subsection{12.3.12 Converting a String to a Field}
\label{\detokenize{actions:converting-a-string-to-a-field}}
The \sphinxstylestrong{string-to-field} function parses a string and converts its
contents to a primitive data type.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{string}\PYG{o}{\PYGZhy{}}\PYG{n}{to}\PYG{o}{\PYGZhy{}}\PYG{n}{field} \PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{symbol}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

where the only argument is the string to be parsed. Essentially calling
\sphinxstylestrong{string-to-field} with its string argument is equivalent to calling
the \sphinxstylestrong{read} function and manually typing the contents of the string
argument or reading it from a file. It is preferable to call
\sphinxstylestrong{string-to-field} rather than \sphinxstylestrong{eval} to convert a string to a
primitive data type since the \sphinxstylestrong{eval} function is not available for
binary-load only or run-time CLIPS configurations (see the \sphinxstyleemphasis{Advanced
Programming Guide}).

Example

CLIPS\textgreater{} (string-to-field “3.4”)

3.4

CLIPS\textgreater{} (string-to-field “a b”)

a

CLIPS\textgreater{}


\section{12.4 The CLIPS I/O System}
\label{\detokenize{actions:the-clips-i-o-system}}
CLIPS uses a system called I/O routers to provide very flexible I/O
while remaining portable. A more complete discussion of I/O routers is
covered in the \sphinxstyleemphasis{Advanced Programming Guide}.


\subsection{12.4.1 Logical Names}
\label{\detokenize{actions:logical-names}}
One of the key concepts of I/O routing is the use of logical names.
Logical names allow reference to an I/O device without having to
understand the details of the imple?mentation of the reference. Many
functions in CLIPS make use of logical names. A logical name can be
either a symbol, a number, or a string. Several logical names are
predefined by CLIPS and are used extensively throughout the CLIPS code.
These are


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Name}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Description}
\\
\hline
stdin
&
The default for all user inputs. The read and readline functions read from stdin if t is specified as the logical name.
\\
\hline
stdout
&
The default for all user output. The printout and format functions write to stdout if t is specified as the logical name.
\\
\hline
wclips
&
The CLIPS prompt is sent to this logical name.
\\
\hline
wdialog
&
All informational messages are sent to this logical name.
\\
\hline
wdisplay
&
Requests to display CLIPS information, such as facts or rules, are sent to this logical name.
\\
\hline
werror
&
All error messages are sent to this logical name.
\\
\hline
wwarning
&
All warning messages are sent to this logical name.
\\
\hline
wtrace
&
All watch information is sent to this logical name (with the exception of compilations which is sent to wdialog).
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Any of these logical names may be used anywhere a logical name is
expected.


\subsection{12.4.2 Common I/O Functions}
\label{\detokenize{actions:common-i-o-functions}}
CLIPS provides some of the most commonly needed I/O capabilities through
several predefined functions.


\subsubsection{12.4.2.1 Open}
\label{\detokenize{actions:open}}
The \sphinxstylestrong{open} function allows a user to open a file from the RHS of a
rule and attaches a logical name to it. This function takes three
arguments: (1) the name of the file to be opened; (2) the logical name
which will be used by other CLIPS I/O functions to ac?cess the file; and
(3) an optional mode specifier. The mode specifier must be one of the
fol?lowing strings:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Mode}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Means}
\\
\hline
r
&
Character read access. Specified file must exist.
\\
\hline
w
&
Character write access. Existing content overwritten.
\\
\hline
a
&
Character write access. Writes append to end of file.
\\
\hline
rb
&
Binary read access. Specified file must exist.
\\
\hline
wb
&
Binary write access. Existing content overwritten.
\\
\hline
ab
&
Binary write access. Writes append to end of file.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

If the mode is not specified, it defaults to character read access.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{open} \PYG{o}{\PYGZlt{}}\PYG{n}{file}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{logical}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{mode}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

The \textless{}file-name\textgreater{} must either be a string or symbol and may include
directory speci?fiers. If a string is used, the backslash () and any
other special characters that are part of \textless{}file-name\textgreater{} must be escaped
with a backslash. The logical name should not have been used previously.
The \sphinxstylestrong{open} function returns TRUE if it was successful, otherwise
FALSE.

Example

CLIPS\textgreater{} (open “myfile.clp” writeFile “w”)

TRUE

CLIPS\textgreater{} (open “MS-DOS/directory/file.clp” readFile)

TRUE

CLIPS\textgreater{}


\subsubsection{12.4.2.2 Close}
\label{\detokenize{actions:close}}
The \sphinxstylestrong{close} function closes a file stream previously opened with the
\sphinxstylestrong{open} com?mand. The file is specified by a logical name previously
attached to the desired stream.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{close} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{logical}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

If \sphinxstylestrong{close} is called without arguments, all open files will be closed.
The user is responsible for closing all files opened during execution.
If files are not closed, the contents are not guaranteed correct,
however, CLIPS will attempt to close all open files when the \sphinxstylestrong{exit}
command is executed. The \sphinxstylestrong{close} function returns TRUE if any files
were successfully closed, otherwise FALSE.

Example

CLIPS\textgreater{} (open “myfile.clp” writeFile “w”)

TRUE

CLIPS\textgreater{} (open “MS-DOS/directory/file.clp” readFile)

TRUE

CLIPS\textgreater{} (close writeFile)

TRUE

CLIPS\textgreater{} (close writeFile)

FALSE

CLIPS\textgreater{} (close)

TRUE

CLIPS\textgreater{} (close)

FALSE

CLIPS\textgreater{}


\subsubsection{12.4.2.3 Printout}
\label{\detokenize{actions:printout}}
The function \sphinxstylestrong{printout} allows output to a device attached to a
logical name. The logical name \sphinxstyleemphasis{must} be specified and the device must
have been prepared previously for output (e.g., a file must be opened
first). To send output to \sphinxstylestrong{stdout}, use a \sphinxstylestrong{t} for the logical name.
If the logical name \sphinxstylestrong{nil} is used, the \sphinxstylestrong{printout} function does
nothing.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{printout} \PYG{o}{\PYGZlt{}}\PYG{n}{logical}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Any number of expressions may be placed in a \sphinxstylestrong{printout} to be printed.
Each expression is evaluated and printed (with no spaces added between
each printed expression). The symbol \sphinxstylestrong{crlf} used as an \textless{}expression\textgreater{}
will force a carriage return/newline and may be placed anywhere in the
list of expressions to be printed. Similarly, the symbols \sphinxstylestrong{tab},
\sphinxstylestrong{vtab}, and \sphinxstylestrong{ff} will print respectively a tab, a vertical tab, and
a form feed. The appearance of these special symbols may vary from one
operating system to another. The printout function strips quotation
marks from around strings when it prints them. Fact-addresses,
instance-addresses and external-addresses can be printed by the printout
function. This function has no return value.

Example

CLIPS\textgreater{} (printout t “Hello there!” crlf)

Hello There!

CLIPS\textgreater{} (open “data.txt” mydata “w”)

TRUE

CLIPS\textgreater{} (printout mydata “red green”)

CLIPS\textgreater{} (close)

TRUE

CLIPS\textgreater{}


\subsubsection{12.4.2.4 Read}
\label{\detokenize{actions:read}}
The \sphinxstylestrong{read} function allows a user to input information for a single
field. All of the stan?dard field rules (e.g., multiple symbols must be
embedded within quotes) apply.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{read} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{logical}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

where \textless{}logical-name\textgreater{} is an optional parameter. If specified, \sphinxstylestrong{read}
tries to read from whatever is attached to the logical file name. If
\textless{}logical-name\textgreater{} is \sphinxstylestrong{t} or is not speci?fied, the function will read
from \sphinxstylestrong{stdin}. All the delimiters defined in section 2.3.1 can be used
as delimiters. The \sphinxstylestrong{read} function always returns a primitive data
type. Spaces, carriage returns, and tabs only act as delimiters and are
not contained within the return value (unless these characters are
included within double quotes as part of a string). If an end of file
(EOF) is encountered while reading, \sphinxstylestrong{read} will return the symbol
\sphinxstylestrong{EOF}. If errors are encountered while reading, the string “\sphinxstylestrong{* READ
ERROR *}” will be returned.

Example

CLIPS\textgreater{} (open “data.txt” mydata “w”)

TRUE

CLIPS\textgreater{} (printout mydata “red green”)

CLIPS\textgreater{} (close)

TRUE

CLIPS\textgreater{} (open “data.txt” mydata)

TRUE

CLIPS\textgreater{} (read mydata)

red

CLIPS\textgreater{} (read mydata)

green

CLIPS\textgreater{} (read mydata)

EOF

CLIPS\textgreater{} (close)

TRUE

CLIPS\textgreater{}


\subsubsection{12.4.2.5 Readline}
\label{\detokenize{actions:readline}}
The \sphinxstylestrong{readline} function is similar to the \sphinxstylestrong{read} function, but it
allows a whole string to be input instead of a single field. Normally,
\sphinxstylestrong{read} will stop when it encounters a delimiter. The \sphinxstylestrong{readline}
function only stops when it encounters a carriage return, a semicolon,
or an EOF. Any tabs or spaces in the input are returned by \sphinxstylestrong{readline}
as a part of the string. The \sphinxstylestrong{readline} function returns a string.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{readline} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{logical}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

where \textless{}logical-name\textgreater{} is an optional parameter. If specified,
\sphinxstylestrong{readline} tries to read from whatever is attached to the logical file
name. If \textless{}logical-name\textgreater{} is \sphinxstylestrong{t} or is not spec?i?fied, the function
will read from \sphinxstylestrong{stdin}. As with the \sphinxstylestrong{read} function, if an EOF is
encountered, \sphinxstylestrong{readline} will return the symbol EOF. If an error is
encountered during input, \sphinxstylestrong{readline} returns the string “\sphinxstylestrong{* READ
ERROR *}”.

Example

CLIPS\textgreater{} (open “data.txt” mydata “w”)

TRUE

CLIPS\textgreater{} (printout mydata “red green”)

CLIPS\textgreater{} (close)

TRUE

CLIPS\textgreater{} (open “data.txt” mydata)

TRUE

CLIPS\textgreater{} (readline mydata)

“red green”

CLIPS\textgreater{} (readline mydata)

EOF

CLIPS\textgreater{} (close)

TRUE

CLIPS\textgreater{}


\subsubsection{12.4.2.6 Format}
\label{\detokenize{actions:format}}
The \sphinxstylestrong{format} function allows a user to send formatted output to a
device attached to a logical name. It can be used in place of
\sphinxstylestrong{printout} when special formatting of out?put information is desired.
Although a slightly more complicated function, \sphinxstylestrong{format} pro?vides much
better control over how the output is formatted. The format commands are
simi?lar to the \sphinxstylestrong{printf} statement in C. The \sphinxstylestrong{format} function
always returns a string containing the formatted output. A logical name
of \sphinxstylestrong{nil} may be used when the formatted return string is desired
without writing to a device.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{format} \PYG{o}{\PYGZlt{}}\PYG{n}{logical}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

If \sphinxstylestrong{t} is given, output is sent to \sphinxstylestrong{stdout}. The second argument to
format, called the control string, specifies how the output should be
formatted. Subsequent arguments to format (the parameter list for the
control string) are the expressions which are to be out?put as indicated
by the control string. \sphinxstylestrong{Format} currently does not allow expressions
returning multifield values to be included in the parameter list.

The control string consists of text and format flags. Text is output
exactly as speci?fied, and format flags describe how each parameter in
the parameter list is to be for?matted. The first format flag
corresponds to the first value in the parameter list, the second flag
corresponds to the second value, etc. The format flags must be preceded
by a percent sign (\%) and are of the general format

\%-M.Nx

where x is one of the flags listed below, the minus sign is an optional
justification flag, and M and N are optional parameters which specify
the field width and the precision argument (which varies in meaning
based on the format flag). If M is used, at least M characters will be
output. If more than M characters are required to display the value,
\sphinxstylestrong{format} expands the field as needed. If M starts with a 0 (e.g.,
\%07d), a zero is used as the pad character; oth?er?wise, spaces are
used. If N is not specified, it defaults to six digits for
floating-point numbers. If a minus sign is included before the M, the
value will be left justified; oth?erwise the value is right justified.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Format Flag}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Meaning}
\\
\hline
c
&
Display parameter as a single character.
\\
\hline
d
&
Display parameter as a long long integer. (The N specifier is the minimum number of digits to be printed.)
\\
\hline
f
&
Display parameter as a floating-point number (The N specifier is the number of digits following the decimal point).
\\
\hline
e
&
Display parameter as a floating-point using power of 10 notation (The N specifier is the number of digits following the decimal point).
\\
\hline
g
&
Display parameter in the most general format, whichever is shorter (the N specifier is the number of significant digits to be printed).
\\
\hline
o
&
Display parameter as an unsigned octal number. (The N specifier is the minimum number of digits to be printed.)
\\
\hline
x
&
Display parameter as an unsigned hexadecimal number. (The N specifier is the minimum number of digits to be printed.)
\\
\hline
s
&
Display parameter as a string. Strings will have the leading and trailing quotes stripped. (The N specifier indicates the maximum number of characters to be printed. Zero also cannot be used for the pad character.)
\\
\hline
n
&
Put a new line in the output.
\\
\hline
r
&
Put a carriage return in the output.
\\
\hline
\%
&
Put the percent character in the output.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Example

CLIPS\textgreater{} (format t “Hello World!\%n”)

Hello World!

“Hello World!

“

CLIPS\textgreater{} (format nil “Integer: \textbar{}\%d\textbar{}” 12)

“Integer: \textbar{}12\textbar{}”

CLIPS\textgreater{} (format nil “Integer: \textbar{}\%4d\textbar{}” 12)

“Integer: \textbar{} 12\textbar{}”

CLIPS\textgreater{} (format nil “Integer: \textbar{}\%-04d\textbar{}” 12)

“Integer: \textbar{}12 \textbar{}”

CLIPS\textgreater{} (format nil “Integer: \textbar{}\%6.4d\textbar{}” 12)

“Integer: \textbar{} 0012\textbar{}”

CLIPS\textgreater{} (format nil “Float: \textbar{}\%f\textbar{}” 12.01)

“Float: \textbar{}12.010000\textbar{}”

CLIPS\textgreater{} (format nil “Float: \textbar{}\%7.2f\textbar{} “12.01)

“Float: \textbar{} 12.01\textbar{} “

CLIPS\textgreater{} (format nil “Test: \textbar{}\%e\textbar{}” 12.01)

“Test: \textbar{}1.201000e+01\textbar{}”

CLIPS\textgreater{} (format nil “Test: \textbar{}\%7.2e\textbar{}” 12.01)

“Test: \textbar{}1.20e+01\textbar{}”

CLIPS\textgreater{} (format nil “General: \textbar{}\%g\textbar{}” 1234567890)

“General: \textbar{}1.23457e+09\textbar{}”

CLIPS\textgreater{} (format nil “General: \textbar{}\%6.3g\textbar{}” 1234567890)

“General: \textbar{}1.23e+09\textbar{}”

CLIPS\textgreater{} (format nil “Hexadecimal: \textbar{}\%x\textbar{}” 12)

“Hexadecimal: \textbar{}c\textbar{}”

CLIPS\textgreater{} (format nil “Octal: \textbar{}\%o\textbar{}” 12)

“Octal: \textbar{}14\textbar{}”

CLIPS\textgreater{} (format nil “Symbols: \textbar{}\%s\textbar{} \textbar{}\%s\textbar{}” value-a1 capacity)

“Symbols: \textbar{}value-a1\textbar{} \textbar{}capacity\textbar{}”

CLIPS\textgreater{}

? Portability Note

The \sphinxstylestrong{format} function uses the C function \sphinxstylestrong{sprintf} as a base. Some
systems may not support \sphinxstylestrong{sprintf} or may not support all of these
features, which may affect how \sphinxstylestrong{format} works.


\subsubsection{12.4.2.7 Rename}
\label{\detokenize{actions:rename}}
The \sphinxstylestrong{rename} function is used to change the name of a file.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{rename} \PYG{o}{\PYGZlt{}}\PYG{n}{old}\PYG{o}{\PYGZhy{}}\PYG{n}{file}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{new}\PYG{o}{\PYGZhy{}}\PYG{n}{file}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Both \textless{}old-file-name\textgreater{} and \textless{}new-file-name\textgreater{} must either be a string or
symbol and may include directory speci?fiers. If a string is used, the
backslash () and any other special characters that are part of either
\textless{}old-file-name\textgreater{} or \textless{}new-file-name\textgreater{} must be escaped with a backslash. The
\sphinxstylestrong{rename} function returns TRUE if it was successful, otherwise FALSE.

? Portability Note

The \sphinxstylestrong{rename} function uses the ANSI C function \sphinxstylestrong{rename} as a base.


\subsubsection{12.4.2.8 Remove}
\label{\detokenize{actions:remove}}
The \sphinxstylestrong{remove} function is used to delete a file.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{remove} \PYG{o}{\PYGZlt{}}\PYG{n}{file}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

The \textless{}file-name\textgreater{} must either be a string or symbol and may include
directory speci?fiers. If a string is used, the backslash () and any
other special characters that are part of \textless{}file-name\textgreater{} must be escaped
with a backslash. The \sphinxstylestrong{remove} function returns TRUE if it was
successful, otherwise FALSE.

? Portability Note

The \sphinxstylestrong{remove} function uses the ANSI C function \sphinxstylestrong{remove} as a base.


\subsubsection{12.4.2.9 Get Character}
\label{\detokenize{actions:get-character}}
The \sphinxstylestrong{get-char} function allows a single character to be retrieved from
a logical name.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{char} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{logical}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

where \textless{}logical-name\textgreater{} is an optional parameter. If specified,
\sphinxstylestrong{get-char} tries to retrieve a character from the specified logical
file name. If \textless{}logical-name\textgreater{} is \sphinxstylestrong{t} or is not speci?fied, the function
will read from \sphinxstylestrong{stdin}. The return value is the integer ASCII value of
the character retrieved. The value of -1 is returned if the end of file
is encountered while retrieving a character.

Example

CLIPS\textgreater{} (open example.txt example “w”)

TRUE

CLIPS\textgreater{} (printout example “ABC” crlf)

CLIPS\textgreater{} (close example)

TRUE

CLIPS\textgreater{} (open example.txt example)

TRUE

CLIPS\textgreater{} (get-char example)

65

CLIPS\textgreater{} (format nil “\%c” (get-char example))

“B”

CLIPS\textgreater{} (get-char example)

67

CLIPS\textgreater{} (get-char example)

10

CLIPS\textgreater{} (get-char example)

-1

CLIPS\textgreater{}

(progn (printout t “Press any character to continue…”)

(get-char t))

Press any character to continue…

13

CLIPS\textgreater{} (close)

TRUE

CLIPS\textgreater{}


\subsubsection{12.4.2.10 Read Number}
\label{\detokenize{actions:read-number}}
The \sphinxstylestrong{read-number} function allows a user to input a single number
using the localized format (if one has been specified using the
set-locale function). If a localized format has not been specified, then
the C format for a number is used.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{read}\PYG{o}{\PYGZhy{}}\PYG{n}{number} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{logical}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

where \textless{}logical-name\textgreater{} is an optional parameter. If specified,
\sphinxstylestrong{read-number} tries to read from whatever is attached to the logical
file name. If \textless{}logical-name\textgreater{} is \sphinxstylestrong{t} or is not speci?fied, the function
will read from \sphinxstylestrong{stdin}. If a number is successfully parsed, the
\sphinxstylestrong{read-number} function will return either an integer (if the number
contained just a sign and digits) or a float (if the number contained
the localized decimal point character or an exponent). If an end of file
(EOF) is encountered while reading, \sphinxstylestrong{read-number} will return the
symbol \sphinxstylestrong{EOF}. If errors are encountered while reading, the string
“\sphinxstylestrong{* READ ERROR *}” will be returned.

Example

CLIPS\textgreater{} (read-number)

34

34

CLIPS\textgreater{} (read-number)

34.0

34.0

CLIPS\textgreater{} (read-number)

23,0

“\sphinxstylestrong{* READ ERROR *}”

CLIPS\textgreater{}


\subsubsection{12.4.2.11 Set Locale}
\label{\detokenize{actions:set-locale}}
The \sphinxstylestrong{set-locale} function allows a user to specify a locale which
affects the numeric format behavior of the \sphinxstylestrong{format} and
\sphinxstylestrong{read-number} functions. Before a number is printed by the \sphinxstylestrong{format}
function or is parsed by the \sphinxstylestrong{read-number} function, the locale is
temporarily changed to the last value specified to the \sphinxstylestrong{set-locale}
function (or the default C locale if no value was previously specified).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{locale} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{locale}\PYG{o}{\PYGZhy{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

where the optional argument \textless{}locale-string\textgreater{} is a string containing the
new locale to be used by the \sphinxstylestrong{format} and \sphinxstylestrong{read-number} functions.
If \textless{}local-string\textgreater{} is specified, then the value of the previous locale is
returned. If \textless{}locale-string\textgreater{} is not specified, then the value of the
current locale is returned. A \textless{}locale-string\textgreater{} value of “” uses the
native locale (and the specification of this locale is dependent on the
environment in which CLIPS is run). A \textless{}locale-string\textgreater{} of “C” specifies
the standard C locale (which is the default).

Example

;;; This example assumes that the native

;;; locale has been set to Germany.

CLIPS\textgreater{} (read-number)

3.21

3.21

CLIPS\textgreater{} (read-number)

3,21

“\sphinxstylestrong{* READ ERROR *}”

CLIPS\textgreater{} (format nil “\%f” 3.1)

“3.100000”

CLIPS\textgreater{} (set-locale “”)

“C”

CLIPS\textgreater{} (read-number)

3.21

“\sphinxstylestrong{* READ ERROR *}”

CLIPS\textgreater{} (read-number)

3,21

3.21

CLIPS\textgreater{} (format nil “\%f” 3.1)

“3,100000”

CLIPS\textgreater{}

? Portability Note

The CLIPS \sphinxstylestrong{set-locale} function uses the ANSI C function \sphinxstylestrong{setlocale}
to temporarily change the locale. Setting the native locale used by the
setlocale function when \textless{}local-string\textgreater{} is specified as the empty string
“” varies from one operating system to another. For example, in Windows
7 the native locale is set by clicking on the Start menu, selecting
Control Panel, selecting Region and Language, selecting the Formats tab,
and then selecting a region from the drop-down menu such as German
(Germany). Alternately in Windows, the \textless{}local-string\textgreater{} could be specified
as ?DE? for Germany.

In Mac OS X, the native local can be specified by launching System
Preferences, clicking on Language \& Region, and then setting the region
to Germany. However, this only works when running CLIPS from the
Terminal application. Alternately the \textless{}locale-string\textgreater{} could be specified
as ?de\_DE? to specify Germany for either the GUI or Terminal version of
CLIPS.


\section{12.5 Math Functions}
\label{\detokenize{actions:math-functions}}
CLIPS provides several functions for mathematical computa?tions. They
are split into two packages: a set of standard math functions and a set
of extended math functions.


\subsection{12.5.1 Standard Math Functions}
\label{\detokenize{actions:standard-math-functions}}
The standard math functions are listed below. These func?tions should be
used only on numeric arguments. An error message will be printed if a
string argument is passed to a math function.


\subsubsection{12.5.1.1 Addition}
\label{\detokenize{actions:addition}}
The \sphinxstylestrong{+} function returns the sum of its arguments. Each of its
arguments should be a numeric expression. Addition is performed using
the type of the arguments provided unless mixed mode arguments (integer
and float) are used. In this case, the function return value and integer
arguments are converted to floats after the first float argument has
been encountered. This function returns a float if any of its arguments
is a float, otherwise it returns an integer.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{+} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (+ 2 3 4)

9

CLIPS\textgreater{} (+ 2 3.0 5)

10.0

CLIPS\textgreater{} (+ 3.1 4.7)

7.8

CLIPS\textgreater{}


\subsubsection{12.5.1.2 Subtraction}
\label{\detokenize{actions:subtraction}}
The \sphinxstylestrong{-}- function returns the value of the first argument minus the
sum of all subsequent arguments. Each of its arguments should be a
numeric expression. Subtraction is performed using the type of the
arguments provided unless mixed mode arguments (integer and float) are
used. In this case, the function return value and integer arguments are
converted to floats after the first float argument has been encountered.
This function returns a float if any of its arguments is a float,
otherwise it returns an integer.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{\PYGZhy{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (- 12 3 4)

5

CLIPS\textgreater{} (- 12 3.0 5)

4.0

CLIPS\textgreater{} (- 4.7 3.1)

1.6

CLIPS\textgreater{}


\subsubsection{12.5.1.3 Multiplication}
\label{\detokenize{actions:multiplication}}
The \sphinxstylestrong{*} function returns the product of its arguments. Each of its
arguments should be a numeric expression. Multiplication is performed
using the type of the arguments provided unless mixed mode arguments
(integer and float) are used. In this case, the function return value
and integer arguments are converted to floats after the first float
argument has been encountered. This function returns a float if any of
its arguments is a float, otherwise it returns an integer.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYGZbs{}\PYG{o}{*} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (* 2 3 4)

24

CLIPS\textgreater{} (* 2 3.0 5)

30.0

CLIPS\textgreater{} (* 3.1 4.7)

14.57

CLIPS\textgreater{}


\subsubsection{12.5.1.4 Division}
\label{\detokenize{actions:division}}
The \sphinxstylestrong{/} function returns the value of the first argument divided by
each of the subsequent arguments. Each of its arguments should be a
numeric expression. Division is performed using the type of the
arguments provided unless mixed mode arguments (integer and float) are
used. In this case, the function return value and integer arguments are
converted to floats after the first float argument has been encountered.
By default, the dividend (the first argument) is \sphinxstyleemphasis{automatically
converted} to a floating point number so that the result is a floating
pointer number. The function \sphinxstylestrong{set-auto-float-dividend} can be used to
control this behavior. If for example, the auto-float feature is
disabled, the expression (/ 4 3 4.0) evaluates to 0.25 as opposed to
0.333333333 if this feature were enabled. This function returns a float
if any of its arguments is a float, otherwise it returns an integer.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{/} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (/ 4 2)

2.0

CLIPS\textgreater{} (/ 4.0 2.0)

2.0

CLIPS\textgreater{} (/ 24 3 4)

2.0

CLIPS\textgreater{}


\subsubsection{12.5.1.5 Integer Division}
\label{\detokenize{actions:integer-division}}
The \sphinxstylestrong{div} function returns the value of the first argument divided by
each of the subsequent arguments. Each of its arguments should be a
numeric expression. Each argument is \sphinxstyleemphasis{automatically converted} to an
integer and integer division is performed. This function returns an
integer.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{div} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (div 4 2)

2

CLIPS\textgreater{} (div 5 2)

2

CLIPS\textgreater{} (div 33 2 3 5)

1

CLIPS\textgreater{}


\subsubsection{12.5.1.6 Maximum Numeric Value}
\label{\detokenize{actions:maximum-numeric-value}}
The \sphinxstylestrong{max} function returns the value of its largest numeric argument.
Each of its arguments should be a numeric expression. When necessary,
integers are temporarily converted to floats for comparison. The return
value will either be integer or float (depending upon the type of the
largest argument).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{max} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (max 3.0 4 2.0)

4

CLIPS\textgreater{}


\subsubsection{12.5.1.7 Minimum Numeric Value}
\label{\detokenize{actions:minimum-numeric-value}}
The \sphinxstylestrong{min} function returns the value of its smallest numeric argument.
Each of its arguments should be a numeric expression. When necessary,
integers are temporarily converted to floats for comparison. The return
value will either be integer or float (depending upon the type of the
smallest argument).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{min} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (min 4 0.1 -2.3)

-2.3

CLIPS\textgreater{}


\subsubsection{12.5.1.8 Absolute Value}
\label{\detokenize{actions:absolute-value}}
The \sphinxstylestrong{abs} function returns the absolute value of its only argument
(which should be a numeric expression). The return value will either be
integer or float (depending upon the type the argument).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{abs} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (abs 4.0)

4.0

CLIPS\textgreater{} (abs -2)

2

CLIPS\textgreater{}


\subsubsection{12.5.1.9 Convert To Float}
\label{\detokenize{actions:convert-to-float}}
The \sphinxstylestrong{float} function converts its only argument (which should be a
numeric expression) to type float and returns this value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{float} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (float 4.0)

4.0

CLIPS\textgreater{} (float -2)

-2.0

CLIPS\textgreater{}


\subsubsection{12.5.1.10 Convert To Integer}
\label{\detokenize{actions:convert-to-integer}}
The \sphinxstylestrong{integer} function converts its only argument (which should be a
numeric expression) to type integer and returns this value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{integer} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (integer 4.0)

4

CLIPS\textgreater{} (integer -2)

-2

CLIPS\textgreater{}


\subsection{12.5.2 Extended Math Functions}
\label{\detokenize{actions:extended-math-functions}}
In addition to standard math functions, CLIPS also provides a large
number of scien?tific and trigonometric math functions for more
extensive computations. Although included in the generic version of
CLIPS, if an expert system does not need these cap?a?bilities, these
functions may be excluded from the executable element of CLIPS to
pro?vide more memory (see the \sphinxstyleemphasis{Advanced Programming Guide}).


\subsubsection{12.5.2.1 Trigonometric Functions}
\label{\detokenize{actions:trigonometric-functions}}
The following trigonometric functions take one numeric argument and
return a floating-point number. The argument is expected to be in
radians.

acos         arccosine    acosh        hyperbolic arccosine
acot         arccotangent acoth        hyperbolic arccotangent
acsc         arccosecant  acsch        hyperbolic arccosecant
asec         arcsecant    asech        hyperbolic arcsecant
asin         arcsine      asinh        hyperbolic arcsine
atan         arctangent   atanh        hyperbolic arctangent
cos          cosine       cosh         hyperbolic cosine
cot          cotangent    coth         hyperbolic cotangent
csc          cosecant     csch         hyperbolic cosecant
sec          secant       sech         hyperbolic secant
sin          sine         sinh         hyperbolic sine
tan          tangent      tanh         hyperbolic tangent
============ ============ ============ =======================
========================= ====================================

Example

CLIPS\textgreater{} (cos 0)

1.0

CLIPS\textgreater{} (acos 1.0)

0.0

CLIPS\textgreater{}


\subsubsection{12.5.2.2 Convert From Degrees to Grads}
\label{\detokenize{actions:convert-from-degrees-to-grads}}
The \sphinxstylestrong{deg-grad} function converts its only argument (which should be a
numeric expression) from units of degrees to units of grads (360 degrees
= 400 grads). The return value of this function is a float.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deg}\PYG{o}{\PYGZhy{}}\PYG{n}{grad} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (deg-grad 90)

100.0

CLIPS\textgreater{}


\subsubsection{12.5.2.3 Convert From Degrees to Radians}
\label{\detokenize{actions:convert-from-degrees-to-radians}}
The \sphinxstylestrong{deg-rad} function converts its only argument (which should be a
numeric expression) from units of degrees to units of radians (360
degrees = 2p radians). The return value of this function is a float.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deg}\PYG{o}{\PYGZhy{}}\PYG{n}{rad} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (deg-rad 180)

3.141592653589793

CLIPS\textgreater{}


\subsubsection{12.5.2.4 Convert From Grads to Degrees}
\label{\detokenize{actions:convert-from-grads-to-degrees}}
The \sphinxstylestrong{grad-deg} function converts its only argument (which should be a
numeric expression) from units of grads to units of degrees (360 degrees
= 400 grads). The return value of this function is a float.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{grad}\PYG{o}{\PYGZhy{}}\PYG{n}{deg} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (grad-deg 100)

90.0

CLIPS\textgreater{}


\subsubsection{12.5.2.5 Convert From Radians to Degrees}
\label{\detokenize{actions:convert-from-radians-to-degrees}}
The \sphinxstylestrong{rad-deg} function converts its only argument (which should be a
numeric expression) from units of radians to units of degrees (360
degrees = 2p radians). The return value of this function is a float.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{rad}\PYG{o}{\PYGZhy{}}\PYG{n}{deg} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (rad-deg 3.141592653589793)

180.0

CLIPS\textgreater{}


\subsubsection{12.5.2.6 Return the Value of p}
\label{\detokenize{actions:return-the-value-of-p}}
The \sphinxstylestrong{pi} function returns the value of p (3.141592653589793…) as a
float.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{pi}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (pi)

3.141592653589793

CLIPS\textgreater{}


\subsubsection{12.5.2.7 Square Root}
\label{\detokenize{actions:square-root}}
The \sphinxstylestrong{sqrt} function returns the square root of its only argument
(which should be a numeric expression) as a float.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{sqrt} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (sqrt 9)

3.0

CLIPS\textgreater{}


\subsubsection{12.5.2.8 Power}
\label{\detokenize{actions:power}}
The \sphinxstylestrong{**} function raises its first argument to the power of its
second argument and returns this value as a float.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{*}\PYGZbs{}\PYG{o}{*} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} ({\color{red}\bfseries{}*}* 3 2)

9.0

CLIPS\textgreater{}


\subsubsection{12.5.2.9 Exponential}
\label{\detokenize{actions:exponential}}
The \sphinxstylestrong{exp} function raises the value e (the base of the natural system
of logarithms, having a value of approximately 2.718…) to the power
specified by its only argument and returns this value as a float.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{exp} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (exp 1)

2.718281828459045

CLIPS\textgreater{}


\subsubsection{12.5.2.10 Logarithm}
\label{\detokenize{actions:logarithm}}
Given n (the only argument) and the value e is the base of the natural
system of logarithms, the \sphinxstylestrong{log} function returns the float value x
such that the following equation is satisfied:

n = ex

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{log} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (log 2.718281828459045)

1.0

CLIPS\textgreater{}


\subsubsection{12.5.2.11 Logarithm Base 10}
\label{\detokenize{actions:logarithm-base-10}}
Given n (the only argument), the \sphinxstylestrong{log10} function returns the float
value x such that the following equation is satisfied:

n = 10x

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{log10} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (log10 100)

2.0

CLIPS\textgreater{}


\subsubsection{12.5.2.12 Round}
\label{\detokenize{actions:round}}
The \sphinxstylestrong{round} function rounds its only argument (which should be a
numeric expression) toward the closest integer. If the argument is
exactly between two integers, it is rounded down. The return value of
this function is an integer.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{round} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (round 3.6)

4

CLIPS\textgreater{}


\subsubsection{12.5.2.13 Modulus}
\label{\detokenize{actions:modulus}}
The \sphinxstylestrong{mod} function returns the remainder of the result of dividing its
first argument by its second argument (assuming that the result of
division must be an integer). It returns an integer if both arguments
are integers, otherwise it returns a float.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{mod} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{numeric}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (mod 5 2)

1

CLIPS\textgreater{} (mod 3.7 1.2)

0.1

CLIPS\textgreater{}


\section{12.6 Procedural Functions}
\label{\detokenize{actions:procedural-functions}}
The following are functions which provide procedural programming
capabilities as found in languages such as Pascal, C and Ada.


\subsection{12.6.1 Binding Variables}
\label{\detokenize{actions:binding-variables}}
Occasionally, it is important to create new variables or to modify the
value of previously bound variables on the RHS of a rule. The \sphinxstylestrong{bind}
function provides this capability.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{bind} \PYG{o}{\PYGZlt{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

where the first argument to bind, \textless{}variable\textgreater{}, is the local or global
variable to be bound (it \sphinxstyleemphasis{may} have been bound previously). The bind
function may also be used within a message-handler’s body to set a
slot’s value.

If no \textless{}expression\textgreater{} is specified, then local variables are unbound and
global variables are reset to their original value. If one \textless{}expression\textgreater{}
is specified, then the value of \textless{}variable\textgreater{} is set to the return value
from evaluating \textless{}expression\textgreater{}. If more than one \textless{}expression\textgreater{} is
specified, then all of the \textless{}expressions\textgreater{} are evaluated and grouped
together as a multifield value and the resulting value is stored in
\textless{}variable\textgreater{}.

The bind function returns the symbol FALSE when a local variable is
unbound, otherwise, the return value is the value to which \textless{}variable\textgreater{} is
set.

Example 1

CLIPS\textgreater{} (defglobal ?*x* = 3.4)

CLIPS\textgreater{} ?*x*

3.4

CLIPS\textgreater{} (bind ?*x* (+ 8 9))

17

CLIPS\textgreater{} ?*x*

17

CLIPS\textgreater{} (bind ?*x* (create\$ a b c d))

(a b c d)

CLIPS\textgreater{} ?*x*

(a b c d)

CLIPS\textgreater{} (bind ?*x* d e f)

(d e f)

CLIPS\textgreater{} ?*x*

(d e f)

CLIPS\textgreater{} (bind ?*x*)

3.4

CLIPS\textgreater{} ?*x*

3.4

CLIPS\textgreater{} (bind ?x 32)

32

CLIPS\textgreater{} ?x

32

CLIPS\textgreater{} (reset)

CLIPS\textgreater{} ?x

{[}EVALUATN1{]} Variable x is unbound

FALSE

CLIPS\textgreater{}

Example 2

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot x)

(slot y))

CLIPS\textgreater{}

(defmessage-handler A init after ()

(bind ?self:x 3)

(bind ?self:y 4))

CLIPS\textgreater{} (make-instance a of A)

{[}a{]}

CLIPS\textgreater{} (send {[}a{]} print)

{[}a{]} of A

(x 3)

(y 4)

CLIPS\textgreater{}


\subsection{12.6.2 If…then…else Function}
\label{\detokenize{actions:if-then-else-function}}
The \sphinxstylestrong{if} function provides an \sphinxstylestrong{if…then…else} structure to allow
for conditional execution of a set of actions.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{k}{if} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}
\PYG{o}{\textbar{}} \PYG{n}{then}
\PYG{o}{\textbar{}} \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYGZbs{}\PYG{o}{*}
\PYG{o}{\textbar{}} \PYG{p}{[}\PYG{k}{else}
\PYG{o}{\textbar{}} \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Any number of allowable actions may be used inside of the \sphinxstylestrong{then} or
\sphinxstylestrong{else} portion, including another \sphinxstylestrong{if…then…else} structure. The
\sphinxstylestrong{else} portion is optional. If \textless{}expression\textgreater{} evaluates to anything
other than the symbol FALSE, then the actions associated with the
\sphinxstylestrong{then} portion are executed. Otherwise, the actions associated with
the \sphinxstylestrong{else} portion are executed. The return value of the if function
is the value of the last \textless{}expression\textgreater{} or \textless{}action\textgreater{} evaluated.

Example

\begin{DUlineblock}{0em}
\item[] (defrule closed-valves
\item[] (temp high)
\item[] (valve ?v closed)
\item[] =\textgreater{}
\item[] (if (= ?v 6)
\item[] then
\item[] (printout t “The special valve ” ?v ” is closed!” crlf)
\item[] (assert (perform special operation))
\item[] else
\item[] (printout t “Valve ” ?v ” is normally closed” crlf)))
\end{DUlineblock}

Note that this rule could have been accomplished just as easily with two
rules, and that it is usually better to accomplish this with two rules.

\begin{DUlineblock}{0em}
\item[] (defrule closed-valves-number-6
\item[] (temp high)
\item[] (valve 6 closed)
\item[] =\textgreater{}
\item[] (printout t “The special valve 6 is closed!” crlf)
\item[] (assert (perform special operation)))
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] (defrule closed-valves-other-than-6
\item[] (temp high)
\item[] (valve ?v\&\textasciitilde{}6 closed)
\item[] =\textgreater{}
\item[] (printout t “Valve ” ?v ” is normally closed” crlf))
\end{DUlineblock}


\subsection{12.6.3 While}
\label{\detokenize{actions:while}}
The \sphinxstylestrong{while} function is provided to allow simple looping. Its use is
similar to that of the \sphinxstylestrong{if} function.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{k}{while} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{do}\PYG{p}{]}
\PYG{o}{\textbar{}} \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Again, all predicate functions are available for use in \sphinxstylestrong{while}. Any
number of allowable actions may be placed inside the \sphinxstylestrong{while} block,
including \sphinxstylestrong{if…then…else} or ad?ditional \sphinxstylestrong{while} structures. The
test is performed prior to the first execution of the loop. The actions
within the \sphinxstylestrong{while} loop are executed until \textless{}expression\textgreater{} evaluates to
the symbol FALSE. The \sphinxstylestrong{while} may optionally include the symbol \sphinxstylestrong{do}
after the condition and before the first action. The \sphinxstylestrong{break} and
\sphinxstylestrong{return} functions can be used to terminate the loop prematurely. The
return value of this function is FALSE unless the \sphinxstylestrong{return} function is
used to terminate the loop.

Example

\begin{DUlineblock}{0em}
\item[] (defrule open-valves
\item[] (valves-open-through ?v)
\item[] =\textgreater{}
\item[] (while (\textgreater{} ?v 0)
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] (printout t “Valve ” ?v ” is open” crlf)
\item[] (bind ?v (- ?v 1))))
\end{DUlineblock}


\subsection{12.6.4 Loop-for-count}
\label{\detokenize{actions:loop-for-count}}
The \sphinxstylestrong{loop-for-count} function is provided to allow simple iterative
looping.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{loop}\PYG{o}{\PYGZhy{}}\PYG{k}{for}\PYG{o}{\PYGZhy{}}\PYG{n}{count} \PYG{o}{\PYGZlt{}}\PYG{n+nb}{range}\PYG{o}{\PYGZhy{}}\PYG{n}{spec}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{do}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

\textless{}range-spec\textgreater{} ::= \textless{}end-index\textgreater{} \textbar{}

(\textless{}loop-variable\textgreater{} \textless{}start-index\textgreater{} \textless{}end-index\textgreater{}) \textbar{}

(\textless{}loop-variable\textgreater{} \textless{}end-index\textgreater{})

\textless{}start-index\textgreater{} ::= \textless{}integer-expression\textgreater{}

\textless{}end-index\textgreater{} ::= \textless{}integer-expression\textgreater{}

Performs the given actions the number of times specified by
\textless{}range-spec\textgreater{}. If \textless{}start-index\textgreater{} is not given, it is assumed to be one. If
\textless{}start-index\textgreater{} is greater than \textless{}end-index\textgreater{}, then the body of the loop is
never executed. The integer value of the current iteration can be
examined with the loop variable, if specified.The \sphinxstylestrong{break} and
\sphinxstylestrong{return} functions can be used to terminate the loop prematurely. The
return value of this function is FALSE unless the \sphinxstylestrong{return} function is
used to terminate the loop. Variables from an outer scope may be used
within the loop, but the loop variable (if specified) masks any outer
variables of the same name. Loops can be nested.

Example

CLIPS\textgreater{} (loop-for-count 2 (printout t “Hello world” crlf))

Hello world

Hello world

FALSE

CLIPS\textgreater{}

(loop-for-count (?cnt1 2 4) do

(loop-for-count (?cnt2 1 3) do

(printout t ?cnt1 ” ” ?cnt2 crlf)))

2 1

2 2

2 3

3 1

3 2

3 3

4 1

4 2

4 3

FALSE

CLIPS\textgreater{}


\subsection{12.6.5 Progn}
\label{\detokenize{actions:progn}}
The \sphinxstylestrong{progn} function evaluates all of its arguments and returns the
value of the last argument;.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{progn} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (progn (setgen 5) (gensym))

gen5

CLIPS\textgreater{}


\subsection{12.6.6 Progn\$}
\label{\detokenize{actions:progn-1}}\label{\detokenize{actions:id3}}
The \sphinxstylestrong{progn\$} function performs a set of actions for each field of a
multifield value. The field of the current iteration can be examined
with \textless{}field-variable\textgreater{}, if specified. The index of the current iteration
can be examined with \textless{}field-variable\textgreater{}**-index**. The \sphinxstylestrong{progn\$} function
can use variables from outer scopes, and the \sphinxstylestrong{return} and \sphinxstylestrong{break}
functions can also be used within a \sphinxstylestrong{progn\$} as long as they are valid
in the outer scope. The return value of this function is the return
value of the last action performed for the last field in the multifield
value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(progn\PYGZdl{} \PYGZlt{}multifield\PYGZhy{}spec\PYGZgt{} \PYGZlt{}expression\PYGZgt{}*)
\end{sphinxVerbatim}

\textless{}multifield-spec\textgreater{} ::= \textless{}multifield-expression\textgreater{} \textbar{}

(\textless{}field-variable\textgreater{} \textless{}multifield-expression\textgreater{})

Example

CLIPS\textgreater{} (progn\$ (?field (create\$ abc def ghi))

(printout t “\textendash{}\textgreater{} ” ?field ” ” ?field-index ” \textless{}\textendash{}” crlf))

\textendash{}\textgreater{} abc 1 \textless{}\textendash{}

\textendash{}\textgreater{} def 2 \textless{}\textendash{}

\textendash{}\textgreater{} ghi 3 \textless{}\textendash{}

CLIPS\textgreater{}


\subsection{12.6.7 Return}
\label{\detokenize{actions:return}}
The \sphinxstylestrong{return} function immediately terminates the currently executing
deffunction, generic function method, message-handler, defrule RHS, or
certain instance set query functions (\sphinxstylestrong{do-for-instance},
\sphinxstylestrong{do-for-all-instances} and \sphinxstylestrong{delayed-do-for-all-instances}). Without
any arguments, there is no return value. However, if an argument is
included, its evaluation is given as the return value of the deffunction
, method or message-handler.

The \sphinxstylestrong{return} function can only be used within the actions of
deffunctions, methods and message-handlers, defrules, or the instance
set query functions previously listed. If used on the RHS of a rule, the
current focus is removed from the focus stack. In addition, \sphinxstylestrong{return}
should not be used as an argument to another function call. If used
within an instance set query function, the \sphinxstylestrong{return} function is only
valid if it is applicable in the outer scope of the query.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{k}{return} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{}

(deffunction sign (?num)

(if (\textgreater{} ?num 0) then

(return 1))

(if (\textless{} ?num 0) then

(return -1))
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi )}
\makeatletter\def\p@enumii{\p@enumi \theenumi )}\makeatother
\setcounter{enumi}{-1}
\item {} 
\end{enumerate}

CLIPS\textgreater{} (sign 5)

1

CLIPS\textgreater{} (sign -10)

-1

CLIPS\textgreater{} (sign 0)

0

CLIPS\textgreater{}


\subsection{12.6.8 Break}
\label{\detokenize{actions:break}}
The \sphinxstylestrong{break} function immediately terminates the currently iterating
\sphinxstylestrong{while} loop, \sphinxstylestrong{loop-for-count} execution, \sphinxstylestrong{progn} execution,
\sphinxstylestrong{progn\$} execution, \sphinxstylestrong{foreach} execution, or certain instance set
query functions (\sphinxstylestrong{do-for-instance}, \sphinxstylestrong{do-for-all-instances} and
\sphinxstylestrong{delayed-do-for-all-instances}).

The \sphinxstylestrong{break} function can only be used within the actions of a
\sphinxstylestrong{while} loop, \sphinxstylestrong{loop-for-count} execution, \sphinxstylestrong{progn} execution,
\sphinxstylestrong{progn\$} execution, \sphinxstylestrong{foreach} execution, or the specified instance
set queries previously listed. Other uses will have no effect. The
\sphinxstylestrong{break} cannot be used within a \sphinxstylestrong{progn} unless it is valid for the
outer scope of the \sphinxstylestrong{progn}. In addition, \sphinxstylestrong{break} should not be used
as an argument to another function call.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{k}{break}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{}

(deffunction iterate (?num)

(bind ?i 0)

(while TRUE do

(if (\textgreater{}= ?i ?num) then

(break))

(printout t ?i ” “)

(bind ?i (+ ?i 1)))

(printout t crlf))

CLIPS\textgreater{} (iterate 1)

0

CLIPS\textgreater{} (iterate 10)

0 1 2 3 4 5 6 7 8 9

CLIPS\textgreater{}


\subsection{12.6.9 Switch}
\label{\detokenize{actions:switch}}
The \sphinxstylestrong{switch} function allows a particular group of actions (among
several groups of actions) to be performed based on a specified value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{switch} \PYG{o}{\PYGZlt{}}\PYG{n}{test}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\textless{}case-statement\textgreater{}*

{[}\textless{}default-statement\textgreater{}{]})

\textless{}case-statement\textgreater{} ::=

(case \textless{}comparison-expression\textgreater{} then \textless{}action\textgreater{}*)

\textless{}default-statement\textgreater{} ::= (default \textless{}action\textgreater{}*)

As indicated by the BNF, the optional default statement must succeed all
case statements. None of the case comparison expressions should be the
same.

The \sphinxstylestrong{switch} function evaluates the \textless{}test-expression\textgreater{} first and then
evaluates each \textless{}comparison-expression\textgreater{} in order of definition. Once the
evaluation of the \textless{}comparison-expression\textgreater{} is equivalent to the
evaluation of the \textless{}test-expression\textgreater{}, the actions of that case are
evaluated (in order) and the switch function is terminated. If no cases
are satisfied, the default actions (if any) are evaluated (in order).

The return value of the \sphinxstylestrong{switch} function is the last action evaluated
in the \sphinxstylestrong{switch} function. If no actions are evaluated, the return
value is the symbol FALSE.

Example

CLIPS\textgreater{} (defglobal ?*x* = 0)

CLIPS\textgreater{} (defglobal ?*y* = 1)

CLIPS\textgreater{}

(deffunction foo (?val)

(switch ?val

(case ?*x* then *x*)

(case ?*y* then *y*)

(default none)))

CLIPS\textgreater{} (foo 0)

*x*

CLIPS\textgreater{} (foo 1)

*y*

CLIPS\textgreater{} (foo 2)

none

CLIPS\textgreater{}


\subsection{12.6.10 Foreach}
\label{\detokenize{actions:foreach}}
The \sphinxstylestrong{foreach} function performs a set of actions for each field of a
multifield value. The field of the current iteration can be examined
with \textless{}field-variable\textgreater{}, if specified. The index of the current iteration
can be examined with \textless{}field-variable\textgreater{}**-index**. The \sphinxstylestrong{foreach}
function can use variables from outer scopes, and the \sphinxstylestrong{return} and
\sphinxstylestrong{break} functions can also be used within a \sphinxstylestrong{foreach} as long as
they are valid in the outer scope. The return value of this function is
the return value of the last action performed for the last field in the
multifield value.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{foreach} \PYG{o}{\PYGZlt{}}\PYG{n}{field}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{multifield}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (foreach ?field (create\$ abc def ghi)

(printout t “\textendash{}\textgreater{} ” ?field ” ” ?field-index ” \textless{}\textendash{}” crlf))

\textendash{}\textgreater{} abc 1 \textless{}\textendash{}

\textendash{}\textgreater{} def 2 \textless{}\textendash{}

\textendash{}\textgreater{} ghi 3 \textless{}\textendash{}

CLIPS\textgreater{}

? Portability Note

The \sphinxstylestrong{foreach} function provides the same functionality as the
\sphinxstylestrong{progn\$} function, but uses different syntax with a more meaningful
function name. It is provided for compatibility with Jess (Java Expert
System Shell).


\section{12.7 Miscellaneous Functions}
\label{\detokenize{actions:miscellaneous-functions}}
The following are additional functions for use within CLIPS.


\subsection{12.7.1 Gensym}
\label{\detokenize{actions:gensym}}
The \sphinxstylestrong{gensym} function returns a special, sequenced symbol that can be
stored as a sin?gle field. This is primarily for tagging patterns that
need a unique identifier, but the user does not care what the identifier
is. Multiple calls to \sphinxstylestrong{gensym} are guaranteed to return different
identifiers of the form

gen\sphinxstylestrong{X}

where \sphinxstylestrong{X} is a positive integer. The first call to \sphinxstylestrong{gensym} returns
\sphinxstylestrong{gen1}; all subsequent calls increment the number. Note that
\sphinxstylestrong{gensym} is \sphinxstyleemphasis{not} reset after a call to \sphinxstylestrong{clear}. If users plan to
use the gensym feature, they should avoid creating facts which include a
user-defined field of this form.

Example

(assert (new-id (gensym) flag1 7))

which, on the first call, generates a fact of the form

(new-id gen1 flag1 7)


\subsection{12.7.2 Gensym*}
\label{\detokenize{actions:gensym-1}}\label{\detokenize{actions:id4}}
The \sphinxstylestrong{gensym*} function is similar to the \sphinxstylestrong{gensym} function,
however, it will produce a unique symbol that does not currently exist
within the CLIPS environment.

Example

CLIPS\textgreater{} (setgen 1)

1

CLIPS\textgreater{} (assert (gen1 gen2 gen3))

\textless{}Fact-1\textgreater{}

CLIPS\textgreater{} (gensym)

gen1

CLIPS\textgreater{} (gensym*)

gen4

CLIPS\textgreater{}


\subsection{12.7.3 Setgen}
\label{\detokenize{actions:setgen}}
The \sphinxstylestrong{setgen} function allows the user to set the starting number used
by \sphinxstylestrong{gensym} and \sphinxstylestrong{gensym*} (see sections 12.7.1 and 12.7.2).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{setgen} \PYG{o}{\PYGZlt{}}\PYG{n}{integer}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

where \textless{}intger-expression\textgreater{} must be a positive integer value and is the
value returned by this function. All subsequent calls to \sphinxstylestrong{gensym} will
return a sequenced symbol with the numeric portion of the symbol
starting at \textless{}integer-expression\textgreater{}.

Example

CLIPS\textgreater{} (setgen 32)

32

CLIPS\textgreater{}

After this, calls to \sphinxstylestrong{gensym} will return gen32, gen33, etc.


\subsection{12.7.4 Random}
\label{\detokenize{actions:random}}
The \sphinxstylestrong{random} function returns a ?random? integer value. It is
patterned after the ANSI standard rand library function and therefore
may not be available on all platforms.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{random} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{start}\PYG{o}{\PYGZhy{}}\PYG{n}{integer}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{end}\PYG{o}{\PYGZhy{}}\PYG{n}{integer}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

where \textless{}start-integer-expression\textgreater{} and \textless{}end-integer-expression\textgreater{} if
specified indicate the range of values to which the randomly generated
integer is limited.

Example

\begin{DUlineblock}{0em}
\item[] (defrule roll-the-dice
\item[] (roll-the-dice)
\item[] =\textgreater{}
\end{DUlineblock}

(bind ?roll1 (random 1 6))

(bind ?roll2 (random 1 6))

(printout t “Your roll is: ” ?roll1 ” ” ?roll2 crlf))


\subsection{12.7.5 Seed}
\label{\detokenize{actions:seed}}
The \sphinxstylestrong{seed} function seeds the random number generator. It is patterned
after the ANSI standard seed library function and therefore may not be
available on all platforms.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{seed} \PYG{o}{\PYGZlt{}}\PYG{n}{integer}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

where \textless{}integer-expression\textgreater{} is the integer seed value and the function
has no return value.


\subsection{12.7.6 Time}
\label{\detokenize{actions:time}}
The \sphinxstylestrong{time} function returns a floating-point value representing the
elapsed seconds since the system refer?ence time.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{time}\PYG{p}{)}
\end{sphinxVerbatim}

? Portability Note

Not all operating systems/compilers provide this function. The code is
stored in the \sphinxstylestrong{sysdep.c} file, and the default coding for generic
CLIPS is a non-?functional stub that returns zero for the time.


\subsection{12.7.7 Number of Fields or Characters in a Data Object}
\label{\detokenize{actions:number-of-fields-or-characters-in-a-data-object}}
The \sphinxstylestrong{length} function returns an integer for the number of fields
bound to a multifield value or the length in characters of a string or
symbol.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{length} \PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZhy{}}\PYG{n}{symbol}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{multifield}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

If the argument given to \sphinxstylestrong{length} is not the appropriate type, a
negative one (-1) is returned. This function may also be called using
the name \sphinxstylestrong{length\$}.

Example

CLIPS\textgreater{} (length (create\$ a b c d e f g))

7

CLIPS\textgreater{} (length “cat”)

3

CLIPS\textgreater{}


\subsection{12.7.8 Determining the Restrictions for a Function}
\label{\detokenize{actions:determining-the-restrictions-for-a-function}}
The \sphinxstylestrong{get-function-restrictions} function can be used to gain access to
the restriction string associated with a CLIPS or user defined function.
The restriction string contains information on the number and types of
arguments that a function expects. See section 3.1 of the Advanced
Programming Guide for the meaning of the characters which compose the
restriction string.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{restrictions} \PYG{o}{\PYGZlt{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (get-function-restrictions +)

“2*n”

CLIPS\textgreater{}


\subsection{12.7.9 Sorting a List of Values}
\label{\detokenize{actions:sorting-a-list-of-values}}
The function \sphinxstylestrong{sort} allows a list of values to be sorted based on a
user specified comparison function.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{sort} \PYG{o}{\PYGZlt{}}\PYG{n}{comparison}\PYG{o}{\PYGZhy{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

This function returns a multifield value containing the sorted values
specified as arguments. The comparison function used for sorting should
accept exactly two arguments and can be a user-defined function, a
generic function, or a deffunction. Given two adjacent arguments from
the list to be sorted, the comparison function should return TRUE if its
first argument should come after its second argument in the sorted list.

Example

CLIPS\textgreater{} (sort \textgreater{} 4 3 5 7 2 7)

(2 3 4 5 7 7)

CLIPS\textgreater{}

(deffunction string\textgreater{} (?a ?b)

(\textgreater{} (str-compare ?a ?b) 0))

CLIPS\textgreater{} (sort string\textgreater{} ax aa bk mn ft m)

(aa ax bk ft m mn)

CLIPS\textgreater{}


\subsection{12.7.10 Calling a Function}
\label{\detokenize{actions:calling-a-function}}
The function \sphinxstylestrong{funcall} constructs a function call from its arguments
and then evaluates the function call. The first argument should be the
name of a user-defined function, deffunction, or generic function. The
remaining arguments are evaluated and then passed to the specified
function when it is evaluated. Functions that are invoked using
specialized syntax, such as the \sphinxstylestrong{assert} command (which uses
parentheses to delimit both slot and function names), may not be called
using funcall.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{funcall} \PYG{o}{\PYGZlt{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (funcall delete\$ (create\$ a b c) 2 2)

(a c)

CLIPS\textgreater{} (funcall + 1 2 (expand\$ (create\$ 3 4)))

10

CLIPS\textgreater{}


\subsection{12.7.11 Timing Functions and Commands}
\label{\detokenize{actions:timing-functions-and-commands}}
The function \sphinxstylestrong{timer} returns the number of seconds elapsed evaluating
a series of expressions.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{timer} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (timer (loop-for-count 10000 (+ 3 4)))

0.0416709999999512

CLIPS\textgreater{}


\subsection{12.7.12 Determining the Operating System}
\label{\detokenize{actions:determining-the-operating-system}}
The \sphinxstylestrong{operating-system} function returns a symbol indicating the
opertating system on which CLIPS is running. Possible return values are
VMS, UNIX-V, UNIX-7, LINUX, DARWIN, MAC-OS-X, DOS, WINDOWS, and UNKNOWN.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{operating}\PYG{o}{\PYGZhy{}}\PYG{n}{system}\PYG{p}{)}
\end{sphinxVerbatim}


\section{12.8 Deftemplate Functions}
\label{\detokenize{actions:deftemplate-functions}}
The following functions provide ancillary capabilities for the
deftemplate construct.


\subsection{12.8.1 Determining the Module in which a Deftemplate is Defined}
\label{\detokenize{actions:determining-the-module-in-which-a-deftemplate-is-defined}}
This function returns the module in which the specified deftemplate name
is defined.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{module} \PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.8.2 Getting the Allowed Values for a Deftemplate Slot}
\label{\detokenize{actions:getting-the-allowed-values-for-a-deftemplate-slot}}
This function groups the allowed values for a slot (specified in any of
allowed-? attributes for the slots) into a multifield variable. If no
allowed-? attributes were specified for the slot, then the symbol FALSE
is returned. A multifield of length zero is returned if an error occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{allowed}\PYG{o}{\PYGZhy{}}\PYG{n}{values} \PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(deftemplate A

(slot x)

(slot y (allowed-integers 2 3) (allowed-symbols foo)))

CLIPS\textgreater{} (deftemplate-slot-allowed-values A x)

FALSE

CLIPS\textgreater{} (deftemplate-slot-allowed-values A y)

(2 3 foo)

CLIPS\textgreater{}


\subsection{12.8.3 Getting the Cardinality for a Deftemplate Slot}
\label{\detokenize{actions:getting-the-cardinality-for-a-deftemplate-slot}}
This function groups the minimum and maximum cardinality allowed for a
multifield slot into a multifield variable. A maximum cardinality of
infinity is indicated by the symbol \sphinxstylestrong{+oo} (the plus character followed
by two lowercase o?s?not zeroes). A multifield of length zero is
returned for single field slots or if an error occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{cardinality} \PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(deftemplate A

(slot x)

(multislot y (cardinality ?VARIABLE 5))

(multislot z (cardinality 3 ?VARIABLE)))

CLIPS\textgreater{} (deftemplate-slot-cardinality A y)

(0 5)

CLIPS\textgreater{} (deftemplate-slot-cardinality A z)

(3 +oo)

CLIPS\textgreater{}


\subsection{12.8.4 Testing whether a Deftemplate Slot has a Default}
\label{\detokenize{actions:testing-whether-a-deftemplate-slot-has-a-default}}
This function returns the symbol static if the specified slot in the
specified deftemplate has a static default (whether explicitly or
implicitly defined), the symbol dynamic if the slot has a dynamic
default, or the symbol FALSE if the slot does not have a default. An
error is generated if the specified deftemplate or slot does not exist.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{defaultp} \PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(deftemplate A

(slot w)

(slot x (default ?NONE))

(slot y (default 1))

(slot z (default-dynamic (gensym))))

CLIPS\textgreater{} (deftemplate-slot-defaultp A w)

static

CLIPS\textgreater{} (deftemplate-slot-defaultp A x)

FALSE

CLIPS\textgreater{} (deftemplate-slot-defaultp A y)

static

CLIPS\textgreater{} (deftemplate-slot-defaultp A z)

dynamic

CLIPS\textgreater{}


\subsection{12.8.5 Getting the Default Value for a Deftemplate Slot}
\label{\detokenize{actions:getting-the-default-value-for-a-deftemplate-slot}}
This function returns the default value associated with a deftemplate
slot. If a slot has a dynamic default, the expression will be evaluated
when this function is called. The symbol FALSE is returned if an error
occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{default}\PYG{o}{\PYGZhy{}}\PYG{n}{value} \PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(deftemplate A

(slot x (default 3))

(multislot y (default a b c))

(slot z (default-dynamic (gensym))))

CLIPS\textgreater{} (deftemplate-slot-default-value A x)

3

CLIPS\textgreater{} (deftemplate-slot-default-value A y)

(a b c)

CLIPS\textgreater{} (deftemplate-slot-default-value A z)

gen1

CLIPS\textgreater{} (deftemplate-slot-default-value A z)

gen2

CLIPS\textgreater{}


\subsection{12.8.6 Deftemplate Slot Existence}
\label{\detokenize{actions:deftemplate-slot-existence}}
This function returns the symbol TRUE if the specified slot is present
in the specified deftemplate, FALSE otherwise.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{existp} \PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (deftemplate A (slot x))

CLIPS\textgreater{} (deftemplate-slot-existp A x)

TRUE

CLIPS\textgreater{} (deftemplate-slot-existp A y)

FALSE

CLIPS\textgreater{}


\subsection{12.8.7 Testing whether a Deftemplate Slot is a Multifield Slot}
\label{\detokenize{actions:testing-whether-a-deftemplate-slot-is-a-multifield-slot}}
This function returns the symbol TRUE if the specified slot in the
specified deftemplate is a multifield slot. Otherwise, it returns the
symbol FALSE. An error is generated if the specified deftemplate or slot
does not exist.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{multip} \PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (deftemplate A (slot x) (multislot y))

CLIPS\textgreater{} (deftemplate-slot-multip A x)

FALSE

CLIPS\textgreater{} (deftemplate-slot-multip A y)

TRUE

CLIPS\textgreater{}


\subsection{12.8.8 Determining the Slot Names Associated with a Deftemplate}
\label{\detokenize{actions:determining-the-slot-names-associated-with-a-deftemplate}}
The \sphinxstylestrong{deftemplate-slot-names} function returns the slot names
associated with the deftemplate in a multifield value. The symbol
\sphinxstyleemphasis{implied} is returned for an implied deftemplate (which has a single
implied multifield slot). FALSE is returned if the specified deftemplate
does not exist.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{names} \PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (deftemplate foo (slot bar) (multislot yak))

CLIPS\textgreater{} (deftemplate-slot-names foo)

(bar yak)

CLIPS\textgreater{}


\subsection{12.8.9 Getting the Numeric Range for a Deftemplate Slot}
\label{\detokenize{actions:getting-the-numeric-range-for-a-deftemplate-slot}}
This function groups the minimum and maximum numeric ranges allowed a
slot into a multifield variable. A minimum value of infinity is
indicated by the symbol \sphinxstylestrong{-oo} (the minus character followed by two
lowercase o?s?not zeroes). A maximum value of infinity is indicated by
the symbol \sphinxstylestrong{+oo} (the plus character followed by two lowercase o?s?not
zeroes). The symbol FALSE is returned for slots in which numeric values
are not allowed. A multifield of length zero is returned if an error
occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{range} \PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(deftemplate A

(slot x)

(slot y (type SYMBOL))

(slot z (range 3 10)))

CLIPS\textgreater{} (deftemplate-slot-range A x)

(-oo +oo)

CLIPS\textgreater{} (deftemplate-slot-range A y)

FALSE

CLIPS\textgreater{} (deftemplate-slot-range A z)

(3 10)

CLIPS\textgreater{}


\subsection{12.8.10 Testing whether a Deftemplate Slot is a Single-Field Slot}
\label{\detokenize{actions:testing-whether-a-deftemplate-slot-is-a-single-field-slot}}
This function returns the symbol TRUE if the specified slot in the
specified deftemplate is a single-field slot. Otherwise, it returns the
symbol FALSE. An error is generated if the specified deftemplate or slot
does not exist.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{singlep} \PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (deftemplate A (slot x) (multislot y))

CLIPS\textgreater{} (deftemplate-slot-singlep A x)

TRUE

CLIPS\textgreater{} (deftemplate-slot-singlep A y)

FALSE

CLIPS\textgreater{}


\subsection{12.8.11 Getting the Primitive Types for a Deftemplate Slot}
\label{\detokenize{actions:getting-the-primitive-types-for-a-deftemplate-slot}}
This function groups the names of the primitive types allowed for a
deftemplate slot into a multifield variable. A multifield of length zero
is returned if an error occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{types} \PYG{o}{\PYGZlt{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (deftemplate A (slot y (type INTEGER LEXEME)))

CLIPS\textgreater{} (deftemplate-slot-types A y)

(INTEGER SYMBOL STRING)

CLIPS\textgreater{}


\subsection{12.8.12 Getting the List of Deftemplates}
\label{\detokenize{actions:getting-the-list-of-deftemplates}}
The function \sphinxstylestrong{get-deftemplate-list} returns a multifield value
containing the names of all deftemplate constructs facts visible to the
module specified by \textless{}module-name\textgreater{} or to the current module if none is
specified. If * is specified as the module name, then all deftemplates
are returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{deftemplate}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (deftemplate A)

CLIPS\textgreater{} (deftemplate B)

CLIPS\textgreater{} (get-deftemplate-list)

(initial-fact A B)

CLIPS\textgreater{}


\section{12.9 Fact Functions}
\label{\detokenize{actions:fact-functions}}
The following actions are used for assert, retracting, and modifying
facts.


\subsection{12.9.1 Creating New Facts}
\label{\detokenize{actions:creating-new-facts}}
The \sphinxstylestrong{assert} action allows the user to add a fact to the fact-list.
Multiple facts may be asserted with each call. If the facts item is
being watched (see section 13.2), then an informational message will be
printed each time a fact is asserted.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{k}{assert} \PYG{o}{\PYGZlt{}}\PYG{n}{RHS}\PYG{o}{\PYGZhy{}}\PYG{n}{pattern}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}

Missing slots in a tem?plate fact being asserted are assigned their
default value (see section 3). If an identical copy of the fact already
exists in the fact-list, the fact will not be added (however, this
behavior can be changed, see sections 13.4.4 and 13.4.5). Note that in
addition to constants, expressions can be placed within a fact to be
asserted. The first field of a fact must be a symbol. The value returned
of the assert function is the fact-address of the last fact asserted. If
the assertion of the last fact causes an error, or if an identical copy
of the fact already exists in the fact-list, then the symbol FALSE is
returned.

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (assert (color red))

\textless{}Fact-1\textgreater{}

CLIPS\textgreater{} (assert (color blue) (value (+ 3 4)))

\textless{}Fact-3\textgreater{}

CLIPS\textgreater{} (assert (color red))

FALSE

CLIPS\textgreater{} (deftemplate status (slot temp) (slot pressure))

CLIPS\textgreater{} (assert (status (temp high)

(pressure low)))

\textless{}Fact-4\textgreater{}

CLIPS\textgreater{} (facts)

f-0 (initial-fact)

f-1 (color red)

f-2 (color blue)

f-3 (value 7)

f-4 (status (temp high) (pressure low))

For a total of 5 facts.

CLIPS\textgreater{}


\subsection{12.9.2 Removing Facts from the Fact-list}
\label{\detokenize{actions:removing-facts-from-the-fact-list}}
The \sphinxstylestrong{retract} action allows the user to remove facts from the
fact-list. Multiple facts may be retracted with a single retract
statement. The retraction of a fact also removes all rules that depended
upon that fact for activation from the agenda. Retraction of a fact may
also cause the retraction of other facts which receive logical support
from the retracted fact. If the facts item is being watched (see section
13.2), then an informational message will be printed each time a fact is
retracted.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{retract} \PYG{o}{\PYGZlt{}}\PYG{n}{retract}\PYG{o}{\PYGZhy{}}\PYG{n}{specifier}\PYG{o}{\PYGZgt{}}\PYG{o}{+} \PYGZbs{}\PYG{o}{\textbar{}} \PYGZbs{}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

\textless{}retract-specifier\textgreater{} ::= \textless{}fact-specifier\textgreater{} \textbar{} \textless{}integer-expression\textgreater{}

The term \textless{}retract-specifier\textgreater{} includes variables bound on the LHS to
fact-addresses as described in section 5.4.1.8, or the \sphinxstylestrong{fact-index} of
the desired fact (e.g. 3 for the fact labeled f-3), or an expression
which evaluates to a retract-specifier. If the symbol * is used as an
argument, all facts will be retracted. Note that the number generally is
not known during the execution of a program, so facts usually are
retracted by binding them on the LHS of a rule. Only variable;s, fact
indices, or the symbol * may be used in a re?tract. External functions
may \sphinxstyleemphasis{not} be called. This function has no return value.

Example

\begin{DUlineblock}{0em}
\item[] (defrule change-valve-status
\item[] ?f1 \textless{}- (valve ?v open)
\item[] ?f2 \textless{}- (set ?v close)
\item[] =\textgreater{}
\item[] (retract ?f1 ?f2)
\item[] (assert (valve ?v close)))
\end{DUlineblock}


\subsection{12.9.3 Modifying Template Facts}
\label{\detokenize{actions:modifying-template-facts}}
The \sphinxstylestrong{modify} action allows the user to modify template facts on the
fact-list. Only one fact may be modified with a single modify statement.
The modification of a fact is equivalent to retracting the present fact
and asserting the modified fact. Therefore, any facts receiving logical
support from a template fact are retracted (assuming no other support)
when the template fact is modified and the new template fact loses any
logical support that it previously had.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{modify} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n}{specifier}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{RHS}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

The term \textless{}fact-specifier\textgreater{} includes variables bound on the LHS to
fact-addresses as described in section 5.4.1.8 or the fact-index of the
desired fact (e.g. 3 for the fact labeled f-3). Note that the fact-index
generally is not known during the execution of a program, so facts
usually are modified by binding them on the LHS of a rule. Static
deftemplate checking is not performed when a fact-index is used as the
\textless{}fact-specifier\textgreater{} since the deftemplate being referenced is usually
ambiguous. Only variables or fact indices may be used in a modify.
External functions may \sphinxstyleemphasis{not} be called. The value returned by this
function is the fact-address of the newly modified fact. If the
assertion of the newly modified fact causes an error, or if an identical
copy of the newly modified fact already exists in the fact-list, then
the symbol FALSE is returned.

Example

\begin{DUlineblock}{0em}
\item[] (defrule change-valve-status
\item[] ?f1\textless{}-(status (valve open))
\item[] ?f2\textless{}-(close-valve)
\item[] =\textgreater{}
\item[] (retract ?f2)
\item[] (modify ?f1 (valve closed)))
\end{DUlineblock}


\subsection{12.9.4 Duplicating Template Facts}
\label{\detokenize{actions:duplicating-template-facts}}
The \sphinxstylestrong{duplicate} action allows the user to duplicate deftemplate facts
on the fact-list changing a group of specified fields. This command
allows a new fact to be created by copying most of the fields of a
source fact and then specifying the fields to be changed. Only one fact
may be duplicated with a single duplicate statement. The duplicate
command is similar to the modify command except the fact being
duplicated is not retracted.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{duplicate} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n}{specifier}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{RHS}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

The term \textless{}fact-specifier\textgreater{} includes variables bound on the LHS to
fact-addresses as described in section 5.4.1.8 or the fact-index of the
desired fact (e.g. 3 for the fact labeled f-3). Note that the fact-index
generally is not known during the execution of a program, so facts
usually are duplicated by binding them on the LHS of a rule. Static
deftemplate checking is not performed when a fact-index is used as the
\textless{}fact-specifier\textgreater{} since the deftemplate being referenced is usually
ambiguous. Only variables or fact indices may be used in a duplicate.
External functions may \sphinxstyleemphasis{not} be called. The value returned by this
function is the fact-address of the newly duplicated fact. If the
assertion of the newly duplicated fact causes an error, or if an
identical copy of the newly duplicated fact already exists in the
fact-list, then the symbol FALSE is returned.

Example

\begin{DUlineblock}{0em}
\item[] (defrule duplicate-part
\item[] ?f1 \textless{}- (duplicate-part ?name)
\item[] ?f2 \textless{}- (part (name ?name))
\item[] =\textgreater{}
\item[] (retract ?f1)
\item[] (duplicate ?f2 (id (gensym*))))
\end{DUlineblock}


\subsection{12.9.5 Asserting a String}
\label{\detokenize{actions:asserting-a-string}}
The \sphinxstylestrong{assert-string} function is similar to assert in that it will add
a fact to the fact-list. How?ever, \sphinxstylestrong{assert-string} takes a single
string representing a fact (expressed in either ordered or deftemplate
format ) and asserts it. Only one fact may be asserted with each
\sphinxstylestrong{assert-string} statement.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{k}{assert}\PYG{o}{\PYGZhy{}}\PYG{n}{string} \PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

If an identical copy of the fact already exists in the fact-list, the
fact will not be added (however, this behavior can be changed, see
sections 13.4.4 and 13.4.5). Fields within the fact may contain a string
by escaping the quote character with a backslash. Note that this
function takes a string and turns it into fields. If the fields within
that string are going to contain special characters (such as a
backslash), they need to be escaped twice (because you are literally
embedding a string within a string and the backslash mechanism ends up
being applied twice). Global variables and expressions can be contained
within the string. The value returned by this function is the
fact-address of the newly created fact. If the assertion of the newly
created fact causes an error, or if an identical copy of the newly
created fact already exists in the fact-list, then the symbol FALSE is
returned.

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (deftemplate foo (slot x) (slot y))

CLIPS\textgreater{} (assert-string “(status valve open)”)

\textless{}Fact-1\textgreater{}

CLIPS\textgreater{} (assert-string “(light "red”)”)

\textless{}Fact-2\textgreater{}

CLIPS\textgreater{} (assert-string “(a\textbackslash{}b "c\textbackslash{}d”)”)

\textless{}Fact-3\textgreater{}

CLIPS\textgreater{} (assert-string “(foo (x 3))”)

\textless{}Fact-4\textgreater{}

CLIPS\textgreater{} (assert-string “(foo (y 7))”)

\textless{}Fact-5\textgreater{}

CLIPS\textgreater{} (facts)

f-0 (initial-fact)

f-1 (status valve open)

f-2 (light “red”)

f-3 (ab “cd”)

f-4 (foo (x 3) (y nil))

f-5 (foo (x nil) (y 7))

For a total of 6 facts.

CLIPS\textgreater{}


\subsection{12.9.6 Getting the Fact-Index of a Fact-address}
\label{\detokenize{actions:getting-the-fact-index-of-a-fact-address}}
The \sphinxstylestrong{fact-index} function returns the fact-index (an integer) of a
fact-address.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n}{address}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

\begin{DUlineblock}{0em}
\item[] (defrule print-fact-indices
\item[] ?f \textless{}- (some-fact \$?)
\item[] =\textgreater{}
\item[] (printout t (fact-index ?f) crlf))
\end{DUlineblock}


\subsection{12.9.7 Determining If a Fact Exists}
\label{\detokenize{actions:determining-if-a-fact-exists}}
The \sphinxstylestrong{fact-existp} returns TRUE if the fact specified by its fact-index
or fact-address arguments exists, otherwise FALSE is returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n}{existp} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n}{address}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{index}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (defglobal ?*x* = (assert (example fact)))

CLIPS\textgreater{} (facts)

f-0 (initial-fact)

f-1 (example fact)

For a total of 2 facts.

CLIPS\textgreater{} (fact-existp 1)

TRUE

CLIPS\textgreater{} (retract 1)

CLIPS\textgreater{} (fact-existp ?*x*)

FALSE

CLIPS\textgreater{}


\subsection{12.9.8 Determining the Deftemplate (Relation) Name Associated with a Fact}
\label{\detokenize{actions:determining-the-deftemplate-relation-name-associated-with-a-fact}}
The \sphinxstylestrong{fact-relation} function returns the deftemplate (relation) name
associated with the fact. FALSE is returned if the specified fact does
not exist.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n}{relation} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n}{address}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{index}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (assert (example fact))

\textless{}Fact-1\textgreater{}

CLIPS\textgreater{} (fact-relation 1)

example

CLIPS\textgreater{}


\subsection{12.9.9 Determining the Slot Names Associated with a Fact}
\label{\detokenize{actions:determining-the-slot-names-associated-with-a-fact}}
The \sphinxstylestrong{fact-slot-names} function returns the slot names associated with
the fact in a multifield value. The symbol \sphinxstyleemphasis{implied} is returned for an
ordered fact (which has a single implied multifield slot). FALSE is
returned if the specified fact does not exist.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{names} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n}{address}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{index}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (deftemplate foo (slot bar) (multislot yak))

CLIPS\textgreater{} (assert (foo (bar 1) (yak 2 3)))

\textless{}Fact-1\textgreater{}

CLIPS\textgreater{} (fact-slot-names 1)

(bar yak)

CLIPS\textgreater{} (assert (another a b c))

\textless{}Fact-2\textgreater{}

CLIPS\textgreater{} (fact-slot-names 2)

(implied)

CLIPS\textgreater{}


\subsection{12.9.10 Retrieving the Slot Value of a Fact}
\label{\detokenize{actions:retrieving-the-slot-value-of-a-fact}}
The \sphinxstylestrong{fact-slot-value} function returns the value of the specified slot
from the specified fact. The symbol \sphinxstyleemphasis{implied} should be used as the slot
name for the implied multifield slot of an ordered fact. FALSE is
returned if the slot name argument is invalid or the specified fact does
not exist.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{value} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n}{address}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{n}{index}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (deftemplate foo (slot bar) (multislot yak))

CLIPS\textgreater{} (assert (foo (bar 1) (yak 2 3)))

\textless{}Fact-1\textgreater{}

CLIPS\textgreater{} (fact-slot-value 1 bar)

1

CLIPS\textgreater{} (fact-slot-value 1 yak)

(2 3)

CLIPS\textgreater{} (assert (another a b c))

\textless{}Fact-2\textgreater{}

CLIPS\textgreater{} (fact-slot-value 2 implied)

(a b c)

CLIPS\textgreater{}


\subsection{12.9.11 Retrieving the Fact-List}
\label{\detokenize{actions:retrieving-the-fact-list}}
The \sphinxstylestrong{get-fact-list} function returns a multifield containing the list
of facts visible to the module specified by \textless{}module-name\textgreater{} or to the
current module if none is specified. If * is specified as the module
name, then all facts are returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (assert (a))

\textless{}Fact-1\textgreater{}

CLIPS\textgreater{} (get-fact-list)

(\textless{}Fact-0\textgreater{} \textless{}Fact-1\textgreater{})

CLIPS\textgreater{} (defmodule B)

CLIPS\textgreater{} (assert (b))

\textless{}Fact-2\textgreater{}

CLIPS\textgreater{} (get-fact-list)

(\textless{}Fact-2\textgreater{})

CLIPS\textgreater{} (get-fact-list MAIN)

(\textless{}Fact-0\textgreater{} \textless{}Fact-1\textgreater{})

CLIPS\textgreater{} (get-fact-list *)

(\textless{}Fact-0\textgreater{} \textless{}Fact-1\textgreater{} \textless{}Fact-2\textgreater{})

CLIPS\textgreater{}


\subsection{12.9.12 Fact-set Queries and Distributed Actions}
\label{\detokenize{actions:fact-set-queries-and-distributed-actions}}
CLIPS provides a useful query system for determining and performing
actions on sets of facts that satisfy user-defined queries. The fact
query system in CLIPS provides six functions, each of which operate on
fact-sets determined by user-defined criteria:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Function}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Purpose}
\\
\hline
any-factp
&
Determines if one or more fact-sets satisfy a query
\\
\hline
find-fact
&
Returns the first fact-set that satisfies a query
\\
\hline
find-all-facts
&
Groups and returns all fact-sets which satisfy a query
\\
\hline
do-for-fact
&
Performs an action for the first fact-set which satisfies a query
\\
\hline
do-for-all-facts
&
Performs an action for every fact-set which satisfies a query as they are found
\\
\hline
delayed-do-for-all-facts
&
Groups all fact-sets which satisfy a query and then iterates an action over this group
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Explanations on how to form fact-set templates, queries and actions
immediately follow, for these definitions are common to all of the query
functions. The specific details of each query function will then be
given. The following is a complete example of a fact-set query function:

Example

{\color{red}\bfseries{}\textbar{}FST\textbar{}}

For all of the examples in this section, assume that the commands below
have already been entered:

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(deftemplate girl

(slot name)

(slot sex (default female))

(slot age (default 4)))

CLIPS\textgreater{}

(deftemplate woman

(slot name)

(slot sex (default female))

(slot age (default 25)))

CLIPS\textgreater{}

(deftemplate boy

(slot name)

(slot sex (default male))

(slot age (default 4)))

CLIPS\textgreater{}

(deftemplate man

(slot name)

(slot sex (default male))

(slot age (default 25)))

CLIPS\textgreater{}

(deffacts PEOPLE

(man (name Man-1) (age 18))

(man (name Man-2) (age 60))

(woman (name Woman-1) (age 18))

(woman (name Woman-2) (age 60))

(woman (name Woman-3))

(boy (name Boy-1) (age 8))

(boy (name Boy-2))

(boy (name Boy-3))

(boy (name Boy-4))

(girl (name Girl-1) (age 8))

(girl (name Girl-2)))

CLIPS\textgreater{} (reset)

CLIPS\textgreater{} (facts)

f-0 (initial-fact)

f-1 (man (name Man-1) (sex male) (age 18))

f-2 (man (name Man-2) (sex male) (age 60))

f-3 (woman (name Woman-1) (sex female) (age 18))

f-4 (woman (name Woman-2) (sex female) (age 60))

f-5 (woman (name Woman-3) (sex female) (age 25))

f-6 (boy (name Boy-1) (sex male) (age 8))

f-7 (boy (name Boy-2) (sex male) (age 4))

f-8 (boy (name Boy-3) (sex male) (age 4))

f-9 (boy (name Boy-4) (sex male) (age 4))

f-10 (girl (name Girl-1) (sex female) (age 8))

f-11 (girl (name Girl-2) (sex female) (age 4))

For a total of 12 facts.

CLIPS\textgreater{}


\subsubsection{12.9.12.1 Fact-set Definition}
\label{\detokenize{actions:fact-set-definition}}
A \sphinxstylestrong{fact-set} is an ordered collection of facts. Each \sphinxstylestrong{fact-set
member} is a member of a set of deftemplates, called \sphinxstylestrong{template
restrictions}, defined by the user. The template restrictions can be
different for each fact-set member. The query functions use \sphinxstylestrong{fact-set
templates} to generate fact-sets. A fact-set template is a set of
\sphinxstylestrong{fact-set member variables} and their associated template
restrictions. Fact-set member variables reference the corresponding
members in each fact-set which matches a template. Variables may be used
to specify the deftemplates for the fact-set template, but if the
constant names of the deftemplates are specified, the deftemplates must
already be defined. Module specifiers may be included with the
deftemplate names; the deftemplates need not be in scope of the current
module.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

::= (\textless{}fact-set-member-template\textgreater{}+)

\textless{}fact-set-member-template\textgreater{}

::= (\textless{}fact-set-member-variable\textgreater{} \textless{}deftemplate-restrictions\textgreater{})

\textless{}fact-set-member-variable\textgreater{} ::= \textless{}single-field-variable\textgreater{}

\textless{}deftemplate-restrictions\textgreater{} ::= \textless{}deftemplate-name-expression\textgreater{}+

Example

One fact-set template might be the ordered pairs of boys or men and
girls or women.

((?man-or-boy boy man) (?woman-or-girl girl woman))

Fact-set member variables (e.g. ?man-or-boy) are bound to
fact-addresses.


\subsubsection{12.9.12.2 Fact-set Determination}
\label{\detokenize{actions:fact-set-determination}}
CLIPS uses straightforward permutations to generate fact-sets that match
a fact-set template from the actual facts in the system. The rules are
as follows:

1) When there is more than one member in a fact-set template, vary the
rightmost members first.

2) When there is more than one deftemplate that an fact-set member can
be, iterate through the deftemplate from left to right.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi )}
\makeatletter\def\p@enumii{\p@enumi \theenumi )}\makeatother
\setcounter{enumi}{2}
\item {} 
Examine facts of a deftemplate in the order that they were defined.

\end{enumerate}

Example

For the fact-set template given in section 12.9.12.1, thirty fact-sets
would be generated in the following order:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\textless{}Fact-6\textgreater{} \textless{}Fact-10\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{15}
\item {} 
\textless{}Fact-9\textgreater{} \textless{}Fact-10\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{1}
\item {} 
\textless{}Fact-6\textgreater{} \textless{}Fact-11\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{16}
\item {} 
\textless{}Fact-9\textgreater{} \textless{}Fact-11\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{2}
\item {} 
\textless{}Fact-6\textgreater{} \textless{}Fact-3\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{17}
\item {} 
\textless{}Fact-9\textgreater{} \textless{}Fact-3\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{3}
\item {} 
.\textless{}Fact-6\textgreater{} \textless{}Fact-4\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{18}
\item {} 
\textless{}Fact-9\textgreater{} \textless{}Fact-4\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{4}
\item {} 
\textless{}Fact-6\textgreater{} \textless{}Fact-5\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{19}
\item {} 
\textless{}Fact-9\textgreater{} \textless{}Fact-5\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{5}
\item {} 
\textless{}Fact-7\textgreater{} \textless{}Fact-10\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{20}
\item {} 
\textless{}Fact-1\textgreater{} \textless{}Fact-10\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{6}
\item {} 
\textless{}Fact-7\textgreater{} \textless{}Fact-11\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{21}
\item {} 
\textless{}Fact-1\textgreater{} \textless{}Fact-11\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{7}
\item {} 
\textless{}Fact-7\textgreater{} \textless{}Fact-3\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{22}
\item {} 
\textless{}Fact-1\textgreater{} \textless{}Fact-3\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{8}
\item {} 
\textless{}Fact-7\textgreater{} \textless{}Fact-4\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{23}
\item {} 
\textless{}Fact-1\textgreater{} \textless{}Fact-4\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{9}
\item {} 
\textless{}Fact-7\textgreater{} \textless{}Fact-5\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{24}
\item {} 
\textless{}Fact-1\textgreater{} \textless{}Fact-5\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{10}
\item {} 
\textless{}Fact-8\textgreater{} \textless{}Fact-10\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{25}
\item {} 
\textless{}Fact-2\textgreater{} \textless{}Fact-10\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{11}
\item {} 
\textless{}Fact-8\textgreater{} \textless{}Fact-11\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{26}
\item {} 
\textless{}Fact-2\textgreater{} \textless{}Fact-11\textgreater{}

\end{enumerate}
\\
\hline
13 \textless{}Fact-8\textgreater{} \textless{}Fact-3\textgreater{}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{27}
\item {} 
\textless{}Fact-2\textgreater{} \textless{}Fact-3\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{13}
\item {} 
\textless{}Fact-8\textgreater{} \textless{}Fact-4\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{28}
\item {} 
\textless{}Fact-2\textgreater{} \textless{}Fact-4\textgreater{}

\end{enumerate}
\\
\hline\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{14}
\item {} 
\textless{}Fact-8\textgreater{} \textless{}Fact-5\textgreater{}

\end{enumerate}
&\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{29}
\item {} 
\textless{}Fact-2\textgreater{} \textless{}Fact-5\textgreater{}

\end{enumerate}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsubsection{12.9.12.3 Query Definition}
\label{\detokenize{actions:query-definition}}\label{\detokenize{actions:query-definition-1}}
A \sphinxstylestrong{query} is a user-defined boolean expression applied to a fact-set
to determine if the fact-set meets further user-defined restrictions. If
the evaluation of this expression for an fact-set is anything but the
symbol FALSE, the fact-set is said to satisfy the query.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}} \PYG{p}{:}\PYG{p}{:}\PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{boolean}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Example

Continuing the previous example, one query might be that the two facts
in an ordered pair have the same age.

(= (fact-slot-value ?man-or-boy age) (fact-slot-value ?woman-or-girl
age))

Within a query, slots of fact-set members can be directly read with a
shorthand notation similar to that used by instances in message-handlers
(see section 9.4.2).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{member}\PYG{o}{\PYGZhy{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Example

The previous example could be rewritten as:

(= ?man-or-boy:age ?woman-or-girl:age)

Since only fact-sets which satisfy a query are of interest, and the
query is evaluated for all possible fact-sets, the query should not have
any side-effects.


\subsubsection{12.9.12.4 Distributed Action Definition}
\label{\detokenize{actions:distributed-action-definition}}\label{\detokenize{actions:distributed-action-definition-1}}
A \sphinxstylestrong{distributed action} is a user-defined expression evaluated for each
fact-set which satisfies a query.

Action Syntax

\textless{}action\textgreater{} ::= \textless{}expression\textgreater{}

Example

Continuing the previous example, one distributed action might be to
simply print out the ordered pair to the screen.

(printout t “(” ?man-or-boy:name “,” ?woman-or-girl:name “)” crlf)


\subsubsection{12.9.12.5 Scope in Fact-set Query Functions}
\label{\detokenize{actions:scope-in-fact-set-query-functions}}
A fact-set query function can be called from anywhere that a regular
function can be called. If a variable from an outer scope is not masked
by a fact-set member variable, then that variable may be referenced
within the query and action. In addition, rebinding variables within a
fact-set function action is allowed. However, attempts to rebind
fact-set member variables will generate errors. Binding variables is not
allowed within a query. Fact-set query functions can be nested.

Example

CLIPS\textgreater{}

(deffunction count-facts (?template)

(bind ?count 0)

(do-for-all-facts ((?fct ?template)) TRUE

(bind ?count (+ ?count 1)))

?count)

CLIPS\textgreater{}

(deffunction count-facts-2 (?template)

(length (find-all-facts ((?fct ?template)) TRUE)))

CLIPS\textgreater{} (count-facts woman)

3

CLIPS\textgreater{} (count-facts-2 boy)

4

CLIPS\textgreater{}

Fact-set member variables are only in scope within the fact-set query
function. Attempting to use fact-set member variables in an outer scope
will generate an error.

Example

CLIPS\textgreater{}

(deffunction last-fact (?template)

(any-factp ((?fct ?template)) TRUE)

?fct)

{[}PRCCODE3{]} Undefined variable fct referenced in deffunction.

ERROR:

(deffunction MAIN::last-fact

(?template)

(any-factp ((?fct ?template))

TRUE)

?fct

)

CLIPS\textgreater{}


\subsubsection{12.9.12.6 Errors during Fact-set Query Functions}
\label{\detokenize{actions:errors-during-fact-set-query-functions}}
If an error occurs during an fact-set query function, the function will
be immediately terminated and the return value will be the symbol FALSE.


\subsubsection{12.9.12.7 Halting and Returning Values from Query Functions}
\label{\detokenize{actions:halting-and-returning-values-from-query-functions}}\label{\detokenize{actions:halting-and-returning-values-from-query-functions-1}}
The functions \sphinxstylestrong{break} and \sphinxstylestrong{return} are now valid inside the action
of the fact-set query functions \sphinxstylestrong{do-for-fact}, \sphinxstylestrong{do-for-all-facts}
and \sphinxstylestrong{delayed-do-for-all-facts}. The \sphinxstylestrong{return} function is only valid
if it is applicable in the outer scope, whereas the \sphinxstylestrong{break} function
actually halts the query.


\subsubsection{12.9.12.8 Fact-set Query Functions}
\label{\detokenize{actions:fact-set-query-functions}}
The fact query system in CLIPS provides six functions. For a given set
of facts, all six query functions will iterate over these facts in the
same order (see section 12.9.12.2). However, if a particular fact is
retracted and reasserted, the iteration order will change.


\paragraph{12.9.12.8.1 Testing if Any Fact-set Satisfies a Query}
\label{\detokenize{actions:testing-if-any-fact-set-satisfies-a-query}}
This function applies a query to each fact-set which matches the
template. If a fact-set satisfies the query, then the function is
immediately terminated, and the return value is the symbol TRUE.
Otherwise, the return value is the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{any}\PYG{o}{\PYGZhy{}}\PYG{n}{factp} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

Are there any men over age 30?

CLIPS\textgreater{} (any-factp ((?man man)) (\textgreater{} ?man:age 30))

TRUE

CLIPS\textgreater{}


\paragraph{12.9.12.8.2 Determining the First Fact-set Satisfying a Query}
\label{\detokenize{actions:determining-the-first-fact-set-satisfying-a-query}}
This function applies a query to each fact-set which matches the
template. If a fact-set satisfies the query, then the function is
immediately terminated, and the fact-set is returned in a multifield
value. Otherwise, the return value is a zero-length multifield value.
Each field of the multifield value is a fact-address representing a
fact-set member.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{find}\PYG{o}{\PYGZhy{}}\PYG{n}{fact} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

Find the first pair of a man and a woman who have the same age.

CLIPS\textgreater{}

(find-fact((?m man) (?w woman)) (= ?m:age ?w:age))

(\textless{}Fact-1\textgreater{} \textless{}Fact-3\textgreater{})

CLIPS\textgreater{}


\paragraph{12.9.12.8.3 Determining All Fact-sets Satisfying a Query}
\label{\detokenize{actions:determining-all-fact-sets-satisfying-a-query}}
This function applies a query to each fact-set which matches the
template. Each fact-set which satisfies the query is stored in a
multifield value. This multifield value is returned when the query has
been applied to all possible fact-sets. If there are n facts in each
fact-set, and m fact-sets satisfied the query, then the length of the
returned multifield value will be n * m. The first n fields correspond
to the first fact-set, and so on. Each field of the multifield value is
an fact-address representing a fact-set member. The multifield value can
consume a large amount of memory due to permutational explosion, so this
function should be used judiciously.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{find}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{facts} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

Find all pairs of a man and a woman who have the same age.

CLIPS\textgreater{}

(find-all-facts ((?m man) (?w woman)) (= ?m:age ?w:age))

(\textless{}Fact-1\textgreater{} \textless{}Fact-3\textgreater{} \textless{}Fact-2\textgreater{} \textless{}Fact-4\textgreater{})

CLIPS\textgreater{}


\paragraph{12.9.12.8.4 Executing an Action for the First Fact-set Satisfying a Query}
\label{\detokenize{actions:executing-an-action-for-the-first-fact-set-satisfying-a-query}}
This function applies a query to each fact-set which matches the
template. If a fact-set satisfies the query, the specified action is
executed, and the function is immediately terminated. The return value
is the evaluation of the action. If no fact-set satisfied the query,
then the return value is the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{do}\PYG{o}{\PYGZhy{}}\PYG{k}{for}\PYG{o}{\PYGZhy{}}\PYG{n}{fact} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

Print out the first triplet of different people that have the same age.
The calls to \sphinxstylestrong{neq} in the query eliminate the permutations where two
or more members of the instance-set are identical.

CLIPS\textgreater{}

(do-for-fact ((?p1 girl boy woman man)

(?p2 girl boy woman man)

(?p3 girl boy woman man))

(and (= ?p1:age ?p2:age ?p3:age)

(neq ?p1 ?p2)

(neq ?p1 ?p3)

(neq ?p2 ?p3))

(printout t ?p1:name ” ” ?p2:name ” ” ?p3:name crlf))

Girl-2 Boy-2 Boy-3

CLIPS\textgreater{}


\paragraph{12.9.12.8.5 Executing an Action for All Fact-sets Satisfying a Query}
\label{\detokenize{actions:executing-an-action-for-all-fact-sets-satisfying-a-query}}
This function applies a query to each fact-set which matches the
template. If a fact-set satisfies the query, the specified action is
executed. The return value is the evaluation of the action for the last
fact-set which satisfied the query. If no fact-set satisfied the query,
then the return value is the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{do}\PYG{o}{\PYGZhy{}}\PYG{k}{for}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{facts} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{query}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{action}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

Print out all triplets of different people that have the same age. The
calls to \sphinxstylestrong{str-compare} limit the fact-sets which satisfy the query to
combinations instead of permutations. Without these restrictions, two
fact-sets which differed only in the order of their members would both
satisfy the query.

CLIPS\textgreater{}

(do-for-all-facts ((?p1 girl boy woman man)

(?p2 girl boy woman man)

(?p3 girl boy woman man))

(and (= ?p1:age ?p2:age ?p3:age)

(\textgreater{} (str-compare ?p1:name ?p2:name) 0)

(\textgreater{} (str-compare ?p2:name ?p3:name) 0))

(printout t ?p1:name ” ” ?p2:name ” ” ?p3:name crlf))

Girl-2 Boy-3 Boy-2

Girl-2 Boy-4 Boy-2

Girl-2 Boy-4 Boy-3

Boy-4 Boy-3 Boy-2

CLIPS\textgreater{}


\paragraph{12.9.12.8.6 Executing a Delayed Action for All Fact-sets Satisfying a Query}
\label{\detokenize{actions:executing-a-delayed-action-for-all-fact-sets-satisfying-a-query}}
This function is similar to \sphinxstylestrong{do-for-all-facts} except that it groups
all fact-sets which satisfy the query into an intermediary multifield
value. If there are no fact-sets which satisfy the query, then the
function returns the symbol FALSE. Otherwise, the specified action is
executed for each fact-set in the multifield value, and the return value
is the evaluation of the action for the last fact-set to satisfy the
query. The intermediary multifield value is discarded. This function can
consume large amounts of memory in the same fashion as
\sphinxstylestrong{find-all-facts}. This function should be used in lieu of
\sphinxstylestrong{do-for-all-facts} when the action applied to one fact-set would
change the result of the query for another fact-set (unless that is the
desired effect).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{delayed}\PYG{o}{\PYGZhy{}}\PYG{n}{do}\PYG{o}{\PYGZhy{}}\PYG{k}{for}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}\PYG{o}{\PYGZhy{}}\PYG{n}{facts} \PYG{o}{\PYGZlt{}}\PYG{n}{fact}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{template}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\textless{}query\textgreater{} \textless{}action\textgreater{}*)

Example

Delete all boys with the greatest age. The test in this case is another
query function which determines if there are any older boys than the one
currently being examined. The action needs to be delayed until all boys
have been processed, or the greatest age will decrease as the older boys
are deleted.

CLIPS\textgreater{} (watch facts)

CLIPS\textgreater{}

(delayed-do-for-all-facts ((?b1 boy))

(not (any-factp ((?b2 boy)) (\textgreater{} ?b2:age ?b1:age)))

(retract ?b1))

\textless{}== f-6 (boy (name Boy-1) (sex male) (age 8))

CLIPS\textgreater{} (unwatch facts)

CLIPS\textgreater{} (reset)

CLIPS\textgreater{} (watch facts)

CLIPS\textgreater{}

(do-for-all-facts ((?b1 boy))

(not (any-factp ((?b2 boy)) (\textgreater{} ?b2:age ?b1:age)))

(retract ?b1))

\textless{}== f-6 (boy (name Boy-1) (sex male) (age 8))

\textless{}== f-7 (boy (name Boy-2) (sex male) (age 4))

\textless{}== f-8 (boy (name Boy-3) (sex male) (age 4))

\textless{}== f-9 (boy (name Boy-4) (sex male) (age 4))

CLIPS\textgreater{} (unwatch facts)

CLIPS\textgreater{}


\section{12.10 Deffacts Functions}
\label{\detokenize{actions:deffacts-functions}}
The following functions provide ancillary capabilities for the deffacts
construct.


\subsection{12.10.1 Getting the List of Deffacts}
\label{\detokenize{actions:getting-the-list-of-deffacts}}
The function \sphinxstylestrong{get-deffacts-list} returns a multifield value containing
the names of all deffacts constructs visible to the module specified by
\textless{}module-name\textgreater{} or to the current module if none is specified. If * is
specified as the module name, then all deffacts are returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{deffacts}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (get-deffacts-list)

(initial-fact)

CLIPS\textgreater{} (deffacts foo)

CLIPS\textgreater{} (get-deffacts-list)

(initial-fact foo)

CLIPS\textgreater{}


\subsection{12.10.2 Determining the Module in which a Deffacts is Defined}
\label{\detokenize{actions:determining-the-module-in-which-a-deffacts-is-defined}}
This function returns the module in which the specified deffacts name is
defined.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deffacts}\PYG{o}{\PYGZhy{}}\PYG{n}{module} \PYG{o}{\PYGZlt{}}\PYG{n}{deffacts}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\section{12.11 Defrule Functions}
\label{\detokenize{actions:defrule-functions}}
The following functions provide ancillary capabilities for the defrule
construct.


\subsection{12.11.1 Getting the List of Defrules}
\label{\detokenize{actions:getting-the-list-of-defrules}}
The function \sphinxstylestrong{get-defrule-list} returns a multifield value containing
the names of all defrule constructs visible to the module specified by
\textless{}module-name\textgreater{} or to the current module if none is specified. If * is
specified as the module name, then all defrules are returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{defrule}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (get-defrule-list)

()

CLIPS\textgreater{} (defrule foo =\textgreater{})

CLIPS\textgreater{} (defrule bar =\textgreater{})

CLIPS\textgreater{} (get-defrule-list)

(foo bar)

CLIPS\textgreater{}


\subsection{12.11.2 Determining the Module in which a Defrule is Defined}
\label{\detokenize{actions:determining-the-module-in-which-a-defrule-is-defined}}
This function returns the module in which the specified defrule name is
defined.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defrule}\PYG{o}{\PYGZhy{}}\PYG{n}{module} \PYG{o}{\PYGZlt{}}\PYG{n}{defrule}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\section{12.12 Agenda Functions}
\label{\detokenize{actions:agenda-functions}}
The following functions provide ancillary capabilities manipulating the
agenda.


\subsection{12.12.1 Getting the Current Focus}
\label{\detokenize{actions:getting-the-current-focus}}
The function \sphinxstylestrong{get-focus} returns the module name of the current focus.
If the focus stack is empty, then the symbol FALSE is returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{focus}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (get-focus)

MAIN

CLIPS\textgreater{} (defmodule A)

CLIPS\textgreater{} (defmodule B)

CLIPS\textgreater{} (focus A B)

TRUE

CLIPS\textgreater{} (get-focus)

A

CLIPS\textgreater{}


\subsection{12.12.2 Getting the Focus Stack}
\label{\detokenize{actions:getting-the-focus-stack}}
The function \sphinxstylestrong{get-focus-stack} returns all of the module names in the
focus stack as a multifield value. A multifield value of length zero is
returned if the focus stack is empty.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{focus}\PYG{o}{\PYGZhy{}}\PYG{n}{stack}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (get-focus-stack)

(MAIN)

CLIPS\textgreater{} (clear-focus-stack)

CLIPS\textgreater{} (get-focus-stack)

()

CLIPS\textgreater{} (defmodule A)

CLIPS\textgreater{} (defmodule B)

CLIPS\textgreater{} (focus A B)

TRUE

CLIPS\textgreater{} (get-focus-stack)

(A B)

CLIPS\textgreater{}


\subsection{12.12.3 Removing the Current Focus from the Focus Stack}
\label{\detokenize{actions:removing-the-current-focus-from-the-focus-stack}}
The function \sphinxstylestrong{pop-focus} removes the current focus from the focus
stack and returns the module name of the current focus. If the focus
stack is empty, then the symbol FALSE is returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{pop}\PYG{o}{\PYGZhy{}}\PYG{n}{focus}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (list-focus-stack)

MAIN

CLIPS\textgreater{} (pop-focus)

MAIN

CLIPS\textgreater{} (defmodule A)

CLIPS\textgreater{} (defmodule B)

CLIPS\textgreater{} (focus A B)

TRUE

CLIPS\textgreater{} (list-focus-stack)

A

B

MAIN

CLIPS\textgreater{} (pop-focus)

A

CLIPS\textgreater{} (list-focus-stack)

B

CLIPS\textgreater{}


\section{12.13 Defglobal Functions}
\label{\detokenize{actions:defglobal-functions}}
The following functions provide ancillary capabilities for the defglobal
construct.


\subsection{12.13.1 Getting the List of Defglobals}
\label{\detokenize{actions:getting-the-list-of-defglobals}}
The function \sphinxstylestrong{get-defglobal-list} returns a multifield value
containing the names of all global variables visible to the module
specified by \textless{}module-name\textgreater{} or to the current module if none is
specified. If * is specified as the module name, then all globals are
returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{defglobal}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (get-defglobal-list)

()

CLIPS\textgreater{} (defglobal ?*x* = 3 ?*y* = 5)

CLIPS\textgreater{} (get-defglobal-list)

(x y)

CLIPS\textgreater{}


\subsection{12.13.2 Determining the Module in which a Defglobal is Defined}
\label{\detokenize{actions:determining-the-module-in-which-a-defglobal-is-defined}}
This function returns the module in which the specified defglobal name
is defined.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defglobal}\PYG{o}{\PYGZhy{}}\PYG{n}{module} \PYG{o}{\PYGZlt{}}\PYG{n}{defglobal}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\section{12.14 Deffunction Functions}
\label{\detokenize{actions:deffunction-functions}}
The following functions provide ancillary capabilities for the
deffunction construct.


\subsection{12.14.1 Getting the List of Deffunctions}
\label{\detokenize{actions:getting-the-list-of-deffunctions}}
The function \sphinxstylestrong{get-deffunction-list} returns a multifield value
containing the names of all deffunction constructs visible to the module
specified by \textless{}module-name\textgreater{} or to the current module if none is
specified. If * is specified as the module name, then all deffunctions
are returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{deffunction}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (get-deffunction-list)

()

CLIPS\textgreater{} (deffunction foo ())

CLIPS\textgreater{} (deffunction bar ())

CLIPS\textgreater{} (get-deffunction-list)

(foo bar)

CLIPS\textgreater{}


\subsection{12.14.2 Determining the Module in which a Deffunction is Defined}
\label{\detokenize{actions:determining-the-module-in-which-a-deffunction-is-defined}}
This function returns the module in which the specified deffunction name
is defined.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{deffunction}\PYG{o}{\PYGZhy{}}\PYG{n}{module} \PYG{o}{\PYGZlt{}}\PYG{n}{deffunction}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\section{12.15 Generic Function Functions}
\label{\detokenize{actions:generic-function-functions}}
The following functions provide ancillary capabilities for generic
function methods.


\subsection{12.15.1 Getting the List of Defgenerics}
\label{\detokenize{actions:getting-the-list-of-defgenerics}}
The function \sphinxstylestrong{get-defgeneric-list} returns a multifield value
containing the names of all defgeneric constructs that are currently
defined.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{defgeneric}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (get-defgeneric-list)

()

CLIPS\textgreater{} (defgeneric foo)

CLIPS\textgreater{} (defgeneric bar)

CLIPS\textgreater{} (get-defgeneric-list)

(foo bar)

CLIPS\textgreater{}


\subsection{12.15.2 Determining the Module in which a Generic Function is Defined}
\label{\detokenize{actions:determining-the-module-in-which-a-generic-function-is-defined}}
This function returns the module in which the specified defgeneric name
is defined.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defgeneric}\PYG{o}{\PYGZhy{}}\PYG{n}{module} \PYG{o}{\PYGZlt{}}\PYG{n}{defgeneric}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.15.3 Getting the List of Defmethods}
\label{\detokenize{actions:getting-the-list-of-defmethods}}
The function \sphinxstylestrong{get-defmethod-list} returns a multifield value
containing method name/indices pairs for all defmethod constructs that
are currently defined. The optional generic-function name parameter
restricts the methods return to only those of the specified generic
function.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{defmethod}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{generic}\PYG{o}{\PYGZhy{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (get-defmethod-list)

()

CLIPS\textgreater{} (defmethod foo ((?x STRING)))

CLIPS\textgreater{} (defmethod foo ((?x INTEGER)))

CLIPS\textgreater{} (defmethod bar ((?x STRING)))

CLIPS\textgreater{} (defmethod bar ((?x INTEGER)))

CLIPS\textgreater{} (get-defmethod-list)

(foo 1 foo 2 bar 1 bar 2)

CLIPS\textgreater{} (get-defmethod-list foo)

(foo 1 foo 2)

CLIPS\textgreater{}


\subsection{12.15.4 Type Determination}
\label{\detokenize{actions:type-determination}}
The function \sphinxstylestrong{type} returns a symbol which is the name of the type (or
class) of its of argument. This function is equivalent to the \sphinxstylestrong{class}
function (see section 12.16.4.4), but, unlike the \sphinxstylestrong{class} function, it
is available even when COOL is not installed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{type} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (type (+ 2 2))

INTEGER

CLIPS\textgreater{} (defclass CAR (is-a USER))

CLIPS\textgreater{} (make-instance Rolls-Royce of CAR)

{[}Rolls-Royce{]}

CLIPS\textgreater{} (type Rolls-Royce)

SYMBOL

CLIPS\textgreater{} (type {[}Rolls-Royce{]})

CAR

CLIPS\textgreater{}


\subsection{12.15.5 Existence of Shadowed Methods}
\label{\detokenize{actions:existence-of-shadowed-methods}}
If called from a method for a generic function, the function
\sphinxstylestrong{next-methodp} will return the symbol TRUE if there is another method
shadowed (see section 8.5.3) by the current one. Otherwise, the function
will return the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{next}\PYG{o}{\PYGZhy{}}\PYG{n}{methodp}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.15.6 Calling Shadowed Methods}
\label{\detokenize{actions:calling-shadowed-methods}}
If the conditions are such that the function \sphinxstylestrong{next-methodp} would
return the symbol TRUE (see section 12.15.5), then calling the function
\sphinxstylestrong{call-next-method} will execute the shadowed (see section 8.5.3)
method. Otherwise, a method execution error will occur (see section
8.5.4). In the event of an error, the return value of this function is
the symbol FALSE, otherwise it is the return value of the shadowed
method. The shadowed method is passed the same arguments as the calling
method.

A method may continue execution after calling \sphinxstylestrong{call-next-method}. In
addition, a method may make multiple calls to \sphinxstylestrong{call-next-method}, and
the same shadowed method will be executed each time.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{call}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{next}\PYG{o}{\PYGZhy{}}\PYG{n}{method}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{}

(defmethod describe ((?a INTEGER))

(if (next-methodp) then

(bind ?extension (str-cat ” ” (call-next-method)))

else

(bind ?extension “”))

(str-cat “INTEGER” ?extension))

CLIPS\textgreater{} (describe 3)

“INTEGER”

CLIPS\textgreater{}

(defmethod describe ((?a NUMBER))

“NUMBER”)

CLIPS\textgreater{} (describe 3)

“INTEGER NUMBER”

CLIPS\textgreater{} (describe 3.0)

“NUMBER”

CLIPS\textgreater{}


\subsection{12.15.7 Calling Shadowed Methods with Overrides}
\label{\detokenize{actions:calling-shadowed-methods-with-overrides}}
The function \sphinxstylestrong{override-next-method} is similar to
\sphinxstylestrong{call-next-method}, except that new arguments can be provided. This
allows one method to act as a wrapper for another and set up a special
environment for the shadowed method. From the set of methods which are
more general than the currently executing one, the most specific method
which is applicable to the new arguments is executed. (In contrast,
\sphinxstylestrong{call-next-method} calls the next most specific method which is
applicable to the same arguments as the currently executing one
received.) A recursive call to the generic function itself should be
used in lieu of \sphinxstylestrong{override-next-method} if the most specific of all
methods for the generic function which is applicable to the new
arguments should be executed.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{override}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{next}\PYG{o}{\PYGZhy{}}\PYG{n}{method} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(defmethod + ((?a INTEGER) (?b INTEGER))

(override-next-method (* ?a 2) (* ?b 3)))

CLIPS\textgreater{} (list-defmethods +)
\begin{itemize}
\item {} 
\#2 (INTEGER) (INTEGER)

\item {} 
\#SYS1 (NUMBER) (NUMBER) (\$? NUMBER)

\end{itemize}

For a total of 2 methods.

CLIPS\textgreater{} (preview-generic + 1 2)
\begin{itemize}
\item {} 
\#2 (INTEGER) (INTEGER)

\item {} 
\#SYS1 (NUMBER) (NUMBER) (\$? NUMBER)

\end{itemize}

CLIPS\textgreater{} (watch methods)

CLIPS\textgreater{} (+ 1 2)

MTH \textgreater{}\textgreater{} +:\#2 ED:1 (1 2)

MTH \textgreater{}\textgreater{} +:\#SYS1 ED:2 (2 6)

MTH \textless{}\textless{} +:\#SYS1 ED:2 (2 6)

MTH \textless{}\textless{} +:\#2 ED:1 (1 2)

8

CLIPS\textgreater{} (unwatch methods)

CLIPS\textgreater{}


\subsection{12.15.8 Calling a Specific Method}
\label{\detokenize{actions:calling-a-specific-method}}
The function \sphinxstylestrong{call-specific-method} allows the user to call a
particular method of a generic function without regards to method
precedence. This allows the user to bypass method precedence when
absolutely necessary. The method must be applicable to the arguments
passed. Shadowed methods can still be called via \sphinxstylestrong{call-next-method}
and \sphinxstylestrong{override-next-method}.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{call}\PYG{o}{\PYGZhy{}}\PYG{n}{specific}\PYG{o}{\PYGZhy{}}\PYG{n}{method} \PYG{o}{\PYGZlt{}}\PYG{n}{generic}\PYG{o}{\PYGZhy{}}\PYG{n}{function}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{method}\PYG{o}{\PYGZhy{}}\PYG{n}{index}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\textless{}expression\textgreater{}*)

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(defmethod + ((?a INTEGER) (?b INTEGER))

(* (- ?a ?b) (- ?b ?a)))

CLIPS\textgreater{} (list-defmethods +)
\begin{itemize}
\item {} 
\#2 (INTEGER) (INTEGER)

\item {} 
\#SYS1 (NUMBER) (NUMBER) (\$? NUMBER)

\end{itemize}

For a total of 2 methods.

CLIPS\textgreater{} (preview-generic + 1 2)
\begin{itemize}
\item {} 
\#2 (INTEGER) (INTEGER)

\item {} 
\#SYS1 (NUMBER) (NUMBER) (\$? NUMBER)

\end{itemize}

CLIPS\textgreater{} (watch methods)

CLIPS\textgreater{} (+ 1 2)

MTH \textgreater{}\textgreater{} +:\#2 ED:1 (1 2)

MTH \textless{}\textless{} +:\#2 ED:1 (1 2)

-1

CLIPS\textgreater{} (call-specific-method + 1 1 2)

MTH \textgreater{}\textgreater{} +:\#SYS1 ED:1 (1 2)

MTH \textless{}\textless{} +:\#SYS1 ED:1 (1 2)

3

CLIPS\textgreater{} (unwatch methods)

CLIPS\textgreater{}


\subsection{12.15.9 Getting the Restrictions of Defmethods}
\label{\detokenize{actions:getting-the-restrictions-of-defmethods}}
The function \sphinxstylestrong{get-method-restrictions} returns a multifield value
containing information about the restrictions for the specified method
using the following format:

\textless{}minimum-number-of-arguments\textgreater{}

\textless{}maximum-number-of-arguments\textgreater{} (can be -1 for wildcards)

\textless{}number-of-restrictions\textgreater{}

\textless{}multifield-index-of-first-restriction-info\textgreater{}

.

.

.

\textless{}multifield-index-of-nth-restriction-info\textgreater{}

\textless{}first-restriction-query\textgreater{} (TRUE or FALSE)

\textless{}first-restriction-class-count\textgreater{}

\textless{}first-restriction-first-class\textgreater{}

.

.

.

\textless{}first-restriction-nth-class\textgreater{}

.

.

.

\textless{}mth-restriction-class-count\textgreater{}

\textless{}mth-restriction-first-class\textgreater{}

.

.

.

\textless{}mth-restriction-nth-class\textgreater{}

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{method}\PYG{o}{\PYGZhy{}}\PYG{n}{restrictions} \PYG{o}{\PYGZlt{}}\PYG{n}{generic}\PYG{o}{\PYGZhy{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\textless{}method-index\textgreater{})

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(defmethod foo 50 ((?a INTEGER SYMBOL) (?b (= 1 1)) \$?c))

CLIPS\textgreater{} (get-method-restrictions foo 50)

(2 -1 3 7 11 13 FALSE 2 INTEGER SYMBOL TRUE 0 FALSE 0)

CLIPS\textgreater{}


\section{12.16 CLIPS Object-Oriented Language (COOL) Functions}
\label{\detokenize{actions:clips-object-oriented-language-cool-functions}}
The following functions provide ancillary capabilities for COOL.


\subsection{12.16.1 Class Functions}
\label{\detokenize{actions:class-functions}}

\subsubsection{12.16.1.1 Getting the List of Defclasses}
\label{\detokenize{actions:getting-the-list-of-defclasses}}
The function \sphinxstylestrong{get-defclass-list} returns a multifield value containing
the names of all defclass constructs visible to the module specified by
\textless{}module-name\textgreater{} or to the current module if none is specified. If * is
specified as the module name, then all defclasses are returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{defclass}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (get-defclass-list)

(FLOAT INTEGER SYMBOL STRING MULTIFIELD EXTERNAL-ADDRESS FACT-ADDRESS
INSTANCE-ADDRESS INSTANCE-NAME OBJECT PRIMITIVE NUMBER LEXEME ADDRESS
INSTANCE USER INITIAL-OBJECT)

CLIPS\textgreater{} (defclass FOO (is-a USER))

CLIPS\textgreater{} (defclass BAR (is-a USER))

CLIPS\textgreater{} (get-defclass-list)

(FLOAT INTEGER SYMBOL STRING MULTIFIELD EXTERNAL-ADDRESS FACT-ADDRESS
INSTANCE-ADDRESS INSTANCE-NAME OBJECT PRIMITIVE NUMBER LEXEME ADDRESS
INSTANCE USER INITIAL-OBJECT FOO BAR)

CLIPS\textgreater{}


\subsubsection{12.16.1.2 Determining the Module in which a Defclass is Defined}
\label{\detokenize{actions:determining-the-module-in-which-a-defclass-is-defined}}
This function returns the module in which the specified defclass name is
defined.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{defclass}\PYG{o}{\PYGZhy{}}\PYG{n}{module} \PYG{o}{\PYGZlt{}}\PYG{n}{defclass}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.1.3 Determining if a Class Exists}
\label{\detokenize{actions:determining-if-a-class-exists}}
This function returns the symbol TRUE if the specified class is defined,
FALSE otherwise.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{existp} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.1.4 Superclass Determination}
\label{\detokenize{actions:superclass-determination}}
This function returns the symbol TRUE if the first class is a superclass
of the second class, FALSE otherwise.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{superclassp} \PYG{o}{\PYGZlt{}}\PYG{n}{class1}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{class2}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.1.5 Subclass Determination}
\label{\detokenize{actions:subclass-determination}}
This function returns the symbol TRUE if the first class is a subclass
of the second class, FALSE otherwise.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{subclassp} \PYG{o}{\PYGZlt{}}\PYG{n}{class1}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{class2}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.1.6 Slot Existence}
\label{\detokenize{actions:slot-existence}}
This function returns the symbol TRUE if the specified slot is present
in the specified class, FALSE otherwise. If the \sphinxstyleemphasis{inherit} keyword is
specified then the slot may be inherited, otherwise it must be directly
defined in the specified class.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{existp} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{inherit}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.1.7 Testing whether a Slot is Writable}
\label{\detokenize{actions:testing-whether-a-slot-is-writable}}
This function returns the symbol TRUE if the specified slot in the
specified class is writable (see section 9.3.3.4). Otherwise, it returns
the symbol FALSE. An error is generated if the specified class or slot
does not exist.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{writablep} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.1.8 Testing whether a Slot is Initializable}
\label{\detokenize{actions:testing-whether-a-slot-is-initializable}}
This function returns the symbol TRUE if the specified slot in the
specified class is initializable (see section 9.3.3.4). Otherwise, it
returns the symbol FALSE. An error is generated if the specified class
or slot does not exist.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{initablep} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.1.9 Testing whether a Slot is Public}
\label{\detokenize{actions:testing-whether-a-slot-is-public}}
This function returns the symbol TRUE if the specified slot in the
specified class is public (see section 9.3.3.8). Otherwise, it returns
the symbol FALSE. An error is generated if the specified class or slot
does not exist.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{publicp} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.1.10 Testing whether a Slot can be Accessed Directly}
\label{\detokenize{actions:testing-whether-a-slot-can-be-accessed-directly}}
This function returns the symbol TRUE if the specified slot in the
specified class can be accessed directly (see section 9.4.2). Otherwise,
it returns the symbol FALSE. An error is generated if the specified
class or slot does not exist.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{direct}\PYG{o}{\PYGZhy{}}\PYG{n}{accessp} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.1.11 Message-handler Existence}
\label{\detokenize{actions:message-handler-existence}}
This function returns the symbol TRUE if the specified message-handler
is defined (directly only, not by inheritance) for the class, FALSE
otherwise.

\sphinxcode{\sphinxupquote{Syntax}}

Defaults are in \sphinxstylestrong{bold italics}.

(message-handler-existp \textless{}class-name\textgreater{} \textless{}handler-name\textgreater{} {[}\textless{}handler-type\textgreater{}{]})

\textless{}handler-type\textgreater{} ::= around \textbar{} before \textbar{} \sphinxstylestrong{primary} \textbar{} after


\subsubsection{12.16.1.12 Determining if a Class can have Direct Instances}
\label{\detokenize{actions:determining-if-a-class-can-have-direct-instances}}
This function returns the symbol TRUE if the specified class is
abstract, i.e. the class cannot have direct instances, FALSE otherwise.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{abstractp} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.1.13 Determining if a Class can Satisfy Object Patterns}
\label{\detokenize{actions:determining-if-a-class-can-satisfy-object-patterns}}
This function returns the symbol TRUE if the specified class is
reactive, i.e. objects of the class can match object patterns, FALSE
otherwise.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{reactivep} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.1.14 Getting the List of Superclasses for a Class}
\label{\detokenize{actions:getting-the-list-of-superclasses-for-a-class}}
This function groups the names of the direct superclasses of a class
into a multifield variable. If the optional argument ?inherit? is given,
indirect superclasses are also included. A multifield of length zero is
returned if an error occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{superclasses} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{inherit}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (class-superclasses INTEGER)

(NUMBER)

CLIPS\textgreater{} (class-superclasses INTEGER inherit)

(NUMBER PRIMITIVE OBJECT)

CLIPS\textgreater{}


\subsubsection{12.16.1.15 Getting the List of Subclasses for a Class}
\label{\detokenize{actions:getting-the-list-of-subclasses-for-a-class}}
This function groups the names of the direct subclasses of a class into
a multifield variable. If the optional argument ?inherit? is given,
indirect subclasses are also included. A multifield of length zero is
returned if an error occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{subclasses} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{inherit}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (class-subclasses PRIMITIVE)

(NUMBER LEXEME MULTIFIELD ADDRESS INSTANCE)

CLIPS\textgreater{} (class-subclasses PRIMITIVE inherit)

(NUMBER INTEGER FLOAT LEXEME SYMBOL STRING MULTIFIELD ADDRESS
EXTERNAL-ADDRESS FACT-ADDRESS INSTANCE-ADDRESS INSTANCE INSTANCE-NAME)

CLIPS\textgreater{}


\subsubsection{12.16.1.16 Getting the List of Slots for a Class}
\label{\detokenize{actions:getting-the-list-of-slots-for-a-class}}
This function groups the names of the explicitly defined slots of a
class into a multifield variable. If the optional argument ?inherit? is
given, inherited slots are also included. A multifield of length zero is
returned if an error occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{slots} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{inherit}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (defclass A (is-a USER) (slot x))

CLIPS\textgreater{} (defclass B (is-a A) (slot y))

CLIPS\textgreater{} (class-slots B)
\begin{enumerate}
\def\theenumi{\alph{enumi}}
\def\labelenumi{(\theenumi )}
\makeatletter\def\p@enumii{\p@enumi (\theenumi )}\makeatother
\setcounter{enumi}{24}
\item {} 
\end{enumerate}

CLIPS\textgreater{} (class-slots B inherit)

(x y)

CLIPS\textgreater{}


\subsubsection{12.16.1.17 Getting the List of Message-Handlers for a Class}
\label{\detokenize{actions:getting-the-list-of-message-handlers-for-a-class}}
This function groups the class names, message names and message types of
the message-handlers attached direct to class into a multifield variable
(implicit slot-accessors are not included). If the optional argument
?inherit? is given, inherited message-handlers are also included. A
multifield of length zero is returned if an error occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{defmessage}\PYG{o}{\PYGZhy{}}\PYG{n}{handler}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{inherit}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{} (defmessage-handler A foo ())

CLIPS\textgreater{} (get-defmessage-handler-list A)

(A foo primary)

CLIPS\textgreater{} (get-defmessage-handler-list A inherit)

(USER init primary USER delete primary USER create primary USER print
primary USER direct-modify primary USER message-modify primary USER
direct-duplicate primary USER message-duplicate primary A foo primary)

CLIPS\textgreater{}


\subsubsection{12.16.1.18 Getting the List of Facets for a Slot}
\label{\detokenize{actions:getting-the-list-of-facets-for-a-slot}}
This function returns a multifield listing the facet values for the
specified slot (the slot can be inherited or explicitly defined for the
class). A multifield of length zero is returned if an error occurs.
Following is a table indicating what each field represents and its
possible values:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Field}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Meaning}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Values}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Explanation}
\\
\hline
1
&
Field Type
&
SGL/MLT
&
Single-field or multifield
\\
\hline
2
&
Default Value
&
STC/DYN/NIL
&
Static, dynamic, or none
\\
\hline
3
&
Inheritance
&
INH/NIL
&
Inheritable by other classes or not
\\
\hline
4
&
Access
&
RW/R/INT
&
Read-write, read-only, or initialize-only
\\
\hline
5
&
Storage
&
LCL/SHR
&
Local or shared
\\
\hline
6
&
Pattern-Match
&
RCT/NIL
&
Reactive or non-reactive
\\
\hline
7
&
Source
&
EXC/CMP
&
Exclusive or composite
\\
\hline
8
&
Visibility
&
PUB/PRV
&
Public or private
\\
\hline
9
&
Automatic Accessors
&
R/W/RW/NIL
&
Read, write, read-write, or none
\\
\hline
10
&
Override-Message
&
\textless{}message-name\textgreater{}
&
Name of message sent for slot-overrides
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

See section 9.3.3 for more details on slot facets.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{facets} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (defclass A (is-a USER) (slot x (access read-only)))

CLIPS\textgreater{} (defclass B (is-a A) (multislot y))

CLIPS\textgreater{} (slot-facets B x)

(SGL STC INH R SHR RCT EXC PRV R NIL)

CLIPS\textgreater{} (slot-facets B y)

(MLT STC INH RW LCL RCT EXC PRV RW put-y)

CLIPS\textgreater{}\textgreater{}


\subsubsection{12.16.1.19 Getting the List of Source Classes for a Slot}
\label{\detokenize{actions:getting-the-list-of-source-classes-for-a-slot}}
This function groups the names of the classes which provide facets for a
slot of a class into a multifield variable. In the case of an exclusive
slot, this multifield will be of length one and contain the name of the
contributing class. However, composite slots may have facets from many
different classes (see section 9.3.3.6). A multifield of length zero is
returned if an error occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{sources} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot x (access read-only)))

CLIPS\textgreater{}

(defclass B (is-a A)

(slot x (source composite)

(default 100)))

CLIPS\textgreater{} (defclass C (is-a B))

CLIPS\textgreater{} (slot-sources A x)
\begin{enumerate}
\def\theenumi{\Alph{enumi}}
\def\labelenumi{(\theenumi )}
\makeatletter\def\p@enumii{\p@enumi (\theenumi )}\makeatother
\item {} 
\end{enumerate}

CLIPS\textgreater{} (slot-sources B x)

(A B)

CLIPS\textgreater{} (slot-sources C x)

(A B)

CLIPS\textgreater{}


\subsubsection{12.16.1.20 Getting the Primitive Types for a Slot}
\label{\detokenize{actions:getting-the-primitive-types-for-a-slot}}
This function groups the names of the primitive types allowed for a slot
into a multifield variable. A multifield of length zero is returned if
an error occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{types} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (defclass A (is-a USER) (slot y (type INTEGER LEXEME)))

CLIPS\textgreater{} (slot-types A y)

(INTEGER SYMBOL STRING)

CLIPS\textgreater{}


\subsubsection{12.16.1.21 Getting the Cardinality for a Slot}
\label{\detokenize{actions:getting-the-cardinality-for-a-slot}}
This function groups the minimum and maximum cardinality allowed for a
multifield slot into a multifield variable. A maximum cardinality of
infinity is indicated by the symbol \sphinxstylestrong{+oo} (the plus character followed
by two lowercase o?s?not zeroes). A multifield of length zero is
returned for single field slots or if an error occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{cardinality} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot x)

(multislot y (cardinality ?VARIABLE 5))

(multislot z (cardinality 3 ?VARIABLE)))

CLIPS\textgreater{} (slot-cardinality A x)

()

CLIPS\textgreater{} (slot-cardinality A y)

(0 5)

CLIPS\textgreater{} (slot-cardinality A z)

(3 +oo)

CLIPS\textgreater{}


\subsubsection{12.16.1.22 Getting the Allowed Values for a Slot}
\label{\detokenize{actions:getting-the-allowed-values-for-a-slot}}
This function groups the allowed values for a slot (specified in any of
allowed-? facets for the slots) into a multifield variable. If no
allowed-? facets were specified for the slot, then the symbol FALSE is
returned. A multifield of length zero is returned if an error occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{allowed}\PYG{o}{\PYGZhy{}}\PYG{n}{values} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot x)

(slot y (allowed-integers 2 3) (allowed-symbols foo)))

CLIPS\textgreater{} (slot-allowed-values A x)

FALSE

CLIPS\textgreater{} (slot-allowed-values A y)

(2 3 foo)

CLIPS\textgreater{}


\subsubsection{12.16.1.23 Getting the Numeric Range for a Slot}
\label{\detokenize{actions:getting-the-numeric-range-for-a-slot}}
This function groups the minimum and maximum numeric ranges allowed a
slot into a multifield variable. A minimum value of infinity is
indicated by the symbol \sphinxstylestrong{-oo} (the minus character followed by two
lowercase o?s?not zeroes). A maximum value of infinity is indicated by
the symbol \sphinxstylestrong{+oo} (the plus character followed by two lowercase o?s?not
zeroes). The symbol FALSE is returned for slots in which numeric values
are not allowed. A multifield of length zero is returned if an error
occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{range} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot x)

(slot y (type SYMBOL))

(slot z (range 3 10)))

CLIPS\textgreater{} (slot-range A x)

(-oo +oo)

CLIPS\textgreater{} (slot-range A y)

FALSE

CLIPS\textgreater{} (slot-range A z)

(3 10)

CLIPS\textgreater{}


\subsubsection{12.16.1.24 Getting the Default Value for a Slot}
\label{\detokenize{actions:getting-the-default-value-for-a-slot}}
This function returns the default value associated with a slot. If a
slot has a dynamic default, the expression will be evaluated when this
function is called. The symbol FALSE is returned if an error occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{default}\PYG{o}{\PYGZhy{}}\PYG{n}{value} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot x (default 3))

(multislot y (default a b c))

(slot z (default-dynamic (gensym))))

CLIPS\textgreater{} (slot-default-value A x)

3

CLIPS\textgreater{} (slot-default-value A y)

(a b c)

CLIPS\textgreater{} (slot-default-value A z)

gen1

CLIPS\textgreater{} (slot-default-value A z)

gen2

CLIPS\textgreater{}


\subsubsection{12.16.1.25 Setting the Defaults Mode for Classes}
\label{\detokenize{actions:setting-the-defaults-mode-for-classes}}
This function sets the defaults mode used when classes are defined. The
old mode is the return value of this function.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{defaults}\PYG{o}{\PYGZhy{}}\PYG{n}{mode} \PYG{o}{\PYGZlt{}}\PYG{n}{mode}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

where \textless{}mode\textgreater{} is either convenience or conservation. By default, the
class defaults mode is convenience. If the mode is convenience, then for
the purposes of role inheritance, system defined class behave as
concrete classes; for the purpose of pattern-match inheritance, system
defined classes behave as reactive classes unless the inheriting class
is abstract; and the default setting for the create-accessor facet of
the class? slots is read-write. If the class defaults mode is
conservation, then the role and reactivity of system-defined classes is
unchanged for the purposes of role and pattern-match inheritance and the
default setting for the create-accessor facet of the class? slots is
?NONE.


\subsubsection{12.16.1.26 Getting the Defaults Mode for Classes}
\label{\detokenize{actions:getting-the-defaults-mode-for-classes}}
This function returns the current defaults mode used when classes are
defined (convenience or conservation).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{defaults}\PYG{o}{\PYGZhy{}}\PYG{n}{mode}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.1.27 Getting the Allowed Values for a Slot}
\label{\detokenize{actions:getting-the-allowed-values-for-a-slot-1}}\label{\detokenize{actions:id5}}
This function groups the allowed classes for a slot (specified by the
allowed-classes facet for the slot) into a multifield variable. If the
allowed-classes facet was not specified for the slot, then the symbol
FALSE is returned. A multifield of length zero is returned if an error
occurs.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{allowed}\PYG{o}{\PYGZhy{}}\PYG{n}{classes} \PYG{o}{\PYGZlt{}}\PYG{n}{class}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{} (defclass B (is-a USER) (slot x))

CLIPS\textgreater{} (defclass C (is-a USER) (slot y (allowed-classes A B)))

CLIPS\textgreater{} (slot-allowed-classes B x)

FALSE

CLIPS\textgreater{} (slot-allowed-classes C y)

(A B)

CLIPS\textgreater{}


\subsection{12.16.2 Message-handler Functions}
\label{\detokenize{actions:message-handler-functions}}

\subsubsection{12.16.2.1 Existence of Shadowed Handlers}
\label{\detokenize{actions:existence-of-shadowed-handlers}}
This function returns the symbol TRUE if there is another
message-handler available for execution, FALSE otherwise. If this
function is called from an around handler and there are any shadowed
handlers (see section 9.5.3), the return value is the symbol TRUE. If
this function is called from a primary handler and there are any
shadowed primary handlers, the return value is the symbol TRUE. In any
other circumstance, the return value is the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{next}\PYG{o}{\PYGZhy{}}\PYG{n}{handlerp}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.2.2 Calling Shadowed Handlers}
\label{\detokenize{actions:calling-shadowed-handlers}}
If the conditions are such that the function \sphinxstylestrong{next-handlerp} would
return the symbol TRUE, then calling this function will execute the
shadowed method. Otherwise, a message execution error (see section
9.5.4) will occur. In the event of an error, the return value of this
function is the symbol FALSE, otherwise it is the return value of the
shadowed handler. The shadowed handler is passed the same arguments as
the calling handler.

A handler may continue execution after calling \sphinxstylestrong{call-next-handler}. In
addition, a handler may make multiple calls to \sphinxstylestrong{call-next-handler},
and the same shadowed handler will be executed each time.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{call}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{next}\PYG{o}{\PYGZhy{}}\PYG{n}{handler}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{}

(defmessage-handler A print-args (\$?any)

(printout t “A: ” ?any crlf)

(if (next-handlerp) then

(call-next-handler)))

CLIPS\textgreater{}

(defmessage-handler USER print-args (\$?any)

(printout t “USER: ” ?any crlf))

CLIPS\textgreater{} (make-instance a of A)

{[}a{]}

CLIPS\textgreater{} (send {[}a{]} print-args 1 2 3 4)

A: (1 2 3 4)

USER: (1 2 3 4)

CLIPS\textgreater{}


\subsubsection{12.16.2.3 Calling Shadowed Handlers with Different Arguments}
\label{\detokenize{actions:calling-shadowed-handlers-with-different-arguments}}
This function is identical to \sphinxstylestrong{call-next-handler} except that this
function can change the arguments passed to the shadowed handler.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{override}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{next}\PYG{o}{\PYGZhy{}}\PYG{n}{handler} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{}

(defmessage-handler A print-args (\$?any)

(printout t “A: ” ?any crlf)

(if (next-handlerp) then

(override-next-handler (rest\$ ?any))))

CLIPS\textgreater{}

(defmessage-handler USER print-args (\$?any)

(printout t “USER: ” ?any crlf))

CLIPS\textgreater{} (make-instance a of A)

{[}a{]}

CLIPS\textgreater{} (send {[}a{]} print-args 1 2 3 4)

A: (1 2 3 4)

USER: (2 3 4)

CLIPS\textgreater{}


\subsection{12.16.3 Definstances Functions}
\label{\detokenize{actions:definstances-functions}}

\subsubsection{12.16.3.1 Getting the List of Definstances}
\label{\detokenize{actions:getting-the-list-of-definstances}}
The function \sphinxstylestrong{get-definstances-list} returns a multifield value
containing the names of all definstances constructs visible to the
module specified by \textless{}module-name\textgreater{} or to the current module if none is
specified. If * is specified as the module name, then all definstances
are returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{definstances}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (get-definstances-list)

(initial-object)

CLIPS\textgreater{} (definstances foo)

CLIPS\textgreater{} (definstances bar)

CLIPS\textgreater{} (get-definstances-list)

(initial-object foo bar)

CLIPS\textgreater{}\textgreater{}


\subsubsection{12.16.3.2 Determining the Module in which a Definstances is Defined}
\label{\detokenize{actions:determining-the-module-in-which-a-definstances-is-defined}}
This function returns the module in which the specified definstances
name is defined.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{definstances}\PYG{o}{\PYGZhy{}}\PYG{n}{module} \PYG{o}{\PYGZlt{}}\PYG{n}{definstances}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.16.4 Instance Manipulation Functions and Actions}
\label{\detokenize{actions:instance-manipulation-functions-and-actions}}

\subsubsection{12.16.4.1 Initializing an Instance}
\label{\detokenize{actions:initializing-an-instance}}
This function implements the init message-handler attached to the class
USER (see section 9.4.5.1). This function evaluates and places slot
expressions given by the class definition that were not specified by
slot-overrides in the call to \sphinxstylestrong{make-instance} or
\sphinxstylestrong{initialize-instance} (see section 9.6.1). This function should never
be called directly unless an init message-handler is being defined such
that the one attached to USER will never be called. However, such a
definition is unusual and recommended only to advanced users. A
user-defined class which does not inherit indirectly or directly from
the class USER will require an init message-handler which calls this
function in order for instances of the class to be created. If this
function is called from an init message within the context of a
\sphinxstylestrong{make-instance} or \sphinxstylestrong{initialize-instance} call and there are no
errors in evaluating the class defaults, this function will return the
address of the instance it is initializing. Otherwise, this function
will return the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{init}\PYG{o}{\PYGZhy{}}\PYG{n}{slots}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.4.2 Deleting an Instance}
\label{\detokenize{actions:deleting-an-instance}}
This function deletes the specified instances by sending them a
\sphinxstylestrong{delete} message. The argument can be one or more instance-names,
instance-addresses, or symbols (an instance-name without enclosing
brackets). The instance specified by the arguments must exist (except in
the case of ?*?). If ?*? is specified for the instance, all instances
will be sent the \sphinxstylestrong{delete} message (unless there is an instance named
?*?). This function returns the symbol TRUE if all instances were
successfully deleted, otherwise it returns the symbol FALSE. Note, this
function is exactly equivalent to sending the instance(s) the \sphinxstylestrong{delete}
message directly and is provided only as an intuitive counterpart to the
function \sphinxstylestrong{retract} for facts.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{unmake}\PYG{o}{\PYGZhy{}}\PYG{n}{instance} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.4.3 Deleting the Active Instance from a Handler}
\label{\detokenize{actions:deleting-the-active-instance-from-a-handler}}
This function operates implicitly on the active instance (see section
9.4.1.1) for a message, and thus can only be called from within the body
of a message-handler. This function directly deletes the active instance
and is the one used to implement the delete handler attached to class
USER (see section 9.4.5.2). This function returns the symbol TRUE if the
instance was successfully deleted, otherwise the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{delete}\PYG{o}{\PYGZhy{}}\PYG{n}{instance}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.4.4 Determining the Class of an Object}
\label{\detokenize{actions:determining-the-class-of-an-object}}
This function returns a symbol which is the name of the class of its
argument. It returns the symbol FALSE on errors. This function is
equivalent to the \sphinxstylestrong{type} function (see section 12.15.4).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(class \PYGZlt{}object\PYGZhy{}expression\PYGZgt{})
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (class 34)

INTEGER

CLIPS\textgreater{}


\subsubsection{12.16.4.5 Determining the Name of an Instance}
\label{\detokenize{actions:determining-the-name-of-an-instance}}
This function returns a symbol which is the name of its instance
argument. It returns the symbol FALSE on errors. The evaluation of the
argument must be an instance-name or instance-address of an existing
instance.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.4.6 Determining the Address of an Instance}
\label{\detokenize{actions:determining-the-address-of-an-instance}}
This function returns the address of its instance argument. It returns
the symbol FALSE on errors. The evaluation of \textless{}instance expression\textgreater{} must
be an instance-name or instance-address of an existing instance. If
\textless{}module\textgreater{} or * is not specified, the function searches only in the
current module. If * is specified, the current module and imported
modules are recursively searched. If \textless{}module\textgreater{} is specified, only that
module is searched. The :: syntax cannot be used with the instance-name
if \textless{}module\textgreater{} or * is specified.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{address} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}} \PYGZbs{}\PYG{o}{\textbar{}} \PYGZbs{}\PYG{o}{*}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.4.7 Converting a Symbol to an Instance-Name}
\label{\detokenize{actions:converting-a-symbol-to-an-instance-name}}
This function returns an instance-name which is equivalent to its symbol
argument. It returns the symbol FALSE on errors.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{symbol}\PYG{o}{\PYGZhy{}}\PYG{n}{to}\PYG{o}{\PYGZhy{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{o}{\PYGZlt{}}\PYG{n}{symbol}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (symbol-to-instance-name (sym-cat abc def))

{[}abcdef{]}

CLIPS\textgreater{}


\subsubsection{12.16.4.8 Converting an Instance-Name to a Symbol}
\label{\detokenize{actions:converting-an-instance-name-to-a-symbol}}
This function returns a symbol which is equivalent to its instance-name
argument. It returns the symbol FALSE on errors.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{to}\PYG{o}{\PYGZhy{}}\PYG{n}{symbol} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (instance-name-to-symbol {[}a{]})

a

CLIPS\textgreater{}


\subsubsection{12.16.4.9 Predicate Functions}
\label{\detokenize{actions:predicate-functions-1}}\label{\detokenize{actions:id6}}

\paragraph{12.16.4.9.1 Testing for an Instance}
\label{\detokenize{actions:testing-for-an-instance}}
This function returns the symbol TRUE if the evaluation of its argument
is an instance-address or an instance-name. Otherwise, it returns the
symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{instancep} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{12.16.4.9.2 Testing for an Instance-Address}
\label{\detokenize{actions:testing-for-an-instance-address}}
This function returns the symbol TRUE if the evaluation of its argument
is an instance-address. Otherwise, it returns the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{addressp} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{12.16.4.9.3 Testing for an Instance-Name}
\label{\detokenize{actions:testing-for-an-instance-name}}
This function returns the symbol TRUE if the evaluation of its argument
is an instance-name. Otherwise, it returns the symbol FALSE.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{namep} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{12.16.4.9.4 Testing for the Existence an Instance}
\label{\detokenize{actions:testing-for-the-existence-an-instance}}
This function returns the symbol TRUE if the specified instance exists.
Otherwise, it returns the symbol FALSE. If the argument is an
instance-name, the function determines if an instance of the specified
name exists. If the argument is an instance-address, the function
determines if the specified address is still valid.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{existp} \PYG{o}{\PYGZlt{}}\PYG{n}{instance}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.4.10 Reading a Slot Value}
\label{\detokenize{actions:reading-a-slot-value}}
This function returns the value of the specified slot of the active
instance (see section 9.4.1.1). If the slot does not exist, the slot
does not have a value or this function is called from outside a
message-handler, this function will return the symbol FALSE and an error
will be generated. This function differs from the ?self:\textless{}slot-name\textgreater{}
syntax in that the slot is not looked up until the function is actually
called. Thus it is possible to access different slots every time the
function is executed (see section 9.4.2 for more detail). This function
bypasses message-passing.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{dynamic}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.4.11 Setting a Slot Value}
\label{\detokenize{actions:setting-a-slot-value}}
This function sets the value of the specified slot of the active
instance (see section 9.4.1.1). If the slot does not exist, there is an
error in evaluating the arguments to be placed or this function is
called from outside a message-handler, this function will return the
symbol FALSE and an error will be generated. Otherwise, the new slot
value is returned. This function differs from the (bind
?self:\textless{}slot-name\textgreater{} \textless{}value\textgreater{}*) syntax in that the slot is not looked up
until the function is actually called. Thus it is possible to access
different slots every time the function is executed (see section 9.4.2
for more detail). This function bypasses message-passing.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{dynamic}\PYG{o}{\PYGZhy{}}\PYG{n}{put} \PYG{o}{\PYGZlt{}}\PYG{n}{slot}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{12.16.4.12 Multifield Slot Functions}
\label{\detokenize{actions:multifield-slot-functions}}
The following functions allow convenient manipulation of multifield
slots. There are three types of functions: replacing a range of fields
with one or more new values, inserting one or more new values at an
arbitrary point, and deleting a range of fields. For each type, there
are two forms of functions: an external interface which sets the new
value for the multifield slot with a put- message (see section 9.3.3.9),
and an internal interface that can only be called from message-handlers
which sets the slot for the active instance (see section 9.4.1.1)
directly. Both forms read the original value of the slot directly
without the use of a get- message. All of these functions return the new
slot value on success and the symbol FALSE on errors.


\paragraph{12.16.4.12.1 Replacing Fields}
\label{\detokenize{actions:replacing-fields}}
Allows the replacement of a range of fields in a multifield slot value
with one or more new values. The range indices must be from 1..n, where
n is the number of fields in the multifield slot?s original value and n
\textgreater{} 0.

External Interface Syntax

(slot-replace\$ \textless{}instance-expression\textgreater{} \textless{}mv-slot-name\textgreater{}

\textless{}range-begin\textgreater{} \textless{}range-end\textgreater{} \textless{}expression\textgreater{}+)

Internal Interface Syntax

(slot-direct-replace\$ \textless{}mv-slot-name\textgreater{}

\textless{}range-begin\textgreater{} \textless{}range-end\textgreater{} \textless{}expression\textgreater{}+)

Example

CLIPS\textgreater{}

(defclass A (is-a USER)

(multislot mfs (default a b c d e)))

CLIPS\textgreater{} (make-instance a of A)

{[}a{]}

CLIPS\textgreater{} (slot-replace\$ a mfs 2 4 2 3 4)

(a 2 3 4 e)

CLIPS\textgreater{}


\paragraph{12.16.4.12.2 Inserting Fields}
\label{\detokenize{actions:inserting-fields}}
Allows the insertion of one or more new values in a multifield slot
value before a specified field index. The index must greater than or
equal to 1. A value of 1 inserts the new value(s) at the beginning of
the slot?s value. Any value greater than the length of the slot?s value
appends the new values to the end of the slot?s value.

External Interface Syntax

(slot-insert\$ \textless{}instance-expression\textgreater{} \textless{}mv-slot-name\textgreater{}

\textless{}index\textgreater{} \textless{}expression\textgreater{}+)

Internal Interface Syntax

(slot-direct-insert\$ \textless{}mv-slot-name\textgreater{} \textless{}index\textgreater{} \textless{}expression\textgreater{}+)

Example

CLIPS\textgreater{} (initialize-instance a)

{[}a{]}

CLIPS\textgreater{} (slot-insert\$ a mfs 2 4 2 3 4)

(a 4 2 3 4 b c d e)

CLIPS\textgreater{}


\paragraph{12.16.4.12.3 Deleting Fields}
\label{\detokenize{actions:deleting-fields}}
Allows the deletion of a range of fields in a multifield slot value. The
range indices must be from 1..n, where n is the number of fields in the
multifield slot?s original value and n \textgreater{} 0.

External Interface Syntax

(slot-delete\$ \textless{}instance-expression\textgreater{} \textless{}mv-slot-name\textgreater{}

\textless{}range-begin\textgreater{} \textless{}range-end\textgreater{})

Internal Interface Syntax

(slot-direct-delete\$ \textless{}mv-slot-name\textgreater{} \textless{}range-begin\textgreater{} \textless{}range-end\textgreater{})

Example

CLIPS\textgreater{} (initialize-instance a)

{[}a{]}

CLIPS\textgreater{} (slot-delete\$ a mfs 2 4)

(a e)

CLIPS\textgreater{}


\section{12.17 Defmodule Functions}
\label{\detokenize{actions:defmodule-functions}}
The following functions provide ancillary capabilities for the defmodule
construct.


\subsection{12.17.1 Getting the List of Defmodules}
\label{\detokenize{actions:getting-the-list-of-defmodules}}
The function \sphinxstylestrong{get-defmodule-list} returns a multifield value
containing the names of all defmodules that are currently defined.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{defmodule}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list}\PYG{p}{)}
\end{sphinxVerbatim}

Example

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (get-defmodule-list)

(MAIN)

CLIPS\textgreater{} (defmodule A)

CLIPS\textgreater{} (defmodule B)

CLIPS\textgreater{} (get-defmodule-list)

(MAIN A B)

CLIPS\textgreater{}


\subsection{12.17.2 Setting the Current Module}
\label{\detokenize{actions:setting-the-current-module}}
This function sets the current module. It returns the name of the
previous current module. If an invalid module name is given, then the
current module is not changed and the name of the current module is
returned.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{current}\PYG{o}{\PYGZhy{}}\PYG{n}{module} \PYG{o}{\PYGZlt{}}\PYG{n}{defmodule}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.17.3 Getting the Current Module}
\label{\detokenize{actions:getting-the-current-module}}
This function returns the name of the current module.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{current}\PYG{o}{\PYGZhy{}}\PYG{n}{module}\PYG{p}{)}
\end{sphinxVerbatim}


\section{12.18 Sequence Expansion}
\label{\detokenize{actions:sequence-expansion}}
By default, there is no distinction between single-field and multifield
variable references within function calls (as opposed to declaring
variables for function parameters or variables used for
pattern-matching). For example:

CLIPS\textgreater{} (clear)

CLIPS\textgreater{}

(defrule expansion

(foo \$?b)

=\textgreater{}

(printout t ?b crlf)

(printout t \$?b crlf))

CLIPS\textgreater{} (assert (foo a b c))

\textless{}Fact-1\textgreater{}

CLIPS\textgreater{} (run)

(a b c)

(a b c)

CLIPS\textgreater{}

Note that both printout statements in the rule produce identical output
when the rule executes. The use of ?b and \$?b within the function call
behave identically.

Multifield variable references within function calls, however, can
optionally be expanded into multiple single field arguments. The \$ acts
as a ?sequence expansion? operator and has special meaning when applied
to a global or local variable reference within the argument list of a
function call. The \$ means to take the fields of the multifield value
referenced by the variable and treat them as separate arguments to the
function as opposed to passing a single multifield value argument.

For example, using sequence expansion with the \sphinxstyleemphasis{expansion} rule would
give the following output:

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (set-sequence-operator-recognition TRUE)

TRUE

CLIPS\textgreater{}

(defrule expansion

(foo \$?b)

=\textgreater{}

(printout t ?b crlf)

(printout t \$?b crlf))

CLIPS\textgreater{} (assert (foo a b c))

\textless{}Fact-1\textgreater{}

CLIPS\textgreater{} (run)

(a b c)

abc

CLIPS\textgreater{} (set-sequence-operator-recognition FALSE)

TRUE

CLIPS\textgreater{}

Using sequence expansion, the two printout statements on the RHS of the
expansion rule are equivalent to:

(printout t (create\$ a b c) crlf)

(printout t a b c crlf)

The \$ operator also works with global variables. For example:

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (set-sequence-operator-recognition TRUE)

FALSE

CLIPS\textgreater{} (defglobal ?*x* = (create\$ 3 4 5))

CLIPS\textgreater{} (+ ?*x*)

{[}ARGACCES4{]} Function + expected at least 2 argument(s)

CLIPS\textgreater{} (+ \$?*x*)

12

CLIPS\textgreater{} (set-sequence-operator-recognition FALSE)

TRUE

CLIPS\textgreater{}

The sequence expansion operator is particularly useful for generic
function methods. Consider the ease now of defining a general addition
function for strings.

(defmethod + ((\$?any STRING))

(str-cat \$?any))

By default, sequence expansion is disabled. This allows previously
existing CLIPS programs to work correctly with version 6.0 of CLIPS. The
behavior can be enabled using the \sphinxstylestrong{set-sequence-operator-recognition}
function described in section 12.18.3. Old CLIPS code should be changed
so that it works properly with sequence expansion enabled.


\subsection{12.18.1 Sequence Expansion and Rules}
\label{\detokenize{actions:sequence-expansion-and-rules}}
Sequence expansion is allowed on the LHS of rules, but only within
function calls. If a variable is specified in a pattern as a single or
multifield variable, then all other references to that variable that are
not within function calls must also be the same. For example, the
following rule is not allowed

(defrule bad-rule-1

(pattern \$?x ?x \$?x)

=\textgreater{})

The following rules illustrate appropriate use of sequence expansion on
the LHS of rules.

(defrule good-rule-1

(pattern \$?x\&:(\textgreater{} (length\$ ?x) 1))

(another-pattern \$?y\&:(\textgreater{} (length\$ ?y) 1))

(test (\textgreater{} (+ \$?x) (+ \$?y)))

=\textgreater{})

The first and second patterns use the length\$ function to determine that
the multifields bound to ?x and ?y are greater than 1. Sequence
expansion is not used to pass ?x and ?y to the length\$ function since
the length\$ function expects a single argument of type multifield. The
test CE calls the + function to determine the sum of the values bound to
?x and ?y. Sequence expansion is used for these function calls since the
+ function expects two or more arguments with numeric data values.

Sequence expansion has no affect within an \sphinxstylestrong{assert}, \sphinxstylestrong{modify}, or
\sphinxstylestrong{duplicate}; however, it can be used with other functions on the RHS
of a rule.


\subsection{12.18.2 Multifield Expansion Function}
\label{\detokenize{actions:multifield-expansion-function}}
The \$ operator is merely a shorthand notation for the \sphinxstylestrong{expand\$}
function call. For example, the function calls

(printout t \$?b crlf)

and

(printout t (expand\$ ?b) crlf)

are identical.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(expand\PYGZdl{} \PYGZlt{}multifield\PYGZhy{}expression\PYGZgt{})
\end{sphinxVerbatim}

The \sphinxstylestrong{expand\$} function is valid only within the argument list of a
function call. The \sphinxstylestrong{expand\$} function (and hence sequence expansion)
cannot be used as an argument to the following functions: \sphinxstylestrong{expand\$},
\sphinxstylestrong{return}, \sphinxstylestrong{progn}, \sphinxstylestrong{while}, \sphinxstylestrong{if}, \sphinxstylestrong{progn\$}, \sphinxstylestrong{foreach},
\sphinxstylestrong{switch}, \sphinxstylestrong{loop-for-count}, \sphinxstylestrong{assert}, \sphinxstylestrong{modify}, \sphinxstylestrong{duplicate}
and \sphinxstylestrong{object-pattern-match-delay}.


\subsection{12.18.3 Setting The Sequence Operator Recognition Behavior}
\label{\detokenize{actions:setting-the-sequence-operator-recognition-behavior}}
This function sets the sequence operator recognition behavior. When this
behavior is disabled (FALSE by default), multifield variables found in
function calls are treated as a single argument. When this behaviour is
enabled, multifield variables are expanded and passed as separate
arguments in the function call. This behavior should be set \sphinxstyleemphasis{before} an
expression references a multifield variable is encountered (i.e.
changing the behavior does not retroactively change the behavior for
previously encountered expressions). The return value for this function
is the old value for the behavior.

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{sequence}\PYG{o}{\PYGZhy{}}\PYG{n}{operator}\PYG{o}{\PYGZhy{}}\PYG{n}{recognition} \PYG{o}{\PYGZlt{}}\PYG{n}{boolean}\PYG{o}{\PYGZhy{}}\PYG{n}{expression}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.18.4 Getting The Sequence Operator Recognition Behavior}
\label{\detokenize{actions:getting-the-sequence-operator-recognition-behavior}}
This function returns the current value of the sequence operator
recognition behavior (TRUE or FALSE).

\sphinxcode{\sphinxupquote{Syntax}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{get}\PYG{o}{\PYGZhy{}}\PYG{n}{sequence}\PYG{o}{\PYGZhy{}}\PYG{n}{operator}\PYG{o}{\PYGZhy{}}\PYG{n}{recognition}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{12.18.5 Sequence Operator Caveat}
\label{\detokenize{actions:sequence-operator-caveat}}
CLIPS normally tries to detect as many constraint errors as possible for
a function call at parse time, such as bad number of arguments or types.
However, if the sequence expansion operator is used in the function
call, all such checking is delayed until run-time (because the number
and types of arguments can change for each execution of the call.) For
example:

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (set-sequence-operator-recognition TRUE)

FALSE

CLIPS\textgreater{} (deffunction foo (?a ?b))

CLIPS\textgreater{} (deffunction bar (\$?a) (foo ?a))

{[}ARGACCES4{]} Function foo expected exactly 2 argument(s)

ERROR:

(deffunction MAIN::bar

(\$?a)

(foo ?a)

CLIPS\textgreater{} (deffunction bar (\$?a) (foo \$?a))

CLIPS\textgreater{} (bar 1)

{[}ARGACCES4{]} Function foo expected exactly 2 argument(s)

{[}PRCCODE4{]} Execution halted during the actions of deffunction bar.

FALSE

CLIPS\textgreater{} (bar 1 2)

FALSE

CLIPS\textgreater{} (set-sequence-operator-recognition FALSE)

TRUE

CLIPS\textgreater{}

Section 13:
Commands
===========

This section describes commands primarily intended for use from the
top-level command prompt. These commands may also be used from
constructs and other places where functions can be used.


\chapter{Appendix A: Support Information}
\label{\detokenize{appendix:appendix-a-support-information}}\label{\detokenize{appendix::doc}}

\section{A.1 Questions and Information}
\label{\detokenize{appendix:a-1-questions-and-information}}
The URL for the CLIPS Web page is \sphinxurl{http://clipsrules.sourceforge.net}.

Questions regarding CLIPS can be posted to one of several online forums
including the CLIPS Expert System Group,
\sphinxurl{http://groups.google.com/group/CLIPSESG/}, the SourceForge CLIPS Forums,
\sphinxurl{http://sourceforge.net/forum/?group\_id=215471}, and Stack Overflow,
\sphinxurl{http://stackoverflow.com/questions/tagged/clips}.

Inquiries related to the use or installation of CLIPS can be sent via
electronic mail to \sphinxhref{mailto:clipssupport@secretsocietysoftware.com}{clipssupport@secretsocietysoftware.com}.


\section{A.2 Documentation}
\label{\detokenize{appendix:a-2-documentation}}
The CLIPS Reference Manuals and User?s Guide are available in Portable
Document Format (PDF) at
\sphinxurl{http://clipsrules.sourceforge.net/OnlineDocs.html}.

\sphinxstyleemphasis{Expert Systems: Principles and Programming}, 4th Edition, by Giarratano
and Riley comes with a CD-ROM containing CLIPS 6.22 executables (DOS,
Windows XP, and Mac OS), documentation, and source code. The first half
of the book is theory oriented and the second half covers rule-based,
procedural, and object-oriented programming using CLIPS.


\section{A.3 CLIPS Source Code and Executables}
\label{\detokenize{appendix:a-3-clips-source-code-and-executables}}
CLIPS executables and source code are available on the SourceForge web
site at \sphinxurl{http://sourceforge.net/projects/clipsrules/files}.

Appendix B:
Update Release Notes
====================

The following sections denote the changes and bug fixes for CLIPS
versions 6.2. 6.21, 6.22, 6.23, 6.24, and 6.3.


\section{B.1 Version 6.30}
\label{\detokenize{appendix:b-1-version-6-30}}
?E**Performance Improvements** ?ERule performance has been improved
particularly in situations with large numbers of fact/instances or
partial matches.

?E**64-bit Integers** ?EIntegers in CLIPS are now represented using the
?long long?EC data type which provides a minimum of 64 bits of
precision.

?E**Reset after Clear** ?EA reset command is now performed after a clear
command (which includes the clear command issued internally by CLIPS
when it is started). Since no user constructs will be present after a
clear, the primary effect of this behavior is to create the initial-fact
and initial-object.

?E**Pattern Addition** ?EThe initial-fact and initial-object patterns
are no longer used in triggering rules. When printing partial matches,
the * symbol is used to indicate a not or exists pattern that is
satisfied.

?E**Module Specifiers** ?EA module specifier can be used in expressions
to reference a deffunction or defgeneric that is exported by a module,
but not specifically imported by the module which is referencing it. For
example: (UTIL::my-function a 3).

?E**Instance Name and Class Visibility** ?EInstance names now have
global scope and must be unique regardless of their module. Instances of
classes that are not in scope can be created if the module name is
specified as part of the class name. Messages can be sent to instances
regardless of whether the instance class is in scope.

?E**Command Prompt** ?ELocal variables bound at the command prompt using
the bind function persist until a reset or clear command is issued (see
section 2.1.1).

?E**Printout Function** ?EThe deprecated use of the symbol \sphinxstyleemphasis{t} as a
substitute for the \sphinxstyleemphasis{crlf} symbol is no longer allowed.

?E**MicroEMACS Editor** ?EThe built-in editor is no longer supported.

?E**New Functions and Commands** - Several new functions and commands
have been added. They are:

?E**foreach** (see section 12.6.10)

?E**operating-system** (see section 12.7.12)

?E**Command and Function Changes** - The following commands and
functions have been enhanced:

?E**matches** (see section 13.6.4). This command now has a return value
indicating the number of matches, partial matches, and activations. The
amount of output can be controlled with a verbosity argument.

?E**open** (see section 12.4.2.1). The r+ mode is no longer supported.
New modes ab and rb have been added.

?E**Help Functions** ?EThe \sphinxstylestrong{help} and \sphinxstylestrong{help-path} funtions are no
longer supported

?E**Behavior Changes** - The following changes have been made to
behavior:

?EA defgeneric redefinition warning is no longer printed when a
defmethod is defined.


\section{B.2 Version 6.24}
\label{\detokenize{appendix:b-2-version-6-24}}
?E**Allowed Classes Constraint Attribute** ?EThe allowed-classes
constraint attribute allows a slot containing an instance value to be
restricted to the specified list of classes.

?E**New Functions and Commands** - Several new functions and commands
have been added. They are:

?E**deftemplate-slot-allowed-values**

?E**deftemplate-slot-cardinality**

?E**deftemplate-slot-defaultp**

?E**deftemplate-slot-default-value**

?E**deftemplate-slot-existp**

?E**deftemplate-slot-multip**

?E**deftemplate-slot-names**

?E**deftemplate-slot-range**

?E**deftemplate-slot-singlep**

?E**deftemplate-slot-type**

?E**get-char**

?E**get-region**

?E**ppfact**

?E**read-number**

?E**set-locale**

?E**slot-allowed-classes**

?E**Command and Function Changes** - The following commands and
functions have been enhanced:

?E**format** The formatting of printed numbers can be changed to use a
native locale with the \sphinxstylestrong{set-locale} function. The documentation has
been updated to include the effect of the precision argument on the d,
g, o, and x format flags.

?E**Behavior Changes** - The following changes have been made to
behavior:

?EThe message displayed when a construct is redefined and compilations
are being watched is now more prominent.

?E**Bug Fixes** - The following bugs were fixed by the 6.24 release:

?EThe DescribeClass macros were incorrectly defined.

?EThe sort function leaks memory when called with a multifield value of
length zero.

?ELink error occurred for the SlotExistError function when OBJECT\_SYSTEM
is set to 0 in setup.h.

?EAn error when calling the Eval function causes a subsequent call to
DeallocateEnvironmentData to fail.

?ELoading a binary instance file from a run-time program caused a bus
error.

?EIncorrect activations could occur with the exists CE.

?ECompilation errors occurred when compiling CLIPS source as C++ files.

?EThe AssignFactSlotDefaults function did not correctly handle defaults
for multifield slots.

?EThe slot-default-value function crashed when no default existed for a
slot (the ?NONE value was specified).

?ECLIPS crashed on AMD64 processor in the function used to generate hash
values for integers.

?EA syntax error was not generated for the last deffunction or defmethod
in a file if it was missing the final closing right parenthesis.

?E**Compiler Support** - The following compilers are now supported. See
the \sphinxstyleemphasis{Interfaces Guide} for more details.

?EMetrowerks CodeWarrior 9.6 for Mac OS X.

?EXcode 2.3 for Mac OS X.

?EMicrosoft Visual C++ .NET 2003 for Windows.


\section{B.3 Version 6.23}
\label{\detokenize{appendix:b-3-version-6-23}}
?E**Fact-Set Query Functions** ?ESix new functions similar to the
instance set query functions have been added for determining and
performing actions on sets of facts that satisfy user-defined queries:
any-factp, find-fact, find-all-facts, do-for-fact, do-for-all-facts, and
delayed-do-for-all-facts. The GetNextFactInTemplate function allows
iteration from C over the facts belonging to a specific deftemplate.

?E**Bug Fixes** - The following bugs were fixed by the 6.23 release:

?EPassing the wrong number of arguments to a deffunction through the
funcall function could cause unpredictable behavior including memory
corruption.

?EA large file name (at least 60 characters) passed into the fetch
command causes a buffer overrun.

?EA large file name (at least 60 characters) passed into the
constructs-to-c command causes a buffer overrun.

?EA large defclass or defgeneric name (at least 500 characters) causes a
buffer overrun when the profile-info command is called.

?EA large module or construct name (at least 500 characters) causes a
buffer overrun when the get-\textless{}construct\textgreater{}-list command is called.

?EThe FalseSymbol and TrueSymbol constants were not defined as described
in the \sphinxstyleemphasis{Advanced Programming Guide}. These constants have have now been
defined as macros so that their corresponding environment companion
functions (EnvFalseSymbol and EnvTrueSymbol) could be defined. See the
\sphinxstyleemphasis{Advanced Programming Guide} for more details.

?EThe slot-writablep function returns TRUE for slots having
initialize-only access.

?EFiles created by the constructs-to-c function for use in a run-time
program generate compilation errors.

?E**Command and Function Changes** - The following commands and
functions have been enhanced:

?E**funcall** Multifield arguments are no longer expanded into multiple
arguments before being passed to the target function of the funcall. The
expand\$ function can be placed around an argument to revert to the old
behavior.

?E**Compiler Support** - The following compilers are now supported. See
the \sphinxstyleemphasis{Interfaces Guide} for more details.

?EMetrowerks CodeWarrior 9.4 for Mac OS X and Windows.

?EXcode 1.2 for Mac OS X.


\section{B.4 Version 6.22}
\label{\detokenize{appendix:b-4-version-6-22}}
?E**Bug Fixes** - The following bugs were fixed by the 6.22 release:

?ENumerous fixes for functions and macros that did not accept the
correct number of arguments as specified in the \sphinxstyleemphasis{Advanced Programming
Guide}. The following functions and macros were corrected: Agenda,
BatchStar, EnvGetActivationSalience, EnvBatchStar, EnvFactDeftemplate,
EnvFactExistp, EnvFactList, EnvFactSlotNames,
EnvGetNextInstanceInClassAndSubclasses, EnvLoadInstancesFromString,
EnvRestoreInstancesFromString, EnvSetOutOfMemoryFunction,
FactDeftemplate, FactExistp, FactList, FactSlotNames,
GetNextInstanceInClassAndSubclasses, LoadInstancesFromString,
RestoreInstancesFromString, SetOutOfMemoryFunction.


\section{B.5 Version 6.21}
\label{\detokenize{appendix:b-5-version-6-21}}
?E**Bug Fixes** - The following bugs were fixed by the 6.21 release:

?EThe C GetDefglobalValue macro did not have the correct number of
arguments.

?EThe C RtnArgCount macro did not have the correct number of arguments.

?EErroneous error generated for object pattern under some circumstances.

?EThe C Save macro did not have the correct number of arguments.

?EThe C Eval and Build functions did not have the correct number of
arguments.

?EThe progn\$ index variable did not always return the correct value.

?EThe member\$ function did not always return the correct value.

?EC++ style comments in the code caused errors when using strict ANSI C
compilation.

?EThe C LoadFactsFromString function did not have the correct number of
arguments.

?EPrior bug fix to the PutFactSlot C function prevented memory
associated with the fact to be garbage collected after the fact had been
retracted. The original bug is now fixed through a new API which allows
embedded programs to temporarily disable garbage collection. See section
1.4 of \sphinxstyleemphasis{The Advanced Programming Guide} for more details.


\section{B.6 Version 6.2}
\label{\detokenize{appendix:b-6-version-6-2}}
\sphinxstylestrong{?EEnvironments} ?EIt is now possible in an embedded application to
create multiple environments into which programs can be loaded. See
section 9 of \sphinxstyleemphasis{The Advanced Programming Guide} for more details

?E**New Microsoft Windows and MacOS X Interfaces** ?EAn improved Windows
95/98/NT CLIPS interface is now available for PC compatible computers.
See section 2 of \sphinxstyleemphasis{The Interfaces Guide} for more details. An improved
MacOS X/9.0 CLIPS interface is now available for Macintosh computers.
See section 3 of \sphinxstyleemphasis{The Interfaces Guide} for more details.

?E**COOL Default Behavior** ?EFor the purpose of role inheritance,
system defined classes behave as concrete classes. The default value for
the \sphinxstylestrong{create-accessor} facet is now \sphinxstylestrong{read-write}. For the purpose of
pattern-match inheritance, system defined classes behave as reactive
classes unless the inheriting class is \sphinxstylestrong{abstract}. This behavior can
be restored to CLIPS 6.1 behavior using the \sphinxstylestrong{set-class-defaults-mode}
function.

?E**COOL Changes** - The following changes have been made to instance
behavior:

?ENewly created instances are sent a \sphinxstylestrong{create} message.

?E**New Functions and Commands** - Several new functions and commands
have been added. They are:

?E**funcall**

?E**get-class-defaults-mode**

?E**set-class-defaults-mode**

?E**string-to-field**

?E**timer**

?E**Command and Function Enhancements** - The following commands and
functions have been enhanced:

?E**switch** The requirement of having at least two case statements has
been removed.

?E**printout** The logical name \sphinxstylestrong{nil} now has special significance.

?E**sort** Multifield as well as single-field values can now be sorted.

?E**random** The integer value returned by the function can now be
restricted to a specified range of values.

?E**do-for-instance** Multiple actions can be specified in the action
portion of the query (which previously required an explicit \sphinxstylestrong{progn}
call).

?E**do-for-all-instances** Multiple actions can be specified in the
action portion of the query (which previously required an explicit
\sphinxstylestrong{progn} call).

?E**delayed-do-for-all-instances** Multiple actions can be specified in
the action portion of the query (which previously required an explicit
\sphinxstylestrong{progn} call).

?E**Bug Fixes** - The following bugs were fixed by the 6.20 release:

?EInner member variables in nested instance set queries could be
confused with member variables from an outer query. This would happen if
the inner member variable name shared all of its characters with the
first N characters of the outer variable name.

?ESome data structures generated by object pattern matching were not
garbage collected until a run command was issued.

?EBackspaces were not properly handled in the display window of the
Windows interface.

?EThe module name was not specified for deffunctions by the save
command.

?EGarbage collection triggered by evaluating the arguments to
str-cat/sym-cat could change the value of the arguments already
retrieved.

?EThe PutFactSlot C function does not properly increment/decrement the
slot value that it changes.

?EDefrule data structures could end up in an invalid state during a
retract if a fact/object matched two patterns in a rule and one pattern
was inside two nested not conditional elements and the other pattern was
inside one not conditional element.

?EThe implode\$ function does not properly handle the \textbackslash{} character in a
string.

?EGarbage collection triggered by expression evaluation during an
assert-string call could corrupt the fact being asserted.

?EInappropriate fact syntax for the assert-string function causes a
crash.

?EThe evaluation error flag was not reset before calling the
AssertString C function.

?EThe FindDefclass C function crashes when the specified module is not
defined.

?EThe save command did not always properly save constructs when modules
using import/export specifications were used.

Appendix C:
Glossary
===========

This section defines some of the terminology used throughout this
manual.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{abstraction}
&
The definition of new classes to describe the common properties and behavior of a group of objects.
\\
\hline

&\\
\hline
\sphinxstylestrong{action}
&
A function executed by a construct (such as the RHS of a rule) which typically has no return value, but performs some useful action (such as the printout action) (see section 12).
\\
\hline

&\\
\hline
\sphinxstylestrong{activation}
&
A rule is activated if all of its conditional elements are satisfied and it has not yet fired based on a specific set of matching pattern entities that caused it to be activated. Note that a rule can be activated by more than one set of pattern entities. An activated rule that is placed on the agenda is called an activation.
\\
\hline

&\\
\hline
\sphinxstylestrong{active instance}
&
The object responding to a message which can be referred to by ?self in the message?s handlers.
\\
\hline

&\\
\hline
\sphinxstylestrong{agenda}
&
A list of all rules that are presently ready to fire. It is sorted by salience values and the current conflict resolution strategy. The rule at the top of the agenda is the next rule that will fire.
\\
\hline

&\\
\hline
\sphinxstylestrong{antecedent}
&
The LHS of a rule.
\\
\hline

&\\
\hline
\sphinxstylestrong{bind}
&
The action of storing a value in a variable.
\\
\hline

&\\
\hline
\sphinxstylestrong{class}
&
Template for describing the common properties (slots) and behavior (message-handlers) of a group of objects called instances of the class.
\\
\hline

&\\
\hline
\sphinxstylestrong{class precedence list}
&
A linear ordering of classes which describes the path of inheritance for a class.
\\
\hline

&\\
\hline
\sphinxstylestrong{command}
&
A function executed at the top-level command prompt (such as the reset command) typically having no return value.
\\
\hline

&\\
\hline
\sphinxstylestrong{command prompt}
&
In the interactive interface, the ?CLIPS\textgreater{}?Eprompt which indicates that CLIPS is ready for a command to be entered.
\\
\hline

&\\
\hline
\sphinxstylestrong{condition}
&
A conditional element.
\\
\hline

&\\
\hline
\sphinxstylestrong{conditional}
&
A restriction on the LHS of a rule which must be satisfied in order for the rule to be applicable (also referred to as a CE).
\\
\hline
\sphinxstylestrong{element}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{conflict resolution}
&
A method for determining the order in which rules should fire among rules with the same salience. There are seven different conflict resolution strategies: depth, breadth, simplicity, complexity, lex, mea, and random.
\\
\hline
\sphinxstylestrong{strategy}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{|l|l|}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

\sphinxstylestrong{consequent}
&
The RHS of a rule.
\\
\hline

&\\
\hline
\sphinxstylestrong{constant}
&
A non-varying single field value directly expressed as a series of characters.
\\
\hline

&\\
\hline
\sphinxstylestrong{constraint}
&
In patterns, a constraint is a requirement that is placed on the value of a field from a fact or instance that must be satisified in order for the pattern to be satisfied. For example, the \textasciitilde{}red constraint is satisfied if the field to which the constraint is applied is not the symbol \sphinxstyleemphasis{red}. The term constraint is also used to refer to the legal values allowed in the slots of facts and instances.
\\
\hline

&\\
\hline
\sphinxstylestrong{construct}
&
A high level CLIPS abstraction used to add components to the knowledge base.
\\
\hline

&\\
\hline
\sphinxstylestrong{current focus}
&
The module from which activations are selected to be fired.
\\
\hline

&\\
\hline
\sphinxstylestrong{current module}
&
The module to which newly defined constructs that do not have a module specifier are added. Also is the default module for certain commands which accept as an optional argument a module name (such as list-defrules).
\\
\hline

&\\
\hline
\sphinxstylestrong{daemon}
&
A message-handler which executes implicitly whenever some action is taken upon an object, such as initialization, deletion, or slot access.
\\
\hline

&\\
\hline
\sphinxstylestrong{deffunction}
&
A non-overloaded function written directly in CLIPS.
\\
\hline

&\\
\hline
\sphinxstylestrong{deftemplate fact}
&
A deftemplate name followed by a list of named fields (slots) and specific values used to represent a deftemplate object. Note that a deftemplate fact has no inheritance. Also called a non-ordered fact.
\\
\hline

&\\
\hline
\sphinxstylestrong{deftemplate object}
&
An informal term for the entity described by a deftemplate. A deftemplate object is simply an informal term for the collections of slots (without specific values) which define a deftemplate. Deftemplate objects do not have inheritance
\\
\hline

&\\
\hline
\sphinxstylestrong{deftemplate pattern}
&
A list of named constraints (constrained slots). A deftemplate pattern describes the attributes and associated values of a deftemplate object. Also called a non-ordered pattern.
\\
\hline

&\\
\hline
\sphinxstylestrong{delimiter}
&
A character which indicates the end of a symbol. The following characters act as delimiters: any non-printable ASCII character (including spaces, tabs, carriage returns, and line feeds), a double quote, opening and closing parenthesis ?E?Eand ?E?E an ampersand ?E?E a vertical bar ?\textbar{}?E a less than ?E?E a semicolon ?E?E and a tilde ?\textasciitilde{}?E
\\
\hline

&\\
\hline
\sphinxstylestrong{dynamic binding}
&
The deferral of which message-handlers will be called for a message until run-time.
\\
\hline

&\\
\hline
\sphinxstylestrong{encapsulation}
&
The requirement that all manipulation of instances of user-defined classes be done with messages.
\\
\hline

&\\
\hline
\sphinxstylestrong{expression}
&
A function call with arguments specified.
\\
\hline

&\\
\hline
\sphinxstylestrong{external-address}
&
The address of an external data structure returned by a function (written in a language such as C or Ada) that has been integrated with CLIPS (see section 2.3.1 for more details).
\\
\hline

&\\
\hline
\sphinxstylestrong{external function}
&
A function written in an external language (such as C or Ada) defined by the user or provided by CLIPS and called from within CLIPS rules.
\\
\hline

&\\
\hline
\sphinxstylestrong{facet}
&
A component of a slot specification for a class, e.g. default value and cardinality.
\\
\hline

&\\
\hline
\sphinxstylestrong{fact}
&
An ordered or deftemplate (non-ordered) fact. Facts are the data about which rules rea?son and represent the current state of the world.
\\
\hline

&\\
\hline
\sphinxstylestrong{fact-address}
&
A pointer to a fact obtained by binding a variable to the fact which matches a pattern on the LHS of a rule.
\\
\hline

&\\
\hline
\sphinxstylestrong{fact-identifier}
&
A shorthand notation for referring to a fact. It consists of the character ?f?E followed by a dash, followed by the fact-index of the fact.
\\
\hline

&\\
\hline
\sphinxstylestrong{fact-index}
&
A unique integer index used to identify a particular fact.
\\
\hline

&\\
\hline
\sphinxstylestrong{fact-list}
&
The list of current facts.
\\
\hline

&\\
\hline
\sphinxstylestrong{field}
&
A placeholder (named or unnamed) that has a value.
\\
\hline

&\\
\hline
\sphinxstylestrong{fire}
&
A rule is said to have fired if all of its conditions are satisfied and the actions then are executed.
\\
\hline

&\\
\hline
\sphinxstylestrong{float}
&
A number that begins with an optional sign followed optionally in order by zero or more digits, a decimal point, zero or more digits, and an exponent (consisting of an e or E followed by an integer). A floating point number must have at least one digit in it (not including the exponent) and must either contain a decimal point or an exponent (see section 2.3.1 for more details).
\\
\hline

&\\
\hline
\sphinxstylestrong{focus}
&
As a verb, refers to changing the current focus. As a noun, refers to the current focus.
\\
\hline

&\\
\hline
\sphinxstylestrong{focus stack}
&
The list of modules that have been focused upon. The module at the top of the focus stack is the current focus. When all the activations from the current focus have been fired, the current focus is removed from the focus stack and the next module on the stack becomes the current focus.
\\
\hline

&\\
\hline
\sphinxstylestrong{function}
&
A piece of executable code identified by a specific name which returns a useful value or performs a useful side effect. Typically only used to refer to functions which do return a value (whereas commands and actions are used to refer to functions which do not return a value).
\\
\hline

&\\
\hline
\sphinxstylestrong{generic dispatch}
&
The process whereby applicable methods are selected and executed for a particular generic function call.
\\
\hline

&\\
\hline
\sphinxstylestrong{generic function}
&
A function written in CLIPS which can do different things depending on what the number and types of its arguments.
\\
\hline

&\\
\hline
\sphinxstylestrong{inference engine}
&
The mechanism provided by CLIPS which automatically matches patterns against the current state of the fact-list and list of instances and determines which rules are applicable.
\\
\hline

&\\
\hline
\sphinxstylestrong{inheritance}
&
The process whereby one class can be defined in terms of other class(es).
\\
\hline

&\\
\hline
\sphinxstylestrong{instance}
&
An object is an instance of a class. Throughout the documentation, the term instance usually refers to objects which are instances of user-defined classes.
\\
\hline

&\\
\hline
\sphinxstylestrong{instance (of a user-defined class)}
&
An object which can only be manipulated via messages, i.e all objects except symbols, strings, integers, floats, multifields and external-addresses.
\\
\hline

&\\
\hline
\sphinxstylestrong{instance-address}
&
The address of an instance of a user-defined class (see section 2.3.1 for more details).
\\
\hline

&\\
\hline
\sphinxstylestrong{instance-name}
&
A symbol enclosed within left and right brackets (see section 2.3.1 for more details). An instance-name refers to an object of the specified name which is an instance of a user-defined class.
\\
\hline

&\\
\hline
\sphinxstylestrong{instance-set}
&
An ordered collection of instances of user-defined classes. Each member of an instance-set is an instance of a set of classes, where the set can be different for each member.
\\
\hline

&\\
\hline
\sphinxstylestrong{instance-set distributed action}
&
A user-defined expression which is evaluated for every instance-set which satisfies an instance-set query.
\\
\hline

&\\
\hline
\sphinxstylestrong{instance-set query}
&
A user-defined boolean expression applied to an instance-set to see if it satisfies further user-defined criteria.
\\
\hline

&\\
\hline
\sphinxstylestrong{integer}
&
A number that begins with an optional sign followed by one or more digits (see section 2.3.1 for more details).
\\
\hline

&\\
\hline
\sphinxstylestrong{LHS}
&
Left-Hand Side. The set of conditional elements that must be satisfied for the ac?tions of the RHS of a rule to be performed.
\\
\hline

&\\
\hline
\sphinxstylestrong{list}
&
A group of items with no implied order.
\\
\hline

&\\
\hline
\sphinxstylestrong{logical name}
&
A symbolic name that is associated with an I/O source or destination.
\\
\hline

&\\
\hline
\sphinxstylestrong{message}
&
The mechanism used to manipulate an object.
\\
\hline

&\\
\hline
\sphinxstylestrong{message dispatch}
&
The process whereby applicable message-handlers are selected and executed for a particular message.
\\
\hline

&\\
\hline
\sphinxstylestrong{message-handler}
&
An implementation of a message for a particular class of objects.
\\
\hline

&\\
\hline
\sphinxstylestrong{message-handler precedence}
&
The property used by the message dispatch to select between handlers when more than one is applicable to a particular message.
\\
\hline

&\\
\hline
\sphinxstylestrong{method}
&
An implementation of a generic function for a particular set of argument restrictions.
\\
\hline

&\\
\hline
\sphinxstylestrong{method index}
&
A shorthand notation for referring to a method with a particular set of parameter restrictions.
\\
\hline

&\\
\hline
\sphinxstylestrong{method precedence}
&
The property used by the generic dispatch to select a method when more than one is applicable to a particular generic function call.
\\
\hline

&\\
\hline
\sphinxstylestrong{module}
&
A workspace where a set of constructs can be grouped together such that explicit control can be maintained over restricting the access of the constructs by other modules. Also used to control the flow of execution of rules through the use of the focus command.
\\
\hline

&\\
\hline
\sphinxstylestrong{module specifier}
&
A notation for specifying a module. It consists of a module name followed by two colons. When placed before a construct name, it?s used to specify which module a newly defined construct is to be added to or to specify which construct a command will affect if that construct is not in the current module.
\\
\hline

&\\
\hline
\sphinxstylestrong{multifield}
&
A sequence of unnamed placeholders each having a value.
\\
\hline

&\\
\hline
\sphinxstylestrong{multifield value}
&
A sequence of zero or more single-field values.
\\
\hline

&\\
\hline
\sphinxstylestrong{non-ordered fact}
&
A deftemplate fact.
\\
\hline

&\\
\hline
\sphinxstylestrong{number}
&
An integer or float.
\\
\hline

&\\
\hline
\sphinxstylestrong{object}
&
A symbol, a string, a floating-point or integer number, a multifield value, an external address or an instance of a user-defined class.
\\
\hline

&\\
\hline
\sphinxstylestrong{order}
&
Position is significant.
\\
\hline

&\\
\hline
\sphinxstylestrong{ordered fact}
&
A sequence of unnamed fields.
\\
\hline

&\\
\hline
\sphinxstylestrong{ordered pattern}
&
A sequence of constraints.
\\
\hline

&\\
\hline
\sphinxstylestrong{overload}
&
The process whereby a generic function can do different things depending on the types and number of its arguments, i.e. the generic function has multiple methods.
\\
\hline

&\\
\hline
\sphinxstylestrong{pattern}
&
A conditional element on the LHS of a rule which is used to match facts in the fact-list.
\\
\hline

&\\
\hline
\sphinxstylestrong{pattern entity}
&
An item that is capable of matching a pattern on the LHS of a rule. Facts and instances are the only types of pattern entities available.
\\
\hline

&\\
\hline
\sphinxstylestrong{pattern-matching}
&
The process of matching facts or instances to patterns on the LHS of rules.
\\
\hline

&\\
\hline
\sphinxstylestrong{polymorphism}
&
The ability of different objects to respond to the same message in a specialized manner.
\\
\hline

&\\
\hline
\sphinxstylestrong{primitive type object}
&
A symbol, string, integer, float, multifield or external-address.
\\
\hline

&\\
\hline
\sphinxstylestrong{relation}
&
The first field in a fact or fact pattern. Synonomous with the associated deftemplate name.
\\
\hline

&\\
\hline
\sphinxstylestrong{RHS}
&
Right-Hand Side. The actions to be performed when the LHS of a rule is satisfied.
\\
\hline

&\\
\hline
\sphinxstylestrong{rule}
&
A collection of conditions and actions. When all patterns are satisfied, the actions will be taken.
\\
\hline

&\\
\hline
\sphinxstylestrong{salience}
&
A priority number given to a rule. When multiple rules are ready for firing, they are fired in order of priority. The default salience is zero (0). Rules with the same salience are fired according to the current conflict resolution strategy.
\\
\hline

&\\
\hline
\sphinxstylestrong{sequence}
&
An ordered list.
\\
\hline

&\\
\hline
\sphinxstylestrong{shadowed message-handler}
&
A message-handler that must be explicitly called by another message-handler in order to execute.
\\
\hline

&\\
\hline
\sphinxstylestrong{shadowed method}
&
A method that must be explicitly called by another method in order to execute.
\\
\hline

&\\
\hline
\sphinxstylestrong{single-field value}
&
One of the primitive data types: float, integer, symbol, string, external-address, instance-name, or instance-address.
\\
\hline

&\\
\hline
\sphinxstylestrong{slot}
&
Named single-field or multifield. To write a slot give the field name (attribute) followed by the field value. A single-field slot has one value, while a multifield slot has zero or more values. Note that a multifield slot with one value is strictly not the same as a single field slot. However, the value of a single-field slot (or variable) may match a multifield slot (or multifield variable) that has one field.
\\
\hline

&\\
\hline
\sphinxstylestrong{slot-accessor}
&
Implicit message-handlers which provide read and write access to slots of an object.
\\
\hline

&\\
\hline
\sphinxstylestrong{specificity (class)}
&
A class that precedes another class in a class precedence list is said to be more specific. A class is more specific than any of its superclasses.
\\
\hline

&\\
\hline
\sphinxstylestrong{specificity (rule)}
&
A measure of how ?specific?Ethe LHS of a rule is in the pattern-matching process. The specificity is determined by the number of constants, variables, and function calls used within LHS conditional elements.
\\
\hline

&\\
\hline
\sphinxstylestrong{string}
&
A set of characters that starts with double quotes (“) and is followed by zero or more printable characters and ends with double quotes (see section 2.3.1 for more details).
\\
\hline

&\\
\hline
\sphinxstylestrong{subclass}
&
If a class inherits from a second class, the first class is a subclass of the second class.
\\
\hline

&\\
\hline
\sphinxstylestrong{superclass}
&
If a class inherits from a second class, the second class is a superclass of the first class.
\\
\hline

&\\
\hline
\sphinxstylestrong{symbol}
&
Any sequence of characters that starts with any printable ASCII character and is followed by zero or more characters (see section 2.3.1 for more details).
\\
\hline

&\\
\hline
\sphinxstylestrong{top level}
&
In the interactive interface, the ?CLIPS\textgreater{}?Eprompt which indicates that CLIPS is ready for a command to be entered.
\\
\hline

&\\
\hline
\sphinxstylestrong{value}
&
A single or multifield value.
\\
\hline

&\\
\hline
\sphinxstylestrong{variable}
&
An symbolic location which can store a value.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

Appendix D:
Performance Considerations
==========================

This appendix explains various techniques that the user can apply to a
CLIPS program to maximize performance. Included are discussions of
pattern ordering in rules, use of deffunctions in lieu of non-overloaded
generic functions, parameter restriction ordering in generic function
methods, and various approaches to improving the speed of
message-passing and reading slots of instances.


\section{D.1 Ordering of Patterns on the LHS}
\label{\detokenize{appendix:d-1-ordering-of-patterns-on-the-lhs}}
The issues which affect performance of a rule-based system are
considerably different from those which affect conventional programs.
This section discusses the single most important issue: the ordering of
patterns on the LHS of a rule.

CLIPS is a rule language based on the RETE algorithm. The RETE algorithm
was de?signed specifically to provide very efficient pattern-matching.
CLIPS has attempted to implement this algorithm in a manner that
combines efficient performance with powerful features. When used
properly, CLIPS can provide very reasonable performance, even on
microcomputers. However, to use CLIPS properly requires some
under?stand?ing of how the pattern-matcher works.

Prior to initiating execution, each rule is loaded into the system and a
network of all patterns that appear on the LHS of any rule is
constructed. As facts and instances of reactive classes (referred to
collectively as pattern entities) are created, they are filtered through
the pattern network. If the pattern entities match any of the patterns
in the network, the rules associated with those patterns are partially
instantiated. When pattern entities exist that match all patterns on the
LHS of the rule, variable bindings (if any) are considered. They are
considered from the top to the bottom; i.e., the first pattern on the
LHS of a rule is con?sidered, then the second, and so on. If the
variable bindings for all patterns are consis?tent with the constraints
applied to the variables, the rules are activated and placed on the
agenda.

This is a very simple description of what occurs in CLIPS, but it gives
the basic idea. A number of important considerations come out of this.
Basic pattern-matching is done by filtering through the pattern network.
The time involved in doing this is fairly constant. The slow portion of
basic pattern-matching comes from comparing variable bindings across
patterns. Therefore, the single most important performance factor is the
ordering of patterns on the LHS of the rule. Unfortunately, there are no
hard and fast methods that will al?ways order the patterns properly. At
best, there seem to be three ?quasi?Emethods for ordering the patterns.

1) Most specific to most general. The more wildcards or unbound
variables there are in a pattern, the lower it should go. If the rule
firing can be controlled by a single pattern, place that pattern first.
This technique often is used to provide control structure in an expert
system; e.g., some kind of ?phase?Efact. Putting this kind of pattern
first will \sphinxstyleemphasis{guarantee} that the rest of the rule will not be considered
until that pattern exists. This is most effective if the single pattern
consists only of literal constraints. If multiple patterns with variable
bindings control rule firing, arrange the patterns so the most important
variables are bound first and compared as soon as possible to the other
pattern constraints. The use of phase facts is not recommended for large
programs if they are used solely for controlling the flow of execution
(use modules instead).

2) Patterns with the lowest number of occurrences in the fact-list or
instance-list should go near the top. A large number of patterns of a
particular form in the fact-list or instance-list can cause numerous
partial instantiations of a rule that have to be ?weeded?Eout by
comparing the variable bindings, a slower operation.

3) Volatile patterns (ones that are retracted and asserted continuously)
should go last, particularly if the rest of the patterns are mostly
independent. Every time a pattern entity is created, it must be filtered
through the network. If a pattern entity causes a partial rule
instan?tiation, the variable bindings must be considered. By putting
volatile patterns last, the variable bindings only will be checked if
all of the rest of the patterns already exist.

These rules are \sphinxstyleemphasis{not} independent and commonly conflict with each other.
At best, they provide some rough guidelines. Since all systems have
these characteristics in different proportions, at a glance the most
efficient manner of ordering patterns for a given system is not evident.
The best approach is to develop the rules with minimal consideration of
ordering. When the reasoning is fairly well verified, experiment with
the patterns until the optimum configuration is found.

Another performance issue is the use of multifield variables and
wildcards (\$?). Although they provide a powerful capability, they must
be used very carefully. Since they can bind to zero or more fields, they
can cause multiple instantiations of a single rule. In particular, the
use of multiple multifield variables in one pattern can cause a very
large number of instantiations.

Some final notes on rule performance. Experience suggests that the user
should keep the expert system ?lean and mean.?EThe list of pattern
entities should not be used as a data base for storage of ex?traneous
information. Store and pattern-match only on that information necessary
for reasoning. Keep the pattern-matching to a minimum and be as specific
as possible. Many short, simple rules perform better than long, complex
rules and have the added benefit of being easier to understand and
maintain.


\section{D.2 Deffunctions versus Generic Functions}
\label{\detokenize{appendix:d-2-deffunctions-versus-generic-functions}}
Deffunctions execute more quickly than generic function because generic
functions must first examine their arguments to determine which methods
are applicable. If a generic function has only one method, a deffunction
probably would be better. Care should be taken when determining if a
particular function truly needs to be overloaded. In addition, if
recompiling and relinking CLIPS is not prohibitive, user-defined
external functions are even more efficient than deffunctions. This is
because deffunction are interpreted whereas external functions are
directly executed. For more details, see sections 7 and 8.2.


\section{D.3 Ordering of Method Parameter Restrictions}
\label{\detokenize{appendix:d-3-ordering-of-method-parameter-restrictions}}
When the generic dispatch examines a generic function?s method to
determine if it is applicable to a particular set of arguments, it
examines that method?s parameter restrictions from left to right. The
programmer can take advantage of this by placing parameter restrictions
which are less frequently satisfied than others first in the list. Thus,
the generic dispatch can conclude as quickly as possible when a method
is not applicable to a generic function call. If a group of restrictions
are all equally likely to be satisfied, placing the simpler restrictions
first, such as those without queries, will also allow the generic
dispatch to conclude more quickly for a method that is not applicable.
For more details, see section 8.4.3.


\section{D.4 Instance-Addresses versus Instance-Names}
\label{\detokenize{appendix:d-4-instance-addresses-versus-instance-names}}
COOL allows instances of user-defined classes to be referenced either by
address or by name in functions which manipulate instances, such as
message-passing with the \sphinxstylestrong{send} function. However, when an instance is
referenced by name, CLIPS must perform an internal lookup to find the
instance-address anyway. If the same instance is going to be manipulated
many times, it might be advantageous to store the instance-address and
use that as a reference. This will allow CLIPS to always go directly to
the instance. For more details, see sections 2.4.2 and 12.16.4.6.


\section{D.5 Reading Instance Slots Directly}
\label{\detokenize{appendix:d-5-reading-instance-slots-directly}}
Normally, message-passing must be used to read or set a slot of an
instance. However, slots can be read directly within instance-set
queries and message-handlers, and they can be set directly within
message-handlers. Accessing slots directly is significantly faster than
message-passing. Unless message-passing is required (because of slot
daemons), direct access should be used when allowed. For more details,
see sections 9.4.2, 9.4.3, 9.4.4, 9.6.3, 9.6.4 and 9.7.3.

Appendix E:
CLIPS Warning Messages
======================

CLIPS typically will display two kinds of warning messages: those
associated with executing constructs and those associated with loading
constructs. This appendix describes some of the more common warning
messages and what they mean. Each message begins with a unique
identifier enclosed in brackets followed by the keyword \sphinxstylestrong{WARNING}; the
messages are listed here in alphabetic order according to the
identifier.

{[}CONSCOMP1{]} WARNING: Base file name exceeds 3 characters.

This may cause files to be overwritten if file name length

is limited on your platform.

The constructs-to-c command generates file names using the file name
prefix supplied as an argument. If this base file name is longer than
three characters, then the possibility exists that files may be
overwritten if file name length is limited on your platform.

{[}CONSCOMP2{]} WARNING: Array name \textless{}arrayName\textgreater{} exceeds 6 characters in
length. This variable may be indistinguishable from another by the
linker.

The constructs-to-c command generates arrays for storing data
structures. If the SHORT\_LINK\_NAMES compiler flag is enabled, then this
warning message is displayed if generated array names exceed six
characters in length.

{[}CSTRCPSR1{]} WARNING: Redefining \textless{}constructType\textgreater{}: \textless{}constructName\textgreater{}

This indicates that a previously defined construct of the specified type
has been redefined.

{[}CSTRNBIN1{]} WARNING: Constraints are not saved with a binary image when
dynamic constraint checking is disabled

or

{[}CSTRNCMP1{]} WARNING: Constraints are not saved with a constructs-to-c
image when dynamic constraint checking is disabled

These warnings occur when dynamic constraint checking is disabled and
the \sphinxstylestrong{constructs-to-c} or \sphinxstylestrong{bsave} commands are executed. Constraints
attached to deftemplate and defclass slots will not be saved with the
runtime or binary image in these cases since it is assumed that dynamic
constraint checking is not required. Enable dynamic constraint checking
with the \sphinxstylestrong{set-dynamic-constraint-checking} function before calling
\sphinxstylestrong{constructs-to-c} or \sphinxstylestrong{bsave} in order to include constraints in the
runtime or binary image.

{[}DFFNXFUN1{]} WARNING: Deffunction \textless{}name\textgreater{} only partially deleted due to
usage by other constructs.

During a clear or deletion of all deffunctions, only the actions of a
deffunction were deleted because another construct which also could not
be deleted referenced the deffunction.

Example:

CLIPS\textgreater{}

(deffunction foo ()

(printout t “Hi there!” crlf))

CLIPS\textgreater{}

(deffunction bar ()

(foo)

(undeffunction *))

CLIPS\textgreater{} (bar)

{[}GENRCBIN1{]} WARNING: COOL not installed! User-defined class in method
restriction substituted with OBJECT.

This warning occurs when a generic function method restricted by
defclasses is loaded using the \sphinxstylestrong{bload} command into a CLIPS
configuration where the object language is not enabled. The restriction
containing the defclass will match any of the primitive types.

{[}OBJBIN1{]} WARNING: Around message-handlers are not supported in this
environment.

This warning occurs when an \sphinxstylestrong{around} message-handler is loaded using
the \sphinxstylestrong{bload} command into a CLIPS configuration not supporting
imperative message-handlers.

{[}OBJBIN2{]} WARNING: Before and after message-handlers are not supported
in this environment.

This warning occurs when a \sphinxstylestrong{before} or an \sphinxstylestrong{after} message-handler is
loaded using the \sphinxstylestrong{bload} command into a CLIPS configuration not
supporting auxiliary message-handlers.

Appendix F:
CLIPS Error Messages
====================

CLIPS typically will display two kinds of error messages: those
associated with executing constructs and those associated with loading
constructs. This appendix describes some of the more common error
messages and what they mean. Each message begins with a unique
identifier enclosed in brackets; the messages are listed here in
alphabetic order according to the identifier.

{[}AGENDA1{]} Salience value must be an integer value.

Salience requires a integer argument and will otherwise result in this
error message.

Example:

CLIPS\textgreater{} (defrule error (declare (salience a)) =\textgreater{})

{[}AGENDA2{]} Salience value out of range \textless{}min\textgreater{} to \textless{}max\textgreater{}

The range of allowed salience has an explicit limit; this error message
will result if the value is out of that range.

Example:

CLIPS\textgreater{} (defrule error (declare (salience 20000)) =\textgreater{})

{[}AGENDA3{]} This error occurred while evaluating the salience {[}for rule
\textless{}name\textgreater{}{]}

When an error results from evaluating a salience value for a rule, this
error message is given.

{[}ANALYSIS1{]} Duplicate pattern-address \textless{}variable name\textgreater{} found in CE \textless{}CE
number\textgreater{}.

This message occurs when two facts or instances are bound to the same
pattern-address variable.

Example:

CLIPS\textgreater{} (defrule error ?f \textless{}- (a) ?f \textless{}- (b) =\textgreater{})

{[}ANALYSIS2{]} Pattern-address \textless{}variable name\textgreater{} used in CE \#2 was previously
bound within a pattern CE.

A variable first bound within a pattern cannot be later bound to a
fact-address.

Example:

CLIPS\textgreater{} (defrule error (a ?f) ?f \textless{}- (b) =\textgreater{})

{[}ANALYSIS3{]} Variable \textless{}variable name\textgreater{} is used as both a single and
multifield variable.

Variables on the LHS of a rule cannot be bound to both single and
multifield variables.

Example:

CLIPS\textgreater{} (defrule error (a ?x \$?x) =\textgreater{})

{[}ANALYSIS4{]} Variable \textless{}variable name\textgreater{} {[}found in the expression
\textless{}expression\textgreater{}{]}

was referenced in CE \textless{}CE number\textgreater{} \textless{}field or slot identifier\textgreater{} before being
defined

A variable cannot be referenced before it is defined and, thus, results
in this error message.

Example:

CLIPS\textgreater{} (defrule foo (a \textasciitilde{}?x) =\textgreater{})

{[}ARGACCES1{]} Function \textless{}name\textgreater{} expected at least \textless{}minimum\textgreater{} and no more than
\textless{}maximum\textgreater{} argument(s)

This error occurs when a function receives less than the minimum number
or more than the maximum number of argu?ment(s) expected.

{[}ARGACCES2{]} Function \textless{}function-name\textgreater{} was unable to open file \textless{}file-name\textgreater{}

This error occurs when the specified function cannot open a file.

{[}ARGACCES3{]} Function \textless{}name1\textgreater{} received a request from function \textless{}name2\textgreater{}
for argument \#\textless{}number\textgreater{} which is non-existent

This error occurs when a function is passed fewer arguments than were
expected.

{[}ARGACCES4{]} Function \textless{}name\textgreater{} expected exactly \textless{}number\textgreater{} argument(s)

This error occurs when a function that expects a precise number of
argument(s) re?ceives an incorrect number of arguments.

{[}ARGACCES4{]} Function \textless{}name\textgreater{} expected at least \textless{}number\textgreater{} argument(s)

This error occurs when a function does not receive the minimum number of
argu?ment(s) that it expected.

{[}ARGACCES4{]} Function \textless{}name\textgreater{} expected no more than \textless{}number\textgreater{} argument(s)

This error occurs when a function receives more than the maximum number
of argu?ment(s) expected.

{[}ARGACCES5{]} Function \textless{}name\textgreater{} expected argument \#\textless{}number\textgreater{} to be of type
\textless{}data-type\textgreater{}

This error occurs when a function is passed the wrong type of argument.

{[}ARGACCES6{]} Function \textless{}name1\textgreater{} received a request from function \textless{}name2\textgreater{}
for argument \#\textless{}number\textgreater{} which is not of type \textless{}data-type\textgreater{}

This error occurs when a function requests from another function the
wrong type of ar?gument, typically a \sphinxstylestrong{string} or \sphinxstylestrong{symbol}, when
expecting a \sphinxstylestrong{number} or vice versa.

{[}BLOAD1{]} Cannot load \textless{}construct type\textgreater{} construct with binary load in
effect.

If the bload command was used to load in a binary image, then the named
construct cannot be entered until a clear command has been performed to
remove the binary image.

{[}BLOAD2{]} File \textless{}file-name\textgreater{} is not a binary construct file

This error occurs when the bload command is used to load a file that was
not cre?ated with the bsave command.

{[}BLOAD3{]} File \textless{}file-name\textgreater{} is an incompatible binary construct file

This error occurs when the bload command is used to load a file that was
cre?ated with the bsave command using a different version of CLIPS.

{[}BLOAD4{]} The CLIPS environment could not be cleared.

Binary load cannot continue.

A binary load cannot be performed unless the current CLIPS environment
can be cleared.

\begin{DUlineblock}{0em}
\item[] {[}BLOAD5{]} Some constructs are still in use by the current binary image:
\item[] \textless{}construct-name 1\textgreater{}
\item[] \textless{}construct-name 2\textgreater{}
\item[] …
\item[] \textless{}construct-name N\textgreater{}
\end{DUlineblock}

Binary \textless{}operation\textgreater{} cannot continue.

This error occurs when the current binary image cannot be cleared
because some constructs are still being used. The \textless{}operation\textgreater{} in
progress may either be a binary load or a binary clear.

\begin{DUlineblock}{0em}
\item[] {[}BLOAD6{]} The following undefined functions are referenced by this
binary image:
\item[] \textless{}function-name 1\textgreater{}
\item[] \textless{}function-name 2\textgreater{}
\item[] …
\item[] \textless{}function-name N\textgreater{}
\end{DUlineblock}

This error occurs when a binary image is loaded that calls functions
which were available in the CLIPS executable that originally created the
binary image, but which are not available in the CLIPS executable that
is loading the binary image.

{[}BSAVE1{]} Cannot perform a binary save while a binary load is in effect.

The bsave command does not work when a binary image is loaded.

{[}CLASSEXM1{]} Inherited slot \textless{}slot-name\textgreater{} from class \textless{}slot-name\textgreater{} is not
valid for function slot-publicp

This error message occurs when the function \sphinxstylestrong{slot-publicp} is given an
inherited slot. This function can only be used on slots defined in the
given class.

Example:

CLIPS\textgreater{}

(defclass FOO (is-a USER)

(slot woz (visibility private)))

CLIPS\textgreater{}

(defclass BAR (is-a FOO))

CLIPS\textgreater{} (slot-publicp BAR woz)

{[}CLASSFUN1{]} Unable to find class \textless{}class name\textgreater{} in function \textless{}function
name\textgreater{}.

This error message occurs when a function is given a non-existent class
name.

Example:

CLIPS\textgreater{} (class-slots FOO)

{[}CLASSFUN2{]} Maximum number of simultaneous class hierarchy traversals
exceeded \textless{}number\textgreater{}.

This error is usually caused by too many simultaneously active
instance-set queries, e.g., \sphinxstylestrong{do-for-all-instances}. The direct or
indirect nesting of instance-set query functions is limited in the
following way:

Ci is the number of members in an instance-set for the ith nested
instance-set query function.

N is the number of nested instance-set query functions.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxincludegraphics[width=0.38889in,height=0.47222in]{{media/image8}.emf}
&
\textless{}= 128 (the default upper limit)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Example:

CLIPS\textgreater{}

(deffunction my-func ()

(do-for-instance ((?a USER) (?b USER) (?c USER)) TRUE

(printout t ?a ” ” ?b ” ” ?c crlf))

; The sum here is C1 = 3 which is OK.

CLIPS\textgreater{}

(do-for-all-instances ((?a OBJECT) (?b OBJECT)) TRUE

(my-func))

; The sum here is C1 + C2 = 2 + 3 = 5 which is OK.

The default upper limit of 128 should be sufficient for most if not all
applications. However, the limit may be increased by editing the header
file OBJECT.H and recompiling CLIPS.

{[}CLASSPSR1{]} An abstract class cannot be reactive.

Only concrete classes can be reactive.

Example:

CLIPS\textgreater{}

(defclass FOO (is-a USER)

(role abstract)

(pattern-match reactive))

{[}CLASSPSR2{]} Cannot redefine a predefined system class.

Predefined system classes cannot be modified by the user.

Example:

CLIPS\textgreater{} (defclass STRING (is-a NUMBER))

{[}CLASSPSR3{]} \textless{}name\textgreater{} class cannot be redefined while outstanding
references to it still exist.

This error occurs when an attempt to redefine a class is made under one
or both of the following two circumstances:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi )}
\makeatletter\def\p@enumii{\p@enumi \theenumi )}\makeatother
\item {} 
The class (or any of its subclasses) has instances.

\end{enumerate}

2) The class (or any of its subclasses) appear in the parameter
restrictions of any generic function method.

Before the class can be redefined, all such instances and methods must
be deleted.

Example:

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{} (defmethod foo ((?a A LEXEME)))

CLIPS\textgreater{} (defclass A (is-a OBJECT)))

{[}CLASSPSR4{]} Class \textless{}attribute\textgreater{} already declared.

Only one specification of a class attribute is allowed.

Example:

CLIPS\textgreater{}

(defclass A (is-a USER)

(role abstract)

(role concrete))

{[}CLSLTPSR1{]} Duplicate slots not allowed.

Slots in a defclass must be unique.

Example:

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot foo)

(slot foo))

{[}CLSLTPSR2{]} \textless{}name\textgreater{} facet already specified.

Only one occurrence of a facet per slot is allowed.

Example:

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot foo (access read-only)

(access read-write)))

{[}CLSLTPSR3{]} Cardinality facet can only be used with multifield slots

Single-field slots by definition have a cardinality of one.

Example:

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot foo (cardinality 3 5)))

{[}CLSLTPSR4{]} read-only slots must have a default value

Since slots cannot be unbound and \sphinxstylestrong{read-only} slots cannot be set
after initial creation of the instance, \sphinxstylestrong{read-only} slots must have a
default value.

Example:

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot foo (access read-only)

(default ?NONE)))

{[}CLSLTPSR5{]} read-only slots cannot have a write accessor

Since \sphinxstylestrong{read-only} slots cannot be changed after initializationof the
instance, a \sphinxstylestrong{write} accessor (\sphinxstylestrong{put-} message-handler) is not
allowed.

Example:

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot foo (access read-only)

(create-accessor write)))

{[}CLSLTPSR6{]} no-inherit slots cannot also be public

\sphinxstylestrong{no-inherit} slots are by definition not accessible to subclasses and
thus only visible to the parent class.

Example:

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot foo (propagation no-inherit)

(visibility public)))

{[}COMMLINE1{]} Expected a ‘(‘, constant, or global variable

This message occurs when a top-level command does not begin with a ‘(‘,
constant, or global variable.

Example:

CLIPS\textgreater{} )

{[}COMMLINE2{]} Expected a command.

This message occurs when a top-level command is not a symbol.

Example:

CLIPS\textgreater{} (“facts”

{[}CONSCOMP1{]} Invalid file name \textless{}fileName\textgreater{} contains ‘.’

A ‘.’ cannot be used in the file name prefix that is passed to the
constructs-to-c command since this prefix is used to generate file names
and some operating systems do not allow more than one ‘.’ to appear in a
file name.

{[}CONSTRCT1{]} Some constructs are still in use. Clear cannot continue.

This error occurs when the clear command is issued when a construct is
in use (such as a rule that is firing).

{[}CSTRCPSR1{]} Expected the beginning of a construct.

This error occurs when the load command expects a left parenthesis
followed a construct type and these token types are not found.

{[}CSTRCPSR2{]} Missing name for \textless{}construct-type\textgreater{} construct

This error occurs when the name is missing for a construct that requires
a name.

Example:

CLIPS\textgreater{} (defgeneric ())

{[}CSTRCPSR3{]} Cannot define \textless{}construct-type\textgreater{} \textless{}construct-name\textgreater{} because of
an import/export conflict.

or

{[}CSTRCPSR3{]} Cannot define defmodule \textless{}defmodule-name\textgreater{} because of an
import/export conflict cause by the \textless{}construct-type\textgreater{} \textless{}construct-name\textgreater{}.

A construct cannot be defined if defining the construct would allow two
different definitions of the same construct type and name to both be
visible to any module.

Example:

CLIPS\textgreater{} (defmodule MAIN (export ?ALL))

CLIPS\textgreater{} (deftemplate MAIN::foo)

CLIPS\textgreater{} (defmodule BAR (import MAIN ?ALL))

CLIPS\textgreater{} (deftemplate BAR::foo (slot x))

{[}CSTRCPSR4{]} Cannot redefine \textless{}construct-type\textgreater{} \textless{}construct-name\textgreater{} while it
is in use.

A construct cannot be redefined while it is being used by another
construct or other data structure (such as a fact or instance).

Example:

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (deftemplate bar)

CLIPS\textgreater{} (assert (bar))

\textless{}Fact-0\textgreater{}

CLIPS\textgreater{} (deftemplate (bar (slot x)))

{[}CSTRNCHK1{]} \sphinxstyleemphasis{Message Varies}

This error ID covers a range of messages indicating a type, value,
range, or cardinality violation.

Example:

CLIPS\textgreater{} (deftemplate foo (slot x (type SYMBOL)))

CLIPS\textgreater{} (assert (foo (x 3)))

{[}CSTRNPSR1{]} The \textless{}first attribute name\textgreater{} attribute conflicts with the
\textless{}second attribute name\textgreater{} attribute.

This error message occurs when two slot attributes conflict.

Example:

CLIPS\textgreater{} (deftemplate foo (slot x (type SYMBOL) (range 0 2)))

{[}CSTRNPSR2{]} Minimum \textless{}attribute\textgreater{} value must be less than

or equal to the maximum \textless{}attribute\textgreater{} value.

The minimum attribute value for the range and cardinality attributes
must be less than or equal to the maximum attribute value for the
attribute.

Example:

CLIPS\textgreater{} (deftemplate foo (slot x (range 8 1)))

{[}CSTRNPSR3{]} The \textless{}first attribute name\textgreater{} attribute cannot be used in
conjunction with the \textless{}second attribute name\textgreater{} attribute.

The use of some slot attributes excludes the use of other slot
attributes.

Example:

CLIPS\textgreater{} (deftemplate foo (slot x (allowed-values a)

(allowed-symbols b)))

{[}CSTRNPSR4{]} Value does not match the expected type for the \textless{}attribute
name\textgreater{} attribute.

The arguments to an attribute must match the type expected for that
attribute (e.g. integers must be used for the allowed-integers
attribute).

Example:

CLIPS\textgreater{} (deftemplate example (slot x (allowed-integers 3.0)))

{[}CSTRNPSR5{]} The cardinality attribute can only be used with multifield
slots.

The cardinality attribute can only be used for slots defined with the
multislot keyword.

Example:

CLIPS\textgreater{} (deftemplate foo (slot x (cardinality 1 1)))

{[}CSTRNPSR6{]} Minimum cardinality value must be greater than or equal to
zero.

A multislot with no value has a cardinality of 0. It is not possible to
have a lower cardinality.

Example:

CLIPS\textgreater{} (deftemplate foo (multislot x (cardinality -3 1)))

{[}DEFAULT1{]} The default value for a single field slot must be a single
field value.

This error occurs when the default or default-dynamic attribute for a
single-field slot does not contain a single value or an expression
returning a single value.

Example:

CLIPS\textgreater{} (deftemplate error (slot x (default)))

{[}DFFNXPSR1{]} Deffunctions are not allowed to replace constructs.

A deffunction cannot have the same name as any construct.

Example:

CLIPS\textgreater{} (deffunction defgeneric ())

{[}DFFNXPSR2{]} Deffunctions are not allowed to replace external functions.

A deffunction cannot have the same name as any system or user-defined
external function.

Example:

CLIPS\textgreater{} (deffunction + ())

{[}DFFNXPSR3{]} Deffunctions are not allowed to replace generic functions.

A deffunction cannot have the same name as any generic function.

Example:

CLIPS\textgreater{} (defgeneric foo)

CLIPS\textgreater{} (deffunction foo ())

{[}DFFNXPSR4{]} Deffunction \textless{}name\textgreater{} may not be redefined while it is
executing.

A deffunction can be loaded at any time except when a deffunction of the
same name is already executing.

Example:

CLIPS\textgreater{}

(deffunction foo ()

(build “(deffunction foo ())”))

CLIPS\textgreater{} (foo)

\sphinxstylestrong{{[}DFFNXPSR5{]} Defgeneric \textless{}name\textgreater{} imported from module \textless{}module name\textgreater{}
conflicts with this deffunction.}

A deffunction cannot have the same name as any generic function imported
from another module.

Example:

CLIPS\textgreater{} (defmodule MAIN (export ?ALL))

CLIPS\textgreater{} (defmethod foo ())

CLIPS\textgreater{} (defmodule FOO (import MAIN ?ALL))

CLIPS\textgreater{} (deffunction foo)

{[}DRIVE1{]} This error occurred in the join network

Problem resides in join \#\textless{}pattern-number\textgreater{} in rule(s):

\textless{}problem-rules\textgreater{}+

This error pinpoints other evaluation errors associated with evaluating
an expression within the join network. The specific pattern of the
problem rules is identified.

{[}EMATHFUN1{]} Domain error for \textless{}function-name\textgreater{} function

This error occurs when an argument passed to a math function is not in
the domain of values for which a return value exists.

{[}EMATHFUN2{]} Argument overflow for \textless{}function-name\textgreater{} function

This error occurs when an argument to an extended math function would
cause a numeric overflow.

{[}EMATHFUN3{]} Singularity at asymptote in \textless{}function-name\textgreater{} function

This error occurs when an argument to a trigonometric math function
would cause a singularity.

{[}EVALUATN1{]} Variable \textless{}name\textgreater{} is unbound

This error occurs when a local variable not set by a previous call to
\sphinxstylestrong{bind} is accessed at the top level.

Example:

CLIPS\textgreater{} (progn ?error)

{[}EVALUATN2{]} No function, generic function or deffunction of name \textless{}name\textgreater{}
exists for external call.

IThis error occurs only when an invalid function name is passed to the
external C access routine CLIPSFunctionCall.

{[}EXPRNPSR1{]} A function name must be a symbol

In the following example, ‘\sphinxstylestrong{\textasciitilde{}}’ is recognized by CLIPS as an operator,
not a function:

Example:

CLIPS\textgreater{} (+ (\textasciitilde{} 3 4) 4)

{[}EXPRNPSR2{]} Expected a constant, variable, or expression

In the following example, ‘\sphinxstylestrong{\textasciitilde{}}’ is an operator and is illegal as an
argument to a function call:

Example:

CLIPS\textgreater{} (\textless{}= \textasciitilde{} 4)

{[}EXPRNPSR3{]} Missing function declaration for \textless{}name\textgreater{}

CLIPS does not recognize \textless{}name\textgreater{} as a declared function and gives this
error message.

Example:

CLIPS\textgreater{} (xyz)

{[}EXPRNPSR4{]} \$ Sequence operator not a valid argument for \textless{}name\textgreater{}.

The sequence expansion operator cannot be used with certain functions.

Example:

CLIPS\textgreater{} (set-sequence-operator-recognition TRUE)

FALSE

CLIPS\textgreater{} (defrule foo (x \$?y) =\textgreater{} (assert (x1 \$?y)))

{[}FACTMCH1{]} This error occurred in the pattern network

Currently active fact: \textless{}newly assert fact\textgreater{}

Problem resides in slot \textless{}slot name\textgreater{}

Of pattern \#\textless{}pattern-number\textgreater{} in rule(s):

\textless{}problem-rules\textgreater{}+

This error pinpoints other evaluation errors associated with evaluating
an expression within the pattern network. The specific pattern and field
of the problem rules are identified.

{[}FACTMNGR1{]} Facts may not be retracted during pattern-matching

or

{[}FACTMNGR2{]} Facts may not be retracted during pattern-matching

Functions used on the LHS of a rule should not have side effects (such
as the creation of a new instance or fact).

Example:

CLIPS\textgreater{}

(defrule error

(test (assert (blah)))

=\textgreater{})

CLIPS\textgreater{} (reset)

{[}FACTRHS1{]} Template \textless{}name\textgreater{} does not exist for assert.

This error occurs when an assert is attempted for a deftemplate which
does not exist in a runtime or active \sphinxstylestrong{bload} image. In other
situations, CLIPS will create an implied deftemplate if one does not
already exist.

Example:

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (bsave error.bin)

TRUE

CLIPS\textgreater{} (bload error.bin)

TRUE

CLIPS\textgreater{} (assert (error))

{[}GENRCCOM1{]} No such generic function \textless{}name\textgreater{} in function undefmethod.

This error occurs when the generic function name passed to the
undefmethod function does not exist.

Example:

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (undefmethod yak 3)

{[}GENRCCOM2{]} Expected a valid method index in function undefmethod.

This error occurs when an invalid method index is passed to undefmethod
(e.g. a negative integer or a symbol other than *).

Example:

CLIPS\textgreater{} (defmethod foo ())

CLIPS\textgreater{} (undefmethod foo a))

{[}GENRCCOM3{]} Incomplete method specification for deletion.

It is illegal to specify a non-wildcard method index when a wildcard is
given for the generic function in the function \sphinxstylestrong{undefmethod}.

Example:

CLIPS\textgreater{} (undefmethod * 1)

{[}GENRCCOM4{]} Cannot remove implicit system function method for generic
function \textless{}name\textgreater{}.

A method corresponding to a system defined function cannot be deleted.

Example:

CLIPS\textgreater{} (defmethod integer ((?x SYMBOL)) 0)

CLIPS\textgreater{} (list-defmethods integer)

integer \#SYS1 (NUMBER)

integer \#2 (SYMBOL)

For a total of 2 methods.

CLIPS\textgreater{} (undefmethod integer 1)

{[}GENRCEXE1{]} No applicable methods for \textless{}name\textgreater{}.

The generic function call arguments do not satisfy any method?s
parameter restrictions.

Example:

CLIPS\textgreater{} (defmethod foo ())

CLIPS\textgreater{} (foo 1 2)

{[}GENRCEXE2{]} Shadowed methods not applicable in current context.

No shadowed method is available when the function \sphinxstylestrong{call-next-method}
is called.

Example:

CLIPS\textgreater{} (call-next-method)

{[}GENRCEXE3{]} Unable to determine class of \textless{}value\textgreater{} in generic function
\textless{}name\textgreater{}.

The class or type of a generic function argument could not be determined
for comparison to a method type restriction.

Example:

CLIPS\textgreater{} (defmethod foo ((?a INTEGER)))

CLIPS\textgreater{} (foo {[}bogus-instance{]})

{[}GENRCEXE4{]} Generic function \textless{}name\textgreater{} method \#\textless{}index\textgreater{} is not applicable to
the given arguments.

This error occurs when \sphinxstylestrong{call-specific-method} is called with an
inappropriate set of arguments for the specified method.

Example:

CLIPS\textgreater{} (defmethod foo ())

CLIPS\textgreater{} (call-specific-method foo 1 abc)

{[}GENRCFUN1{]} Defgeneric \textless{}name\textgreater{} cannot be modified while one of its
methods is executing.

Defgenerics can?t be redefined while one of their methods is currently
executing.

Example:

CLIPS\textgreater{} (defgeneric foo)

CLIPS\textgreater{} (defmethod foo () (build “(defgeneric foo)”))

CLIPS\textgreater{} (foo)

{[}GENRCFUN2{]} Unable to find method \textless{}name\textgreater{} \#\textless{}index\textgreater{} in function \textless{}name\textgreater{}.

No generic function method of the specified index could be found by the
named function.

Example:

CLIPS\textgreater{} (defmethod foo 1 ())

CLIPS\textgreater{} (ppdefmethod foo 2)

{[}GENRCFUN3{]} Unable to find generic function \textless{}name\textgreater{} in function \textless{}name\textgreater{}.

No generic function method of the specified index could be found by the
named function.

Example:

CLIPS\textgreater{} (preview-generic balh)

{[}GENRCPSR1{]} Expected ‘)’ to complete defgeneric.

A right parenthesis completes the definition of a generic function
header.

Example:

CLIPS\textgreater{} (defgeneric foo ())

{[}GENRCPSR2{]} New method \#\textless{}index1\textgreater{} would be indistinguishable from method
\#\textless{}index2\textgreater{}.

An explicit index has been specified for a new method that does not
match that of an older method which has identical parameter
restrictions.

Example:

CLIPS\textgreater{} (defmethod foo 1 ((?a INTEGER)))

CLIPS\textgreater{} (defmethod foo 2 ((?a INTEGER)))

{[}GENRCPSR3{]} Defgenerics are not allowed to replace constructs.

A generic function cannot have the same name as any construct.

\sphinxstylestrong{{[}GENRCPSR4{]} Deffunction \textless{}name\textgreater{} imported from module \textless{}module name\textgreater{}
conflicts with this defgeneric.}

A deffunction cannot have the same name as any generic function imported
from another module.

Example:

CLIPS\textgreater{} (defmodule MAIN (export ?ALL))

CLIPS\textgreater{} (deffunction foo ())

CLIPS\textgreater{} (defmodule FOO (import MAIN ?ALL))

CLIPS\textgreater{} (defmethod foo)

{[}GENRCPSR5{]} Generic functions are not allowed to replace deffunctions.

A generic function cannot have the same name as any deffunction.

{[}GENRCPSR6{]} Method index out of range.

A method index cannot be greater than the maximum value of an integer or
less than 1.

Example:

CLIPS\textgreater{} (defmethod foo 0 ())

{[}GENRCPSR7{]} Expected a ‘(‘ to begin method parameter restrictions.

A left parenthesis must begin a parameter restriction list for a method.

Example:

CLIPS\textgreater{} (defmethod foo)

{[}GENRCPSR8{]} Expected a variable for parameter specification.

A method parameter with restrictions must be a variable.

Example:

CLIPS\textgreater{} (defmethod foo ((abc)))

{[}GENRCPSR9{]} Expected a variable or ‘(‘ for parameter specification.

A method parameter must be a variable with or without restrictions.

Example:

CLIPS\textgreater{} (defmethod foo (abc))

{[}GENRCPSR10{]} Query must be last in parameter restriction.

A query parameter restriction must follow a type parameter restriction
(if any).

Example:

CLIPS\textgreater{} (defmethod foo ((?a (\textless{} ?a 1) INTEGER)))

{[}GENRCPSR11{]} Duplicate classes/types not allowed in parameter
restriction.

A method type parameter restriction may have only a single occurrence of
a particular class.

Example:

CLIPS\textgreater{} (defmethod foo ((?a INTEGER INTEGER)))

{[}GENRCPSR12{]} Binds are not allowed in query expressions.

Binding new variables in a method query parameter restriction is
illegal.

Example:

CLIPS\textgreater{} (defmethod foo ((?a (bind ?b 1))))

{[}GENRCPSR13{]} Expected a valid class/type name or query.

Method parameter restrictions consist of zero or more class names and an
optional query expression.

Example:

CLIPS\textgreater{} (defmethod foo ((?a 34)))

{[}GENRCPSR14{]} Unknown class/type in method.

Classes in method type parameter restrictions must already be defined.

Example:

CLIPS\textgreater{} (defmethod foo ((?a bogus-class)))

{[}GENRCPSR15{]} \textless{}name\textgreater{} class is redundant.

All classes in a method type parameter restriction should be unrelated.

Example:

CLIPS\textgreater{} (defmethod foo ((?a INTEGER NUMBER)))

{[}GENRCPSR16{]} The system function \textless{}name\textgreater{} cannot be overloaded.

Some system functions canot be overloaded.

Example:

CLIPS\textgreater{} (defmethod if ())

{[}GENRCPSR17{]} Cannot replace the implicit system method \#\textless{}integer\textgreater{}.

A system function can not be overloaded with a method that has the exact
number and types of arguments.

Example:

CLIPS\textgreater{} (defmethod integer ((?x NUMBER)) (* 2 ?x))

{[}GLOBLDEF1{]} Global variable \textless{}variable name\textgreater{} is unbound.

A global variable must be defined before it can be accessed at the
command prompt or elsewhere.

Example:

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} ?*x*

{[}GLOBLPSR1{]} Global variable \textless{}variable name\textgreater{} was referenced, but is not
defined.

A global variable must be defined before it can be accessed at the
command prompt or elsewhere.

Example:

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} ?*x*

{[}INCRRSET1{]} The incremental reset behavior cannot be changed with rules
loaded.

The incremental reset behaviour can only be changed when there are no
currently defined rules.

{[}INHERPSR1{]} A class may not have itself as a superclass.

A class may not inherit from itself.

Example:

CLIPS\textgreater{} (defclass A (is-a A))

{[}INHERPSR2{]} A class may inherit from a superclass only once.

All direct superclasses of a class must be unique.

Example:

CLIPS\textgreater{} (defclass A (is-a USER USER))

{[}INHERPSR3{]} A class must be defined after all its superclasses.

Subclasses must be defined last.

Example:

CLIPS\textgreater{} (defclass B (is-a A))

{[}INHERPSR4{]} Must have at least one superclass.

All user-defined classes must have at least one direct superclass.

Example:

CLIPS\textgreater{} (defclass A (is-a))

{[}INHERPSR5{]} Partial precedence list formed: \textless{}classa\textgreater{} \textless{}classb\textgreater{} ?E\textless{}classc\textgreater{}

Precedence loop in superclasses: \textless{}class1\textgreater{} \textless{}class2\textgreater{} ?E\textless{}classn\textgreater{} \textless{}class1\textgreater{}

No class precedence list satisfies the rules specified in section
9.3.1.1 for the given direct superclass list. The message shows a
conflict for \textless{}class1\textgreater{} because the precedence implies that \textless{}class1\textgreater{} must
both precede and succeed \textless{}class2\textgreater{} through \textless{}classn\textgreater{}. The full loop can be
used to help identify which particular classes are causing the problem.
This loop is not necessarily the only loop in the precedence list; it is
the first one detected. The part of the precedence list which was
successfully formed is also listed.

Example:

CLIPS\textgreater{} (defclass A (is-a MULTIFIELD FLOAT SYMBOL))

CLIPS\textgreater{} (defclass B (is-a SYMBOL FLOAT))

CLIPS\textgreater{} (defclass C (is-a A B))

{[}INHERPSR6{]} A user-defined class cannot be a subclass of \textless{}name\textgreater{}.

The INSTANCE, INSTANCE-NAME, and INSTANCE-ADDRESS classes cannot have
any subclasses.

Example:

CLIPS\textgreater{} (defclass A (is-a INSTANCE))

{[}INSCOM1{]} Undefined type in function \textless{}name\textgreater{}.

The evaluation of an expression yielded something other than a
recognized class or primitive type.

{[}INSFILE1{]} Function \textless{}function-name\textgreater{} could not completely process file
\textless{}name\textgreater{}.

This error occurs when an instance definition is improperly formed in
the input file for the \sphinxstylestrong{load-instances}, \sphinxstylestrong{restore-instances}, or
\sphinxstylestrong{bload-instances} command.

Example:

CLIPS\textgreater{} (load-instances bogus.txt)

{[}INSFILE2{]} \textless{}file-name\textgreater{} file is not a binary instances file.

or

{[}INSFILE3{]} \textless{}file-name\textgreater{} file is not a compatible binary instances file.

This error occurs when bload-instances attempts to load a file that was
not created with bsave-instances or when the file being loaded was
created by a different version of CLIPS.

Example:

CLIPS\textgreater{} (reset)

CLIPS\textgreater{} (save-instances foo.ins)

1

CLIPS\textgreater{} (bload-instances foo.ins)

{[}INSFILE4{]} Function bload-instances unable to load instance
\textless{}instance-name\textgreater{}.

This error occurs when an instance specification in the input file for
the \sphinxstylestrong{bload-instances} command could not be created.

Example:

CLIPS\textgreater{} (defclass A (is-a USER) (role concrete))

CLIPS\textgreater{} (make-instance of A)

{[}gen1{]}

CLIPS\textgreater{} (bsave-instances foo.bin)

1

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{} (bload-instances foo.bin)

{[}INSFUN1{]} Expected a valid instance in function \textless{}name\textgreater{}.

The named function expected an instance-name or address as an argument.

Example:

CLIPS\textgreater{} (initialize-instance 34)

{[}INSFUN2{]} No such instance \textless{}name\textgreater{} in function \textless{}name\textgreater{}.

This error occurs when the named function cannot find the specified
instance.

Example:

CLIPS\textgreater{} (instance-address {[}bogus-instance{]})

{[}INSFUN3{]} No such slot \textless{}name\textgreater{} in function \textless{}name\textgreater{}.

This error occurs when the named function cannot find the specified slot
in an instance or class.

Example:

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{} (slot-writablep A b)

{[}INSFUN4{]} Invalid instance-address in function \textless{}name\textgreater{}.

This error occurs when an attempt is made to use the address of a
deleted instance.

Example:

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{} (make-instance a of A)

{[}a{]}

CLIPS\textgreater{} (defglobal ?*x* = (instance-address a))

CLIPS\textgreater{} (make-instance a of A)

{[}a{]}

CLIPS\textgreater{} (class ?*x*)

{[}INSFUN5{]} Cannot modify reactive instance slots while pattern-matching
is in process.

CLIPS does not allow reactive instance slots to be changed while
pattern-matching is taking place. Functions used on the LHS of a rule
should not have side effects (such as the changing slot values).

Example:

CLIPS\textgreater{}

(defclass FOO (is-a USER)

(role concrete)

(pattern-match reactive)

(slot x (create-accessor read-write)))

CLIPS\textgreater{} (make-instance x of FOO)

{[}x{]}

CLIPS\textgreater{} (defrule BAR (x) (test (send {[}x{]} put-x 3)) =\textgreater{})

CLIPS\textgreater{} (assert (x))

{[}INSFUN6{]} Unable to pattern-match on shared slot \textless{}name\textgreater{} in class \textless{}name\textgreater{}.

This error occurs when the number of simultaneous class hierarchy
traversals is exceeded while pattern-matching on a shared slot. See the
related error message {[}CLASSFUN2{]} for more details.

{[}INSFUN7{]} \textless{}multifield-value\textgreater{} illegal for single-field slot \textless{}name\textgreater{} of
instance \textless{}name\textgreater{} found in \textless{}function-call or message-handler\textgreater{}.

Single-field slots in an instance can hold only one atomic value.

Example:

CLIPS\textgreater{} (set-static-constraint-checking FALSE)

TRUE

CLIPS\textgreater{}

(defclass FOO (is-a USER)

(role concrete)

(slot foo))

CLIPS\textgreater{}

(defmessage-handler FOO error ()

(bind ?self:foo 1 2 3))

CLIPS\textgreater{} (make-instance foo of FOO)

{[}foo{]}

CLIPS\textgreater{} (send {[}foo{]} error)

{[}INSFUN8{]} Void function illegal value for slot \textless{}name\textgreater{} of instance \textless{}name\textgreater{}
found in \textless{}function-call or message-handler\textgreater{}.

Only functions which have a return value can be used to generate values
for an instance slot.

Example:

CLIPS\textgreater{} (set-static-constraint-checking FALSE)

TRUE

CLIPS\textgreater{}

(defclass FOO (is-a USER)

(role concrete)

(slot foo))

CLIPS\textgreater{}

(defmessage-handler FOO error ()

(bind ?self:foo (instances)))

CLIPS\textgreater{} (make-instance foo of FOO)

{[}foo{]}

CLIPS\textgreater{} (send {[}foo{]} error)

{[}INSMNGR1{]} Expected a valid name for new instance.

\sphinxstylestrong{make-instance} expects a symbol or an instance-name for the name of a
new instance.

Example:

CLIPS\textgreater{} (make-instance 34 of A)

{[}INSMNGR2{]} Expected a valid class name for new instance.

\sphinxstylestrong{make-instance} expects a symbol for the class of a new instance.

Example:

CLIPS\textgreater{} (make-instance a of 34)

{[}INSMNGR3{]} Cannot create instances of abstract class \textless{}name\textgreater{}.

Direct instances of abstract classes, such as the predefined system
classes, are illegal.

Example:

CLIPS\textgreater{} (make-instance {[}foo{]} of USER)

{[}INSMGNR4{]} The instance \textless{}name\textgreater{} has a slot-value which depends on the
instance definition.

The initialization of an instance is recursive in that a slot-override
or default-value tries to create or reinitialize the same instance.

Example:

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot foo))

CLIPS\textgreater{}

(make-instance a of A (foo (make-instance a of A)))

{[}INSMNGR5{]} Unable to delete old instance \textless{}name\textgreater{}.

\sphinxstylestrong{make-instance} will attempt to delete an old instance of the same
name if it exists. This error occurs if that deletion fails.

Example:

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{}

(defmessage-handler A delete around ()

(if (neq (instance-name ?self) {[}a{]}) then

(call-next-handler)))

CLIPS\textgreater{} (make-instance a of A)

CLIPS\textgreater{} (make-instance a of A)

{[}INSMNGR6{]} Cannot delete instance \textless{}name\textgreater{} during initialization.

The evaluation of a slot-override in \sphinxstylestrong{make-instance} or
\sphinxstylestrong{initialize-instance} attempted to delete the instance.

Example:

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot foo))

CLIPS\textgreater{}

(defmessage-handler A put-foo after (\$?any)

(delete-instance))

CLIPS\textgreater{} (make-instance a of A (foo 2))

{[}INSMNGR7{]} Instance \textless{}name\textgreater{} is already being initialized.

An instance cannot be reinitialized during initialization.

Example:

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{} (make-instance a of A)

CLIPS\textgreater{}

(defmessage-handler A init after ()

(initialize-instance ?self))

CLIPS\textgreater{} (initialize-instance a)

CLIPS\textgreater{} (send {[}a{]} try)

{[}INSMNGR8{]} An error occurred during the initialization of instance
\textless{}name\textgreater{}.

This message is displayed when an evaluation error occurs while the
\sphinxstylestrong{init} message is executing for an instance.

{[}INSMNGR9{]} Expected a valid slot name for slot-override.

\sphinxstylestrong{make-instance} and \sphinxstylestrong{initialize-instance} expect symbols for slot
names.

Example:

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{} (make-instance a of A (34 override-value))

{[}INSMNGR10{]} Cannot create instances of reactive classes while
pattern-matching is in process.

CLIPS does not allow instances of reactive classes to be created while
pattern-matching is taking place. Functions used on the LHS of a rule
should not have side effects (such as the creation of a new instance or
fact).

Example:

CLIPS\textgreater{} (defclass FOO (is-a USER) (role concrete) (pattern-match
reactive))

CLIPS\textgreater{} (defrule BAR (x) (test (make-instance of FOO)) =\textgreater{})

CLIPS\textgreater{} (assert (x))

{[}INSMNGR11{]} Invalid module specifier in new instance name.

This error occurs when the module specifier in the instance-name is
illegal (such as an undefined module name).

Example:

CLIPS\textgreater{} (defclass FOO (is-a USER) (role concrete))

CLIPS\textgreater{} (make-instance BOGUS::x of FOO)

{[}INSMNGR12{]} Cannot delete instances of reactive classes while
pattern-matching is in process.

CLIPS does not allow instances of reactive classes to be deleted while
pattern-matching is taking place. Functions used on the LHS of a rule
should not have side effects (such as the deletion of a new instance or
the retraction of a fact).

Example:

CLIPS\textgreater{} (defclass FOO (is-a USER) (role concrete) (pattern-match
reactive))

CLIPS\textgreater{} (make-instance x of FOO)

{[}x{]}

CLIPS\textgreater{} (defrule BAR (x) (test (send {[}x{]} delete)) =\textgreater{})

CLIPS\textgreater{} (assert (x))

{[}INSMNGR13{]} Slot \textless{}slot-name\textgreater{} does not exist in instance \textless{}instance-name\textgreater{}.

This error occurs when the slot name of a slot override does not
correspond to any of the valid slot names for an instance.

Example:

CLIPS\textgreater{} (defclass FOO (is-a USER) (role concrete))

CLIPS\textgreater{} (make-instance of FOO (x 3))

{[}INSMNGR14{]} Override required for slot \textless{}slot-name\textgreater{} in instance
\textless{}instance-name\textgreater{}.

If the ?NONE keyword was specified with the default attribute for a
slot, then a slot override must be provided when an instance containing
that slot is created.

Example:

CLIPS\textgreater{} (defclass FOO (is-a USER)

(role concrete)

(slot x (default ?NONE)))

CLIPS\textgreater{} (make-instance of FOO)

{[}INSMNGR15{]} init-slots not valid in this context.

The special function \sphinxstylestrong{init-slots} (for initializing slots of an
instance to the class default values) can only be called during the
dispatch of an \sphinxstylestrong{init} message for an instance, i.e., in an \sphinxstylestrong{init}
message-handler.

Example:

CLIPS\textgreater{}

(defmessage-handler INITIAL-OBJECT error ()

(init-slots))

CLIPS\textgreater{} (reset)

CLIPS\textgreater{} (send {[}initial-object{]} error)

{[}INSMODDP1{]} Direct/message-modify message valid only in modify-instance.

The \sphinxstylestrong{direct-modify} and \sphinxstylestrong{message-modify} message-handlers attached
to the class \sphinxstylestrong{USER} can only be called as a result of the appropriate
message being sent.by the \sphinxstylestrong{modify-instance} or
\sphinxstylestrong{message-modify-instance} functions. Additional handlers may be
defined, but the message can only be sent in this context.

Example:

CLIPS\textgreater{} (reset)

CLIPS\textgreater{} (send {[}initial-object{]} direct-modify 0)

{[}INSMODDP2{]} Direct/message-duplicate message valid only in
duplicate-instance.

The \sphinxstylestrong{direct-duplicate} and \sphinxstylestrong{message-duplicate} message-handlers
attached to the class \sphinxstylestrong{USER} can only be called as a result of the
appropriate message being sent.by the \sphinxstylestrong{duplicate-instance} or
\sphinxstylestrong{message-duplicate-instance} functions. Additional handlers may be
defined, but the message can only be sent in this context.

Example:

CLIPS\textgreater{} (reset)

CLIPS\textgreater{} (send {[}initial-object{]} direct-duplicate 0 0)

{[}INSMODDP3{]} Instance copy must have a different name in
duplicate-instance.

If an instance-name is specified for the new instance in the call to
\sphinxstylestrong{duplicate-instance}, it must be different from the source instance?s
name.

Example:

CLIPS\textgreater{} (reset)

CLIPS\textgreater{} (duplicate-instance initial-object to initial-object)

{[}INSMULT1{]} Function \textless{}name\textgreater{} cannot be used on single-field slot \textless{}name\textgreater{} in
instance \textless{}name\textgreater{}.

The functions described in section 12.13.4.12, such as \sphinxstylestrong{slot-insert\$},
can only operate on multifield slots.

Example:

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot foo))

CLIPS\textgreater{} (make-instance a of A)

{[}a{]}

CLIPS\textgreater{} (slot-insert\$ a foo 1 abc def)

{[}INSQYPSR1{]} Duplicate instance-set member variable name in function
\textless{}name\textgreater{}.

Instance-set member variables in an instance-set query function must be
unique.

Example:

CLIPS\textgreater{} (any-instancep ((?a OBJECT) (?a OBJECT)) TRUE)

{[}INSQYPSR2{]} Binds are not allowed in instance-set query in function
\textless{}name\textgreater{}.

An instance-set query cannot bind variables.

Example:

CLIPS\textgreater{}

(any-instancep ((?a OBJECT) (?b OBJECT))

(bind ?c 1))

{[}INSQYPSR3{]} Cannot rebind instance-set member variable \textless{}name\textgreater{} in
function \textless{}name\textgreater{}.

Instance-set member variables cannot be changed within the actions of an
instance-set query function.

Example:

CLIPS\textgreater{}

(do-for-all-instances ((?a USER))

(if (slot-existp ?a age) then

(\textgreater{} ?a:age 30))

(bind ?a (send ?a get-brother)))

{[}IOFUN1{]} Illegal logical name used for \textless{}function name\textgreater{} function.

A logical name must be either a symbol, string, instance-name, float, or
integer.

Example:

(printout (create\$ a b c) x)

{[}IOFUN2{]} Logical name \textless{}logical name\textgreater{} already in use.

A logical name cannot be associated with two different files.

Example:

CLIPS\textgreater{} (open “foo.txt” foo “w”)

TRUE

CLIPS\textgreater{} (open “foo2.txt” foo “w”)

{[}MEMORY1{]} Out of memory

This error indicates insufficient memory exists to expand internal
struc?tures enough to allow continued operation (causing an exit to the
operating system).

{[}MEMORY2{]} Release error in genfree

This error indicates a problem in the memory management routines.

{[}MEMORY3{]} Unable to allocate memory block \textgreater{} 32K

This error occurs when the bload function attempts to allocate a block
of memory larger than 32K and the operating system does not permit
blocks greater than 32K to be allocated. This will only occur on
machines which have 2 byte integers (excluding the Macintosh and IBM PC
which have machine dependent code provided so that they can allocate
more than 32K). When this error occurs, CLIPS exits to the operating
system.

{[}MISCFUN1{]} expand\$ must be used in the argument list of a function call.

The expand\$ function may not be called unless it is within the argument
list of another function.

Example:

CLIPS\textgreater{} (expand\$ (create\$ a b c))

{[}MODULDEF1{]} Illegal use of the module specifier.

The module specifier can only be used as part of a defined construct?s
name or as an argument to a function.

Example:

CLIPS\textgreater{} (deffunction y ())

CLIPS\textgreater{} (MAIN::y)

{[}MODULPSR1{]} Module \textless{}module name\textgreater{} does not export any constructs.

or

{[}MODULPSR1{]} Module \textless{}module name\textgreater{} does not export any \textless{}construct type\textgreater{}
constructs.

or

{[}MODULPSR1{]} Module \textless{}module name\textgreater{} does not export the \textless{}construct type\textgreater{}
\textless{}construct name\textgreater{}.

A construct cannot be imported from a module unless the defmodule
exports that construct.

Example:

CLIPS\textgreater{} (clear)

CLIPS\textgreater{} (defmodule BAR)

CLIPS\textgreater{} (deftemplate BAR::bar)

CLIPS\textgreater{} (defmodule FOO (import BAR deftemplate bar)))

{[}MSGCOM1{]} Incomplete message-handler specification for deletion.

It is illegal to specify a non-wildcard handler index when a wildcard is
given for the class in the external C function
\sphinxstylestrong{UndefmessageHandler()}. This error can only be generated when a
user-defined external function linked with CLIPS calls this function
incorrectly.

{[}MSGCOM2{]} Unable to find message-handler \textless{}name\textgreater{} \textless{}type\textgreater{} for class \textless{}name\textgreater{}
in function \textless{}name\textgreater{}.

This error occurs when the named function cannot find the specified
message-handler.

Example:

CLIPS\textgreater{} (ppdefmessage-handler USER foo around)

{[}MSGCOM3{]} Unable to delete message-handlers.

This error occurs when a message-handler can?t be deleted (such as when
a binary image is loaded).

Example:

CLIPS\textgreater{} (defclass FOO (is-a USER) (role concrete))

CLIPS\textgreater{} (defmessage-handler FOO bar ())

CLIPS\textgreater{} (bsave foo.bin)

TRUE

CLIPS\textgreater{} (bload foo.bin)

TRUE

CLIPS\textgreater{} (undefmessage-handler FOO bar)

{[}MSGFUN1{]} No applicable primary message-handlers found for \textless{}message\textgreater{}.

No primary message-handler attached to the object?s classes matched the
name of the message.

Example:

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{} (make-instance a of A)

{[}a{]}

CLIPS\textgreater{} (send {[}a{]} bogus-message)

{[}MSGFUN2{]} Message-handler \textless{}name\textgreater{} \textless{}type\textgreater{} in class \textless{}name\textgreater{} expected
exactly/at least \textless{}number\textgreater{} argument(s).

The number of message arguments was inappropriate for one of the
applicable message-handlers.

Example:

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{} (defmessage-handler USER foo (?a ?b))

CLIPS\textgreater{} (make-instance a of A)

{[}a{]}

CLIPS\textgreater{} (send {[}a{]} foo)

{[}MSGFUN3{]} \textless{}name\textgreater{} slot in instance \textless{}name\textgreater{}: write access denied.

This error occurs when an attempt is made to change the value of a
read-only slot.

Example:

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot foo (default 100)

(read-only)))

CLIPS\textgreater{} (make-instance a of A)

{[}a{]}

CLIPS\textgreater{} (send {[}a{]} put-foo)

{[}MSGFUN4{]} \textless{}function\textgreater{} may only be called from within message-handlers.

The named function operates on the active instance of a message and thus
can only be called by message-handlers.

Example:

CLIPS\textgreater{} (ppinstance)

{[}MSGFUN5{]} \textless{}function\textgreater{} operates only on instances.

The named function operates on the active instance of a message and can
only handle instances of user-defined classes (not primitive type
objects).

Example:

CLIPS\textgreater{}

(defmessage-handler INTEGER print ()

(ppinstance))

CLIPS\textgreater{} (send 34 print)

{[}MSGFUN6{]} Private slot \textless{}slot-name\textgreater{} of class \textless{}class-name\textgreater{} cannot be
accessed directly by handlers attached to class \textless{}class-name\textgreater{}

A subclass which inherits private slots from a superclass may not access
those slots using the ?self variable. This error can also occur when a
superclass tries to access via \sphinxstylestrong{dynamic-put} or \sphinxstylestrong{dynamic-get} a
private slot in a subclass.

Example:

CLIPS\textgreater{} (defclass FOO (is-a USER) (role concrete) (slot x))

CLIPS\textgreater{} (defclass BAR (is-a FOO))

CLIPS\textgreater{} (defmessage-handler BAR yak () ?self:x)

{[}MSGFUN7{]} Unrecognized message-handler type in defmessage-handler.

Allowed message-handler types include primary, before, after, and
around.

Example:

CLIPS\textgreater{} (defmessage-handler USER foo behind ())

{[}MSGFUN8{]} Unable to delete message-handler(s) from class \textless{}name\textgreater{}.

This error occurs when an attempt is made to delete a message-handler
attached to a class for which any of the message-handlers are executing.

Example:

CLIPS\textgreater{} (reset)

CLIPS\textgreater{}

(defmessage-handler INITIAL-OBJECT error ()

(undefmessage-handler INITIAL-OBJECT error primary))

CLIPS\textgreater{} (send {[}initial-object{]} error)

{[}MSGPASS1{]} Shadowed message-handlers not applicable in current context.

No shadowed message-handler is available when the function
\sphinxstylestrong{call-next-handler} or \sphinxstylestrong{override-next-handler} is called.

Example:

CLIPS\textgreater{} (call-next-handler)

{[}MSGPASS2{]} No such instance \textless{}name\textgreater{} in function \textless{}name\textgreater{}.

This error occurs when the named function cannot find the specified
instance.

Example:

CLIPS\textgreater{} (instance-address {[}bogus-instance{]})

{[}MSGPASS3{]} Static reference to slot \textless{}name\textgreater{} of class \textless{}name\textgreater{} does not
apply to \textless{}instance-name\textgreater{} of \textless{}class-name\textgreater{}.

This error occurs when a static reference to a slot in a superclass by a
message-handler attached to that superclass is incorrectly applied to an
instance of a subclass which redefines that slot. Static slot references
always refer to the slot defined in the class to which the
message-handler is attached.

Example:

CLIPS\textgreater{}

(defclass A (is-a USER)

(slot foo))

CLIPS\textgreater{}

(defclass B (is-a A)

(role concrete)

(slot foo))

CLIPS\textgreater{}

(defmessage-handler A access-foo ()

?self:foo)

CLIPS\textgreater{} (make-instance b of B)

{[}b{]}

CLIPS\textgreater{} (send {[}b{]} access-foo)

{[}MSGPSR1{]} A class must be defined before its message-handlers.

A message-handler can only be attached to an existing class.

Example:

CLIPS\textgreater{} (defmessage-handler bogus-class foo ())

{[}MSGPSR2{]} Cannot (re)define message-handlers during execution of other
message-handlers for the same class.

No message-handlers for a class can be loaded while any current
message-handlers attached to the class are executing.

Example:

CLIPS\textgreater{} (defclass A (is-a USER))

CLIPS\textgreater{} (make-instance a of A)

{[}a{]}

CLIPS\textgreater{}

(defmessage-handler A build-new ()

(build “(defmessage-handler A new ())”))

CLIPS\textgreater{} (send {[}a{]} build-new)

{[}MSGPSR3{]} System message-handlers may not be modified.

There are four primary message-handlers attached to the class USER which
cannot be modified: init, delete, create and print.

Example:

CLIPS\textgreater{} (defmessage-handler USER init ())

{[}MSGPSR4{]} Illegal slot reference in parameter list.

Direct slot references are allowed only within message-handler bodies.

Example:

CLIPS\textgreater{} (defmessage-handler USER foo (?self:bar))

{[}MSGPSR5{]} Active instance parameter cannot be changed.

?self is a reserved parameter for the active instance.

Example:

CLIPS\textgreater{}

(defmessage-handler USER foo ()

(bind ?self 1))

{[}MSGPSR6{]} No such slot \textless{}name\textgreater{} in class \textless{}name\textgreater{} for ?self reference.

The symbol following the ?self: reference must be a valid slot for the
class.

Example:

CLIPS\textgreater{} (defclass FOO (is-a USER) (role concrete) (slot x))

CLIPS\textgreater{} (defmessage-handler FOO bar () ?self:y)

{[}MSGPSR7{]} Illegal value for ?self reference.

The symbol following the ?self: reference must be a symbol.

Example:

CLIPS\textgreater{} (defclass FOO (is-a USER) (role concrete) (slot x))

CLIPS\textgreater{} (defmessage-handler FOO bar () ?self:7)

{[}MSGPSR8{]} Message-handlers cannot be attached to the class \textless{}name\textgreater{}.

Message-handlers cannot be attached to the INSTANCE, INSTANCE-ADDRESS,
or INSTANCE-NAME classes.

Example:

CLIPS\textgreater{} (defmessage-handler INSTANCE foo ())

{[}MULTIFUN1{]} Multifield index \textless{}index\textgreater{} out of range 1..\textless{}end range\textgreater{} in
function \textless{}name\textgreater{}

or

{[}MULTIFUN1{]} Multifield index range \textless{}start\textgreater{}…\textless{}end\textgreater{} out of range 1..\textless{}end
range\textgreater{} in function \textless{}name\textgreater{}

This error occurs when a multifield manipulation function is passed a
single index or range of indices that does not fall within the specified
range of allowed indices.

Example:

CLIPS\textgreater{} (delete\$ (create\$ a b c) 4 4)

{[}MULTIFUN2{]} Cannot rebind field variable in function progn\$.

The field variable (if specified) cannot be rebound within the body of
the progn\$ function.

Example:

CLIPS\textgreater{} (progn\$ (?field (create\$ a)) (bind ?field 3))

{[}OBJRTBLD1{]} No objects of existing classes can satisfy pattern.

No objects of existing classes could possibly satisfy the pattern. This
error usually occurs when a restriction placed on the is-a attribute is
incompatible with slot restrictions before it in the pattern.

Example:

CLIPS\textgreater{} (defclass A (is-a INITIAL-OBJECT) (slot foo))

CLIPS\textgreater{} (defrule error (object (foo ?) (is-a \textasciitilde{}A)) =\textgreater{})

{[}OBJRTBLD2{]} No objects of existing classes can satisfy \textless{}attribute-name\textgreater{}
restriction in object pattern.

The restrictions on \textless{}attribute\textgreater{} are such that no objects of existing
classes (which also satisfy preceding restrictions) could possibly
satisfy the pattern.

Example:

CLIPS\textgreater{} (defrule error (object (bad-slot ?)) =\textgreater{})

{[}OBJRTBLD3{]} No objects of existing classes can satisfy pattern
\#\textless{}pattern-num\textgreater{}.

No objects of existing classes could possibly satisfy the pattern. This
error occurs when the constraints for a slot as given in the
defclass(es) are incompatible with the constraints imposed by the
pattern.

Example:

CLIPS\textgreater{}

(defclass FOO (is-a INITIAL-OBJECT)

(slot bar (type INTEGER)))

CLIPS\textgreater{}

(defclass BAR (is-a INITIAL-OBJECT)

(slot bar (type SYMBOL))

(slot woz))

CLIPS\textgreater{}

(defrule error

(x abc)

(object (bar 100) (woz ?))

(y def)

=\textgreater{})

{[}OBJRTBLD4{]} Multiple restrictions on attribute \textless{}attribute-name\textgreater{} not
allowed.

Only one restriction per attribute is allowed per object pattern.

Example:

CLIPS\textgreater{} (defrule error (object (is-a ?) (is-a ?)) =\textgreater{})

{[}OBJRTBLD5{]} Undefined class in object pattern.

Object patterns are applicable only to classes of objects which are
already defined.

Example:

CLIPS\textgreater{} (defrule error (object (is-a BOGUS)) =\textgreater{})

{[}OBJRTMCH1{]} This error occurred in the object pattern network

Currently active instance: \textless{}instance-name\textgreater{}

Problem resides in slot \textless{}slot name\textgreater{} field \#\textless{}field-index\textgreater{}

Of pattern \#\textless{}pattern-number\textgreater{} in rule(s):

\textless{}problem-rules\textgreater{}+

This error pinpoints other evaluation errors associated with evaluating
an expression within the object pattern network. The specific pattern
and field of the problem rules are identified.

{[}PATTERN1{]} The symbol \textless{}symbol name\textgreater{} has special meaning and may not be
used as a \textless{}use name\textgreater{}.

Certain keywords have special meaning to CLIPS and may not be used in
situations that would cause an ambiguity.

Example:

CLIPS\textgreater{} (deftemplate exists (slot x))

{[}PATTERN2{]} Single and multifield constraints cannot be mixed in a field
constraint

Single and multifield variable constraints cannot be mixed in a field
constraint (this restriction does not include variables passed to
functions with the predicate or return value constraints).

Example:

CLIPS\textgreater{} (defrule foo (a ?x \$?y ?x\&\textasciitilde{}\$?y) =\textgreater{})

{[}PRCCODE1{]} Attempted to call a \textless{}construct\textgreater{} which does not exist.

In a CLIPS configuration without deffunctions and/or generic functions,
an attempt was made to call a deffunction or generic function from a
binary image generated by the \sphinxstylestrong{bsave} command.

{[}PRCCODE2{]} Functions without a return value are illegal as \textless{}construct\textgreater{}
arguments.

An evaluation error occurred while examining the arguments for a
deffunction, generic function or message.

Example:

CLIPS\textgreater{} (defmethod foo (?a))

CLIPS\textgreater{} (foo (instances))

{[}PRCCODE3{]} Undefined variable \textless{}name\textgreater{} referenced in \textless{}where\textgreater{}.

Local variables in the actions of a deffunction, method,
message-handler, or defrule must reference parameters, variables bound
within the actions with the \sphinxstylestrong{bind} function, or variables bound on the
LHS of a rule.

Example:

CLIPS\textgreater{} (defrule foo =\textgreater{} (+ ?a 3))

{[}PRCCODE4{]} Execution halted during the actions of \textless{}construct\textgreater{} \textless{}name\textgreater{}.

This error occurs when the actions of a rule, deffunction, generic
function method or message-handler are prematurely aborted due to an
error.

{[}PRCCODE5{]} Variable \textless{}name\textgreater{} unbound {[}in \textless{}construct\textgreater{} \textless{}name\textgreater{}{]}.

This error occurs when local variables in the actions of a deffunction,
method, message-handler, or defrule becomes unbound during execution as
a result of calling the \sphinxstylestrong{bind} function with no arguments.

Example:

CLIPS\textgreater{} (deffunction foo () (bind ?a) ?a)

CLIPS\textgreater{} (foo)

{[}PRCCODE6{]} This error occurred while evaluating arguments for the
\textless{}construct\textgreater{} \textless{}name\textgreater{}.

An evaluation error occurred while examining the arguments for a
deffunction, generic function method or message-handler.

Example:

CLIPS\textgreater{} (deffunction foo (?a))

CLIPS\textgreater{} (foo (+ (eval “(gensym)”) 2))

{[}PRCCODE7{]} Duplicate parameter names not allowed.

Deffunction, method or message-handler parameter names must be unique.

Example:

CLIPS\textgreater{} (defmethod foo ((?x INTEGER) (?x FLOAT)))

{[}PRCCODE8{]} No parameters allowed after wildcard parameter.

A wildcard parameter for a deffunction, method or message-handler must
be the last parameter.

Example:

CLIPS\textgreater{} (defmethod foo ((\$?x INTEGER) (?y SYMBOL)))

{[}PRCDRPSR1{]} Cannot rebind count variable in function loop-for-count.

The special variable ?count cannot be rebound within the body of the
loop-for-count function.

Example:

CLIPS\textgreater{} (loop-for-count (?count 10) (bind ?count 3))

{[}PRCDRPSR2{]} The return function is not valid in this context.

or

{[}PRCDRPSR2{]} The break function is not valid in this context.

The return and break functions can only be used within certain contexts
(e.g. the break function can only be used within a while loop and
certain instance set query functions).

Example:

CLIPS\textgreater{} (return 3)

{[}PRCDRPSR3{]} Duplicate case found in switch function.

A case may be specified only once in a switch statement.

Example:

CLIPS\textgreater{} (switch a (case a then 8) (case a then 9))

{[}PRNTUTIL1{]} Unable to find \textless{}item\textgreater{} \textless{}item-name\textgreater{}

This error occurs when CLIPS cannot find the named item (check for
typos).

{[}PRNTUTIL2{]} Syntax Error: Check appropriate syntax for \textless{}item\textgreater{}

This error occurs when the appropriate syntax is not used.

Example:

CLIPS\textgreater{} (if (\textgreater{} 3 4))

{[}PRNTUTIL3{]}

*** CLIPS SYSTEM ERROR ***

ID = \textless{}error-id\textgreater{}

CLIPS data structures are in an inconsistent or corrupted state.

This error may have occurred from errors in user defined code.

**************************

This error indicates an internal problem within CLIPS (which may have
been caused by user defined functions or other user code). If the
problem cannot be located within user defined code, then the \textless{}error-id\textgreater{}
should be reported.

{[}PRNTUTIL4{]} Unable to delete \textless{}item\textgreater{} \textless{}item-name\textgreater{}

This error occurs when CLIPS cannot delete the named item (e.g. a
construct might be in use). One example which will cause this error is
an attempt to delete a deffunction or generic function which is used in
another construct (such as the RHS of a defrule or a default-dynamic
facet of a defclass slot).

{[}PRNTUTIL5{]} The \textless{}item\textgreater{} has already been parsed.

This error occurs when CLIPS has already parsed an attribute or
declaration.

{[}PRNTUTIL6{]} Local variables cannot be accessed by \textless{}function or
construct\textgreater{}.

This error occurs when a local variable is used by a function or
construct that cannot use global variables.

Example:

CLIPS\textgreater{} (deffacts info (fact ?x))

{[}PRNTUTIL7{]} Attempt to divide by zero in \textless{}function-name\textgreater{} function.

This error occurs when a function attempts to divide by zero.

Example:

CLIPS\textgreater{} (/ 3 0)

{[}ROUTER1{]} Logical name \textless{}logical\_name\textgreater{} was not recognized by any routers

This error results because “Hello” is not recognized as a valid router
name.

Example:

CLIPS\textgreater{} (printout “Hello” crlf)

{[}RULECSTR1{]} Variable \textless{}variable name\textgreater{} in CE \#\textless{}integer\textgreater{} slot \textless{}slot name\textgreater{}

has constraint conflicts which make the pattern unmatchable.

or

{[}RULECSTR1{]} Variable \textless{}variable name\textgreater{} in CE \#\textless{}integer\textgreater{} field \#\textless{}integer\textgreater{}

has constraint conflicts which make the pattern unmatchable.

or

{[}RULECSTR1{]} CE \#\textless{}integer\textgreater{} slot \textless{}slot name\textgreater{}

has constraint conflicts which make the pattern unmatchable.

or

{[}RULECSTR1{]} CE \#\textless{}integer\textgreater{} field \#\textless{}integer\textgreater{}

has constraint conflicts which make the pattern unmatchable.

This error occurs when slot value constraints (such as allowed types)
prevents any value from matching the slot constraint for a pattern.

Example:

CLIPS\textgreater{} (deftemplate foo (slot x (type SYMBOL)))

CLIPS\textgreater{} (deftemplate bar (slot x (type FLOAT)))

CLIPS\textgreater{} (defrule yak (foo (x ?x)) (bar (x ?x)) =\textgreater{})

{[}RULECSTR2{]} Previous variable bindings of \textless{}variable name\textgreater{} caused the
type restrictions

for argument \#\textless{}integer\textgreater{} of the expression \textless{}expression\textgreater{}

found in CE\#\textless{}integer\textgreater{} slot \textless{}slot name\textgreater{} to be violated.

This error occurs when previous variable bindings and constraints
prevent a variable from containing a value which satisfies the type
constraints for one of a function?s parameters.

Example:

CLIPS\textgreater{} (deftemplate foo (slot x (type SYMBOL)))

CLIPS\textgreater{} (defrule bar (foo (x ?x\&:(\textgreater{} ?x 3))) =\textgreater{})

{[}RULECSTR3{]} Previous variable bindings of \textless{}variable name\textgreater{} caused the
type restrictions

for argument \#\textless{}integer\textgreater{} of the expression \textless{}expression\textgreater{}

found in the rule’s RHS to be violated.

This error occurs when previous variable bindings and constraints
prevent a variable from containing a value which satisfies the type
constraints for one of a function?s parameters.

Example:

CLIPS\textgreater{} (deftemplate foo (slot x (type SYMBOL)))

CLIPS\textgreater{} (defrule bar (foo (x ?x)) =\textgreater{} (printout t (+ ?x 1) crlf))

{[}RULELHS1{]} The logical CE cannot be used with a not/exists/forall CE.

Logical CEs can be placed outside, but not inside, a not/exists/forall
CE.

Example:

CLIPS\textgreater{} (defrule error (not (logical (x))) =\textgreater{})

{[}RULELHS2{]} A pattern CE cannot be bound to a pattern-address within a
not CE

This is an illegal operation and results in an error message.

Example:

CLIPS\textgreater{} (defrule error (not ?f \textless{}- (fact)) =\textgreater{})

{[}RULEPSR1{]} Logical CEs must be placed first in a rule

If logical CEs are used, then the first CE must be a logical CE.

Example:

CLIPS\textgreater{} (defrule error (a) (logical (b)) =\textgreater{})

{[}RULEPSR2{]} Gaps may not exist between logical CEs

Logical CEs found within a rule must be contiguous.

Example:

CLIPS\textgreater{} (defrule error (logical (a)) (b) (logical (c)) =\textgreater{})

{[}STRNGFUN1{]} Function build does not work in run time modules.

or

{[}STRNGFUN1{]} Function eval does not work in run time modules.

The build and eval functions do not work in run time modules because the
code required for parsing is not available.

{[}STRNGFUN2{]} Some variables could not be accessed by the eval function.

Local variables cannot be accessed by the eval function.

Example:

CLIPS\textgreater{} (eval “?x”)

{[}SYSDEP1{]} No file found for -f option

This message occurs if the -f option is used when executing CLIPS, but
no arguments are provided.

Example:

clips -f

{[}TEXTPRO1{]} Could not open file \textless{}file-name\textgreater{}.

This error occurs when the external text-processing system command
\sphinxstylestrong{fetch} encounters an error when loading a file.

Example:

CLIPS\textgreater{} (fetch ?bogus.txt?E

{[}TMPLTDEF1{]} Invalid slot \textless{}slot name\textgreater{} not defined in corresponding
deftemplate \textless{}deftemplate name\textgreater{}

The slot name supplied does not correspond to a slot name defined in the
corre?sponding deftemplate

Example:

CLIPS\textgreater{} (deftemplate example (slot x))

CLIPS\textgreater{} (defrule error (example (z 3)) =\textgreater{})

{[}TMPLTDEF2{]} The single field slot \textless{}slot name\textgreater{} can only contain a single
field value.

If a slot definition is specified in a template pattern or fact, the
contents of the slot must be capable of matching against or evaluating
to a single value.

Example:

CLIPS\textgreater{} (deftemplate example (slot x))

CLIPS\textgreater{} (assert (example (x)))

{[}TMPLTFUN1{]} Fact-indexes can only be used by \textless{}command name\textgreater{} as a top
level command.

Fact indexes may only be used with the modify and duplicate commands
when the command is issued from the top-level command prompt.

Example:

CLIPS\textgreater{} (defrule foo =\textgreater{} (modify 1 (x 3))

{[}TMPLTFUN2{]} Attempted to assert a multifield value into the single field
slot \textless{}slot name\textgreater{} of deftemplate \textless{}deftemplate name\textgreater{}.

A multifield value cannot be stored in a single field slot.

Example:

CLIPS\textgreater{} (deftemplate foo (slot x))

CLIPS\textgreater{}

(defrule foo

=\textgreater{}

(bind ?x (create\$ a b))

(assert (foo (x ?x))))

CLIPS\textgreater{} (reset)

CLIPS\textgreater{} (run)

{[}TMPLTRHS1{]} Slot \textless{}slot name\textgreater{} requires a value because of its (default
?NONE) attribute.

The (default ?NONE) attribute requires that a slot value be supplied
whenever a new fact is created.

Example:

CLIPS\textgreater{} (deftemplate foo (slot x (default ?NONE)))

CLIPS\textgreater{} (assert (foo))

Appendix G:
CLIPS BNF
===========

Data Types

\textless{}symbol\textgreater{} ::= \sphinxstylestrong{A valid symbol as specified}

\sphinxstylestrong{in section 2.3.1}

\textless{}string\textgreater{} ::= \sphinxstylestrong{A valid string as specified}

\sphinxstylestrong{in section 2.3.1}

\textless{}float\textgreater{} ::= \sphinxstylestrong{A valid float as specified}

\sphinxstylestrong{in section 2.3.1}

\textless{}integer\textgreater{} ::= \sphinxstylestrong{A valid integer as specified}

\sphinxstylestrong{in section 2.3.1}

\textless{}instance-name\textgreater{} ::= \sphinxstylestrong{A valid instance-name as specified}

\sphinxstylestrong{in section 2.3.1}

\textless{}number\textgreater{} ::= \textless{}float\textgreater{} \textbar{} \textless{}integer\textgreater{}

\textless{}lexeme\textgreater{} ::= \textless{}symbol\textgreater{} \textbar{} \textless{}string\textgreater{}

\textless{}constant\textgreater{} ::= \textless{}symbol\textgreater{} \textbar{} \textless{}string\textgreater{} \textbar{} \textless{}integer\textgreater{} \textbar{}

\textless{}float\textgreater{} \textbar{} \textless{}instance-name\textgreater{}

\textless{}comment\textgreater{} ::= \textless{}string\textgreater{}

\textless{}variable-symbol\textgreater{} ::= \sphinxstylestrong{A symbol beginning with an}

\sphinxstylestrong{alphabetic character}

\textless{}function-name\textgreater{} ::= \sphinxstylestrong{Any symbol which corresponds to a}

\sphinxstylestrong{system or user defined function, a}

\sphinxstylestrong{deffunction name, or a defgeneric}

\sphinxstylestrong{name}

\textless{}file-name\textgreater{} ::= \sphinxstylestrong{A symbol or string which is a valid}

\sphinxstylestrong{file name (including path}

\sphinxstylestrong{information) for the operating}

\sphinxstylestrong{system under which CLIPS is running}

\textless{}slot-name\textgreater{} ::= \sphinxstylestrong{A valid deftemplate slot name}

\textless{}…-name\textgreater{} ::= \sphinxstylestrong{A \textless{}symbol\textgreater{} where the ellipsis}

\sphinxstylestrong{indicate what the symbol represents.}

\sphinxstylestrong{For example, \textless{}rule-name\textgreater{} is a symbol}

\sphinxstylestrong{which represents the name of a rule.}

Variables and Expressions

\textless{}single-field-variable\textgreater{} ::= ?\textless{}variable-symbol\textgreater{}

\textless{}multifield-variable\textgreater{} ::= \$?\textless{}variable-symbol\textgreater{}

\textless{}global-variable\textgreater{} ::= ?*\textless{}symbol\textgreater{}*

\textless{}variable\textgreater{} ::= \textless{}single-field-variable\textgreater{} \textbar{}

\textless{}multifield-variable\textgreater{} \textbar{}

\textless{}global-variable\textgreater{}

\textless{}function-call\textgreater{} ::= (\textless{}function-name\textgreater{} \textless{}expression\textgreater{}*)

\textless{}expression\textgreater{} ::= \textless{}constant\textgreater{} \textbar{} \textless{}variable\textgreater{} \textbar{}

\textless{}function-call\textgreater{}

\textless{}action\textgreater{} ::= \textless{}expression\textgreater{}

\textless{}…-expression\textgreater{} ::= \sphinxstylestrong{An \textless{}expression\textgreater{} which returns}

\sphinxstylestrong{the type indicated by the}

\sphinxstylestrong{ellipsis. For example,}

\sphinxstylestrong{\textless{}integer-expression\textgreater{} should}

\sphinxstylestrong{return an integer.}

Constructs

\textless{}CLIPS-program\textgreater{} ::= \textless{}construct\textgreater{}*

\textless{}construct\textgreater{} ::= \textless{}deffacts-construct\textgreater{} \textbar{}

\textless{}deftemplate-construct\textgreater{} \textbar{}

\textless{}defglobal-construct\textgreater{} \textbar{}

\textless{}defrule-construct\textgreater{} \textbar{}

\textless{}deffunction-construct\textgreater{} \textbar{}

\textless{}defgeneric-construct\textgreater{} \textbar{}

\textless{}defmethod-construct\textgreater{} \textbar{}

\textless{}defclass-construct\textgreater{} \textbar{}

\textless{}definstance-construct\textgreater{} \textbar{}

\textless{}defmessage-handler-construct\textgreater{} \textbar{}

\textless{}defmodule-construct\textgreater{}

Deffacts Construct

\begin{DUlineblock}{0em}
\item[] \textless{}deffacts-construct\textgreater{} ::= (deffacts \textless{}deffacts-name\textgreater{} {[}\textless{}comment\textgreater{}{]}
\item[] \textless{}RHS-pattern\textgreater{}*)
\end{DUlineblock}

Deftemplate Construct

\textless{}deftemplate-construct\textgreater{}

::= (deftemplate \textless{}deftemplate-name\textgreater{}

{[}\textless{}comment\textgreater{}{]}

\textless{}slot-definition\textgreater{}*)

\textless{}slot-definition\textgreater{} ::= \textless{}single-slot-definition\textgreater{} \textbar{}

\textless{}multislot-definition\textgreater{}

\textless{}single-slot-definition\textgreater{}

::= (slot \textless{}slot-name\textgreater{} \textless{}template-attribute\textgreater{}*)

\textless{}multislot-definition\textgreater{}

::= (multislot \textless{}slot-name\textgreater{}

\textless{}template-attribute\textgreater{}*)

\textless{}template-attribute\textgreater{}

::= \textless{}default-attribute\textgreater{} \textbar{}

\textless{}constraint-attribute\textgreater{}

\textless{}default-attribute\textgreater{}

::= (default ?DERIVE \textbar{} ?NONE \textbar{} \textless{}expression\textgreater{}*) \textbar{}

(default-dynamic \textless{}expression\textgreater{}*)

Fact Specification

\textless{}RHS-pattern\textgreater{} ::= \textless{}ordered-RHS-pattern\textgreater{} \textbar{}

\textless{}template-RHS-pattern\textgreater{}

\textless{}ordered-RHS-pattern\textgreater{} ::= (\textless{}symbol\textgreater{} \textless{}RHS-field\textgreater{}+)

\textless{}template-RHS-pattern\textgreater{} ::= (\textless{}deftemplate-name\textgreater{} \textless{}RHS-slot\textgreater{}*)

\textless{}RHS-slot\textgreater{} ::= \textless{}single-field-RHS-slot\textgreater{} \textbar{}

\textless{}multifield-RHS-slot\textgreater{}

\textless{}single-field-RHS-slot\textgreater{} ::= (\textless{}slot-name\textgreater{} \textless{}RHS-field\textgreater{})

\textless{}multifield-RHS-slot\textgreater{} ::= (\textless{}slot-name\textgreater{} \textless{}RHS-field\textgreater{}*)

\textless{}RHS-field\textgreater{} ::= \textless{}variable\textgreater{} \textbar{}

\textless{}constant\textgreater{} \textbar{}

\textless{}function-call\textgreater{}

Defrule Construct

\textless{}defrule-construct\textgreater{} ::= (defrule \textless{}rule-name\textgreater{} {[}\textless{}comment\textgreater{}{]}

{[}\textless{}declaration\textgreater{}{]}

\begin{DUlineblock}{0em}
\item[] \textless{}conditional-element\textgreater{}*
\item[] =\textgreater{}
\item[] \textless{}action\textgreater{}*)
\end{DUlineblock}

\textless{}declaration\textgreater{} ::= (declare \textless{}rule-property\textgreater{}+)

\textless{}rule-property\textgreater{} ::= (salience \textless{}integer-expression\textgreater{}) \textbar{}

(auto-focus \textless{}boolean-symbol\textgreater{})

\textless{}boolean-symbol\textgreater{} ::= TRUE \textbar{} FALSE

\textless{}conditional-element\textgreater{} ::= \textless{}pattern-CE\textgreater{} \textbar{}

\textless{}assigned-pattern-CE\textgreater{} \textbar{}

\textless{}not-CE\textgreater{} \textbar{} \textless{}and-CE\textgreater{} \textbar{} \textless{}or-CE\textgreater{} \textbar{}

\textless{}logical-CE\textgreater{} \textbar{} \textless{}test-CE\textgreater{} \textbar{}

\textless{}exists-CE\textgreater{} \textbar{} \textless{}forall-CE\textgreater{}

\textless{}pattern-CE\textgreater{} ::= \textless{}ordered-pattern-CE\textgreater{} \textbar{}

\textless{}template-pattern-CE\textgreater{} \textbar{}

\textless{}object-pattern-CE\textgreater{}

\textless{}assigned-pattern-CE\textgreater{} ::= \textless{}single-field-variable\textgreater{} \textless{}- \textless{}pattern-CE\textgreater{}

\textless{}not-CE\textgreater{} ::= (not \textless{}conditional-element\textgreater{})

\textless{}and-CE\textgreater{} ::= (and \textless{}conditional-element\textgreater{}+)

\textless{}or-CE\textgreater{} ::= (or \textless{}conditional-element\textgreater{}+)

\textless{}logical-CE\textgreater{} ::= (logical \textless{}conditional-element\textgreater{}+)

\textless{}test-CE\textgreater{} ::= (test \textless{}function-call\textgreater{})

\textless{}exists-CE\textgreater{} ::= (exists \textless{}conditional-element\textgreater{}+)

\textless{}forall-CE\textgreater{} ::= (forall \textless{}conditional-element\textgreater{}

\textless{}conditional-element\textgreater{}+)

\textless{}ordered-pattern-CE\textgreater{} ::= (\textless{}symbol\textgreater{} \textless{}constraint\textgreater{}*)

\textless{}template-pattern-CE\textgreater{} ::= (\textless{}deftemplate-name\textgreater{} \textless{}LHS-slot\textgreater{}*)

\textless{}object-pattern-CE\textgreater{} ::= (object \textless{}attribute-constraint\textgreater{}*)

\textless{}attribute-constraint\textgreater{} ::= (is-a \textless{}constraint\textgreater{}) \textbar{}

(name \textless{}constraint\textgreater{}) \textbar{}

(\textless{}slot-name\textgreater{} \textless{}constraint\textgreater{}*)

\textless{}LHS-slot\textgreater{} ::= \textless{}single-field-LHS-slot\textgreater{} \textbar{}

\textless{}multifield-LHS-slot\textgreater{}

\textless{}single-field-LHS-slot\textgreater{} ::= (\textless{}slot-name\textgreater{} \textless{}constraint\textgreater{})

\textless{}multifield-LHS-slot\textgreater{} ::= (\textless{}slot-name\textgreater{} \textless{}constraint\textgreater{}*)

\textless{}constraint\textgreater{} ::= ? \textbar{} \$? \textbar{} \textless{}connected-constraint\textgreater{}

\textless{}connected-constraint\textgreater{}

::= \textless{}single-constraint\textgreater{} \textbar{}

\textless{}single-constraint\textgreater{} \sphinxstylestrong{\&} \textless{}connected-constraint\textgreater{} \textbar{}

\textless{}single-constraint\textgreater{} \sphinxstylestrong{\textbar{}} \textless{}connected-constraint\textgreater{}

\textless{}single-constraint\textgreater{} ::= \textless{}term\textgreater{} \textbar{} \textasciitilde{}\textless{}term\textgreater{}

\textless{}term\textgreater{} ::= \textless{}constant\textgreater{} \textbar{}

\textless{}single-field-variable\textgreater{} \textbar{}

\textless{}multifield-variable\textgreater{} \textbar{}

:\textless{}function-call\textgreater{} \textbar{}

=\textless{}function-call\textgreater{}

Defglobal Construct

\textless{}defglobal-construct\textgreater{} ::= (defglobal {[}\textless{}defmodule-name\textgreater{}{]}

\textless{}global-assignment\textgreater{}*)

\textless{}global-assignment\textgreater{} ::= \textless{}global-variable\textgreater{} = \textless{}expression\textgreater{}

\textless{}global-variable\textgreater{} ::= ?*\textless{}symbol\textgreater{}*

Deffunction Construct

\textless{}deffunction-construct\textgreater{}

::= (deffunction \textless{}name\textgreater{} {[}\textless{}comment\textgreater{}{]}

(\textless{}regular-parameter\textgreater{}* {[}\textless{}wildcard-parameter\textgreater{}{]})

\textless{}action\textgreater{}*)

\textless{}regular-parameter\textgreater{} ::= \textless{}single-field-variable\textgreater{}

\textless{}wildcard-parameter\textgreater{} ::= \textless{}multifield-variable\textgreater{}

Defgeneric Construct

\textless{}defgeneric-construct\textgreater{} ::= (defgeneric \textless{}name\textgreater{} {[}\textless{}comment\textgreater{}{]})

Defmethod Construct

\textless{}defmethod-construct\textgreater{}

::= (defmethod \textless{}name\textgreater{} {[}\textless{}index\textgreater{}{]} {[}\textless{}comment\textgreater{}{]}

(\textless{}parameter-restriction\textgreater{}*

{[}\textless{}wildcard-parameter-restriction\textgreater{}{]})

\textless{}action\textgreater{}*)

\textless{}parameter-restriction\textgreater{}

::= \textless{}single-field-variable\textgreater{} \textbar{}

(\textless{}single-field-variable\textgreater{} \textless{}type\textgreater{}* {[}\textless{}query\textgreater{}{]})

\textless{}wildcard-parameter-restriction\textgreater{}

::= \textless{}multifield-variable\textgreater{} \textbar{}

(\textless{}multifield-variable\textgreater{} \textless{}type\textgreater{}* {[}\textless{}query\textgreater{}{]})

\textless{}type\textgreater{} ::= \textless{}class-name\textgreater{}

\textless{}query\textgreater{} ::= \textless{}global-variable\textgreater{} \textbar{} \textless{}function-call\textgreater{}

Defclass Construct

\textless{}defclass-construct\textgreater{} ::= (defclass \textless{}name\textgreater{} {[}\textless{}comment\textgreater{}{]}

(is-a \textless{}superclass-name\textgreater{}+)

{[}\textless{}role\textgreater{}{]}

{[}\textless{}pattern-match-role\textgreater{}{]}

\textless{}slot\textgreater{}*

\textless{}handler-documentation\textgreater{}*)

\textless{}role\textgreater{} ::= (role concrete \textbar{} abstract)

\textless{}pattern-match-role\textgreater{}

::= (pattern-match reactive \textbar{} non-reactive)

\textless{}slot\textgreater{} ::= (slot \textless{}name\textgreater{} \textless{}facet\textgreater{}*) \textbar{}

(single-slot \textless{}name\textgreater{} \textless{}facet\textgreater{}*) \textbar{}

(multislot \textless{}name\textgreater{} \textless{}facet\textgreater{}*)

\textless{}facet\textgreater{} ::= \textless{}default-facet\textgreater{} \textbar{} \textless{}storage-facet\textgreater{} \textbar{}

\textless{}access-facet\textgreater{} \textbar{} \textless{}propagation-facet\textgreater{} \textbar{}

\textless{}source-facet\textgreater{} \textbar{} \textless{}pattern-match-facet\textgreater{} \textbar{}

\textless{}visibility-facet\textgreater{} \textbar{} \textless{}create-accessor-facet\textgreater{}

\textless{}override-message-facet\textgreater{} \textbar{} \textless{}constraint-attribute\textgreater{}

\textless{}default-facet\textgreater{} ::=

(default ?DERIVE \textbar{} ?NONE \textbar{} \textless{}expression\textgreater{}*) \textbar{}

(default-dynamic \textless{}expression\textgreater{}*)

\textless{}storage-facet\textgreater{} ::= (storage local \textbar{} shared)

\textless{}access-facet\textgreater{}

::= (access read-write \textbar{} read-only \textbar{} initialize-only)

\textless{}propagation-facet\textgreater{} ::= (propagation inherit \textbar{} no-inherit)

\textless{}source-facet\textgreater{} ::= (source exclusive \textbar{} composite)

\textless{}pattern-match-facet\textgreater{}

::= (pattern-match reactive \textbar{} non-reactive)

\textless{}visibility-facet\textgreater{} ::= (visibility private \textbar{} public)

\textless{}create-accessor-facet\textgreater{}

::= (create-accessor ?NONE \textbar{} read \textbar{} write \textbar{} read-write)

\textless{}override-message-facet\textgreater{}

::= (override-message ?DEFAULT \textbar{} \textless{}message-name\textgreater{})

\textless{}handler-documentation\textgreater{}

::= (message-handler \textless{}name\textgreater{} {[}\textless{}handler-type\textgreater{}{]})

\textless{}handler-type\textgreater{} ::= primary \textbar{} around \textbar{} before \textbar{} after

Defmessage-handler Construct

\textless{}defmessage-handler-construct\textgreater{}

::= (defmessage-handler \textless{}class-name\textgreater{}

\textless{}message-name\textgreater{} {[}\textless{}handler-type\textgreater{}{]} {[}\textless{}comment\textgreater{}{]}

(\textless{}parameter\textgreater{}* {[}\textless{}wildcard-parameter\textgreater{}{]})

\textless{}action\textgreater{}*)

\textless{}handler-type\textgreater{} ::= around \textbar{} before \textbar{} primary \textbar{} after

\textless{}parameter\textgreater{} ::= \textless{}single-field-variable\textgreater{}

\textless{}wildcard-parameter\textgreater{} ::= \textless{}multifield-variable\textgreater{}

Definstances Construct

\textless{}definstances-construct\textgreater{}

::= (definstances \textless{}definstances-name\textgreater{}

{[}active{]} {[}\textless{}comment\textgreater{}{]}

\textless{}instance-template\textgreater{}*)

\textless{}instance-template\textgreater{} ::= (\textless{}instance-definition\textgreater{})

\begin{DUlineblock}{0em}
\item[] \textless{}instance-definition\textgreater{} ::= \textless{}instance-name-expression\textgreater{} of
\item[] \textless{}class-name-expression\textgreater{}
\item[] \textless{}slot-override\textgreater{}*
\end{DUlineblock}

\textless{}slot-override\textgreater{} ::= (\textless{}slot-name-expression\textgreater{} \textless{}expression\textgreater{}*)

Defmodule Construct

\textless{}defmodule-construct\textgreater{} ::= (defmodule \textless{}module-name\textgreater{} {[}\textless{}comment\textgreater{}{]}

\textless{}port-specification\textgreater{}*)

\textless{}port-specification\textgreater{} ::= (export \textless{}port-item\textgreater{}) \textbar{}

(import \textless{}module-name\textgreater{} \textless{}port-item\textgreater{})

\textless{}port-item\textgreater{} ::= ?ALL \textbar{}

?NONE \textbar{}

\textless{}port-construct\textgreater{} ?ALL \textbar{}

\textless{}port-construct\textgreater{} ?NONE \textbar{}

\textless{}port-construct\textgreater{} \textless{}construct-name\textgreater{}+

\textless{}port-construct\textgreater{} ::= deftemplate \textbar{} defclass \textbar{}

defglobal \textbar{} deffunction \textbar{}

defgeneric

Constraint Attributes

\textless{}constraint-attribute\textgreater{}

::= \textless{}type-attribute\textgreater{}?\textbar{}

\textless{}allowed-constant-attribute\textgreater{} \textbar{}

\textless{}range-attribute\textgreater{} \textbar{}

\textless{}cardinality-attribute\textgreater{}

\textless{}type-attribute\textgreater{} ::= (type \textless{}type-specification\textgreater{})

\textless{}type-specification\textgreater{} ::= \textless{}allowed-type\textgreater{}+ \textbar{} ?VARIABLE

\textless{}allowed-type\textgreater{} ::= SYMBOL \textbar{} STRING \textbar{} LEXEME \textbar{}

INTEGER \textbar{} FLOAT \textbar{} NUMBER \textbar{}

INSTANCE-NAME \textbar{} INSTANCE-ADDRESS \textbar{}

INSTANCE \textbar{} EXTERNAL-ADDRESS \textbar{}

FACT-ADDRESS

\textless{}allowed-constant-attribute\textgreater{}

::= (allowed-symbols?\textless{}symbol-list\textgreater{}) \textbar{}

(allowed-strings \textless{}string-list\textgreater{}) \textbar{}

(allowed-lexemes \textless{}lexeme-list\textgreater{} \textbar{}

(allowed-integers?\textless{}integer-list\textgreater{}) \textbar{}

(allowed-floats?\textless{}float-list\textgreater{}) \textbar{}

(allowed-numbers?\textless{}number-list\textgreater{}) \textbar{}

(allowed-instance-names \textless{}instance-list\textgreater{}) \textbar{}

(allowed-classes \textless{}class-name-list\textgreater{}) \textbar{}

(allowed-values?\textless{}value-list\textgreater{})

\textless{}symbol-list\textgreater{} ::= \textless{}symbol\textgreater{}+ \textbar{} ?VARIABLE

\textless{}string-list\textgreater{} ::= \textless{}string\textgreater{}+ \textbar{} ?VARIABLE

\textless{}lexeme-list\textgreater{} ::= \textless{}lexeme\textgreater{}+ \textbar{} ?VARIABLE

\textless{}integer-list\textgreater{} ::= \textless{}integer\textgreater{}+ \textbar{} ?VARIABLE

\textless{}float-list\textgreater{} ::= \textless{}float\textgreater{}+ \textbar{} ?VARIABLE

\textless{}number-list\textgreater{} ::= \textless{}number\textgreater{}+ \textbar{} ?VARIABLE

\textless{}instance-name-list\textgreater{} ::= \textless{}instance-name\textgreater{}+ \textbar{} ?VARIABLE

\textless{}class-name-list\textgreater{} ::= \textless{}class-name\textgreater{}+ \textbar{} ?VARIABLE

\textless{}value-list\textgreater{} ::= \textless{}constant\textgreater{}+ \textbar{} ?VARIABLE

\textless{}range-attribute\textgreater{} ::= (range \textless{}range-specification\textgreater{}

\textless{}range-specification\textgreater{})

\textless{}range-specification\textgreater{} ::= \textless{}number\textgreater{} \textbar{} ?VARIABLE

\textless{}cardinality-attribute\textgreater{}

::= (cardinality \textless{}cardinality-specification\textgreater{}

\textless{}cardinality-specification\textgreater{})

\textless{}cardinality-specification\textgreater{}

::= \textless{}integer\textgreater{} \textbar{} ?VARIABLE

Appendix H:
Reserved Function Names
=======================

This appendix lists all of the functions provided by either standard
CLIPS or various CLIPS extensions. They should be considered reserved
function names, and users should not create user-defined functions with
any of these names.

!=

*

**
\begin{itemize}
\item {} 
\end{itemize}
\begin{itemize}
\item {} 
\end{itemize}

/

\textless{}

\textless{}=

\textless{}\textgreater{}

=

\textgreater{}

\textgreater{}=

abs

acos

acosh

acot

acoth

acsc

acsch

active-duplicate-instance

active-initialize-instance

active-make-instance

active-message-duplicate-instance

active-message-modify-instance

active-modify-instance

agenda

and

any-instancep

apropos

asec

asech

asin

asinh

assert

assert-string

atan

atanh

batch

batch*

bind

bload

bload-instances

break

browse-classes

bsave

bsave-instances

build

call-next-handler

call-next-method

call-specific-method

class

class-abstractp

class-existp

class-reactivep

class-slots

class-subclasses

class-superclasses

clear

clear-focus-stack

close

conserve-mem

constructs-to-c

cos

cosh

cot

coth

create\$

csc

csch

defclass-module

deffacts-module

deffunction-module

defgeneric-module

defglobal-module

definstances-module

defrule-module

deftemplate-module

deg-grad

deg-rad

delayed-do-for-all-instances

delete\$

delete-instance

dependencies

dependents

describe-class

direct-mv-delete

direct-mv-insert

direct-mv-replace

div

do-for-all-instances

do-for-instance

dribble-off

dribble-on

duplicate

duplicate-instance

duplicate-instance

dynamic-get

dynamic-put

edit

eq

eval

evenp

exit

exp

expand\$

explode\$

fact-existp

fact-index

fact-relation

fact-slot-names

fact-slot-value

facts

fetch

find-all-instances

find-instance

first\$

float

floatp

focus

format

gensym

gensym*

get

get-auto-float-dividend

get-current-module

get-defclass-list

get-deffacts-list

get-deffunction-list

get-defgeneric-list

get-defglobal-list

get-definstances-list

get-defmessage-handler-list

get-defmethod-list

get-defmodule-list

get-defrule-list

get-deftemplate-list

get-dynamic-constraint-checking

get-fact-duplication

get-fact-list

get-focus

get-focus-stack

get-function-restrictions

get-incremental-reset

get-method-restrictions

get-reset-globals

get-salience-evaluation

get-sequence-operator-recognition

get-static-constraint-checking

get-strategy

grad-deg

halt

if

implode\$

init-slots

initialize-instance

initialize-instance

insert\$

instance-address

instance-addressp

instance-existp

instance-name

instance-name-to-symbol

instance-namep

instancep

instances

integer

integerp

length

length\$

lexemep

list-defclasses

list-deffacts

list-deffunctions

list-defgenerics

list-defglobals

list-definstances

list-defmessage-handlers

list-defmethods

list-defmodules

list-defrules

list-deftemplates

list-focus-stack

list-watch-items

load

load*

load-facts

load-instances

log

log10

loop-for-count

lowcase

make-instance

make-instance

matches

max

mem-requests

mem-used

member

member\$

message-duplicate-instance

message-duplicate-instance

message-handler-existp

message-modify-instance

message-modify-instance

min

mod

modify

modify-instance

modify-instance

multifieldp

mv-append

mv-delete

mv-replace

mv-slot-delete

mv-slot-insert

mv-slot-replace

mv-subseq

neq

next-handlerp

next-methodp

not

nth

nth\$

numberp

object-pattern-match-delay

oddp

open

options

or

override-next-handler

override-next-method

pi

pointerp

pop-focus

ppdefclass

ppdeffacts

ppdeffunction

ppdefgeneric

ppdefglobal

ppdefinstances

ppdefmessage-handler

ppdefmethod

ppdefmodule

ppdefrule

ppdeftemplate

ppinstance

preview-generic

preview-send

primitives-info

print-region

printout

progn

progn\$

put

rad-deg

random

read

readline

refresh

refresh-agenda

release-mem

remove

remove-break

rename

replace\$

reset

rest\$

restore-instances

retract

return

round

rule-complexity

rules

run

save

save-facts

save-instances

sec

sech

seed

send

sequencep

set-auto-float-dividend

set-break

set-current-module

set-dynamic-constraint-checking

set-fact-duplication

set-incremental-reset

set-reset-globals

set-salience-evaluation

set-sequence-operator-recognition

set-static-constraint-checking

set-strategy

setgen

show-breaks

show-defglobals

show-fht

show-fpn

show-joins

show-opn

sin

sinh

slot-allowed-values

slot-cardinality

slot-delete\$

slot-direct-accessp

slot-direct-delete\$

slot-direct-insert\$

slot-direct-replace\$

slot-existp

slot-facets

slot-initablep

slot-insert\$

slot-publicp

slot-range

slot-replace\$

slot-sources

slot-types

slot-writablep

sqrt

str-assert

str-cat

str-compare

str-explode

str-implode

str-index

str-length

stringp

sub-string

subclassp

subseq\$

subset

subsetp

superclassp

switch

sym-cat

symbol-to-instance-name

symbolp

system

tan

tanh

time

toss

type

type

undefclass

undeffacts

undeffunction

undefgeneric

undefglobal

undefinstances

undefmessage-handler

undefmethod

undefrule

undeftemplate

unmake-instance

unwatch

upcase

watch

while

wordp

Appendix I:
Bibliography of CLIPS Publications
==================================

Programming

Giarratano, J., and Riley, G. \sphinxstyleemphasis{Expert Systems: Principles and
Programming}, 3rd Edition, Boston, PWS Publishing Company, 1998.

Gonzalez, A. J., and Dankel, D. D. \sphinxstyleemphasis{Engineering of
Knowledge-basedSystems: Theory and Practice}, Prentice Hall, 1993.

Jackson, P. \sphinxstyleemphasis{Introduction to Expert Systems}, 3rd Edition, Reading,
Addison-Wesley, 1998.

Reviews

Brooke, T. ?The Art of Production Systems,?E*AI Expert*, January 1992.

Brooke, T. ?Software Review,?E*AI Expert*, April 1988.

Golden, J. ?Shell Review Monthly,?E*AI Today*, March/April 1988.

Mettrey, W. ?A Comparative Evaluation of Expert System Tools,?E
\sphinxstyleemphasis{Computer}, February 1991.

Popolizio, J. ?CLIPS: NASA?s COSMIC Shell,?E*Artificial Intelligence
Research*, August 1, 1988.

Raeth, P. ?Two PC?based Expert System Shells for the First?time
Developer,?E*Computer*, November 1988.

Overviews

Culbert, C., et al., ?A Solution to the Expert System Delivery Problem,?E
\sphinxstyleemphasis{Proceedings of the ISA/88}, Houston, TX, October 1988.

Riley, G. ?C Language Integrated Production System,?Ein \sphinxstyleemphasis{Encyclopedia of
Computer Science and Technology}, Volume 37. Edited by A. Kent and J.G.
Williams. New York, Marcel Dekker, Inc., 1997.

Riley, G. ?Expert Systems Methodology,?Ein \sphinxstyleemphasis{The Industrial Electronics
Handbook}. Edited by J.D. Irwin. Boca Raton, CRC Press, 1997.

Riley, G. ?CLIPS: An Expert System Building Tool,?E*Proceedings of the
Technology 2001 Conference*, San Jose, CA, December 1991.

Riley, G. ?CLIPS: A Tool for the Development and Delivery of Expert
Systems,?E*Proceedings of the Technology 2000 Conference*, Washington,
DC, November 1990.

Riley G., and Donnell, B. ?Advanced CLIPS Capabilities,?E*Proceedings of
The Fourth Annual Workshop on Space Operations Applications and Research
(SOAR ?E0)*, Albuquerque, NM, June 1990.

Riley, G., et al. ?CLIPS: An Expert System Tool for Training,
Development, and Delivery,?Ein \sphinxstyleemphasis{Intelligent Systems Review}, Volume 1,
Number 1, Fall 1988.

Riley, G., et al., ?CLIPS: An Expert System Tool for Delivery and
Training,?E*Proceedings of the Third Conference on Artificial
Intelligence for Space Applications*, Huntsville, AL, November 1987.

Applications

Carreno, L. A. and Steel, R. A. ?Life Insurance Risk Assessment using a
Fuzzy Logic Expert System,?E*Proceedings of the North American Fuzzy
Logic Processing Society (NAFIPS 1992)*, Houston, TX, December 1992.

Cheatham, J. B., et al. ?A Multi?Sensor System for Robotics Proximity
Operations,?E*Proceedings of The Second Annual Workshop on Space
Operations Automation and Robotics (SOAR ?E8)*, Albuquerque, NM, July
1988.

Chen, Y. ?Applying Knowledge?Based Expert System to Meat Grading,?E
\sphinxstyleemphasis{Proceedings of The Annual AI Systems in Government Conference},
Washington, D.C., March 1989.

?CLIPS: A NASA Developed Expert System Tool,?E*NASA Tech Briefs*,
November/December 1987.

Dutton, T. ?HUB SIAASHING: A Knowledge?Based System for Severe,
Temporary Airline Schedule Reduction,?E*Innovative Applications of
Artificial Intelligence 4*, Klahr, Philip, and Scott, A. Carlisle ed.,
1992.

Ehler, G. B. ?A Multiple Knowledge-Based Spatial Decision Support System
for Industrial Site Selection,?EM.S. Thesis, Department of Geography,
University of South Carolina, Columbia, SC.

Fink, P., and Herren, L. T. ?An Intelligent Tutoring System to Teach
Interdependent Cognitive and High Performance Skills,?E*Proceedings of
Contributed Sessions 1991 Conference on Intelligent Computer Aided
Training*, Houston, TX, November 1991.

Fink, P. ?NESSUS/EXPERT: Bridging the Gap between Artificial
Intelligence and FORTRAN,?E*Proceedings of The Second Annual Workshop on
Space Operations Automation and Robotics (SOAR ?E8)*, Albuquerque, NM,
July 1988.

Flamm, R. O., et al. ?The Integrated Southern Pine Beetle Expert System:
ISPBEX,?E*Expert Systems with Applications*, Vol. 2, 1991.

Franier, R., et al. ?PI?in?a?Box: A Knowledge?based System for Space
Science Experimentation,?E*Proceedings of the Fifth Innovative
Applications of Artificial Intelligence Conference*, July 11?E5, 1993,
Washington, D.C.

Frainier, R., et al. ?PI-in-a-Box: A Knowledge-Based System for Space
Science Experimentation,?E*AI magazine*, Volume 15, No. 1, Spring, 1994.

Frainier, R., et al. ?PI in the Sky: The Astronaut Science Advisor on
SLS-2,?E*Proceedings of The Seventh Annual Workshop on Space Operations
Applications and Research (SOAR ?E3)*, Houston, TX, August 1993.

Germain, D., and Desrosiers, S. ?Turning Up the Heat on Space Station
Training: The Active Thermal Control System ICAT,?E*Proceedings of
Contributed Sessions 1991 Conference on Intelligent Computer Aided
Training*, Houston, TX, November 1991.

Grinstein, G. G., et al. ?Virtual Environment Architecture for Rapid
Application Development,?E*Proceedings of The Contributed Sessions 1993
Conference on Intelligent Computer Aided Training and Virtual
Environment Technology* (ICAT-VET ?E3), Houston, TX, May 1993.

Haymann?Haber, G., et al. ?An Expert System to Advise Astronauts During
Experiments: The Protocol Manager Module,?E*Proceedings of The Third
Annual Workshop on Space Operations Automation and Robotics (SOAR ?E9)*,
Houston, TX, July 1989.

Hill, T., and Faltisco, R. ?Intelligent Fault Management for the Space
Station Active Thermal Control System,?E*Proceedings of The Fifth Annual
Workshop on Space Operations Applications and Research (SOAR ?E1)*,
Houston, TX, July 1991.

Hipwell, D. P. ?Developing Realistic Cooperative Behaviors for
Autonomous Agents in Air Combat Simuation,?EM.S. Thesis, Air Force
Institute of Technology, Wright Patternson AFB, Ohio, 1993.

Hughes, P. M. ?CLEAR: Automating Control Centers with Expert System
Technology,?E*Proceedings of The Third Annual Workshop on Space
Operations Automation and Robotics (SOAR ?E9)*, Houston, TX, July 1989.

Johnson, W. B., et al. ?An Intelligent Tutoring System for Space Shuttle
Diagnosis,?E*Proceedings of The Second Annual Workshop on Space
Operations Automation and Robotics (SOAR ?E8)*, Albuquerque, NM, July
1988.

Kahn, M. G., et al. ?An Expert System for Culture-Based Infection
Control Surveillance,?E*Proceedings of The Seventeenth Annual Symposium
on Computer Applications in Medical Care* (SCAMC ?E3), Washington, D.C.,
October 1993.

Kingston, J. ?Pragmatic KADS: A methodological approach to a small
knowledge based systems project,?E*Expert Systems: The International
Journal of Knowledge Engineering*, 4, 4, November 1992.

Kosta, C. P., and Krolak, P. D. ?Rapid Prototyping 3D Virtual World
Interfaces within a Virtual Factory Environment,?E*Proceedings of The
Contributed Sessions 1993 Conference on Intelligent Computer Aided
Training and Virtual Environment Technology* (ICAT-VET ?E3), Houston,
TX, May 1993.

Kosta, C. P., and Krolak, P. D. ?An Artificial Reality Environment for
Remote Factory Control and Monitoring,?E*Vision 21: Interdisciplinary
Science and Engineering in the Era of Cyberspace*, NASA/Lewis Research
Center, December 1993.

Kovarik, V. J. ?Autonomously Acquiring Declarative and Procedural Domain
Knowledge for ICAT Systems,?E*Proceedings of The Contributed Sessions
1993 Conference on Intelligent Computer Aided Training and Virtual
Environment Technology* (ICAT-VET ?E3), Houston, TX, May 1993.

Lauriente, M., et al. ?Diagnosing Anomalies of Spacecraft for Space
Maintenance and Servicing,?E*Proceedings of The Seventh Annual Workshop
on Space Operations Applications and Research (SOAR ?E3)*, Houston, TX,
August 1993.

Lee, L., and Hill, R. W., ?Process Control and Recovery in the Link
Monitor and Control Operator Assistant,?E*Proceedings of The Sixth
Annual Workshop on Space Operations Applications and Research (SOAR
?E2)*, Houston, TX, August 1992.

Leinweber, D. ?Finance,?E*Expert Systems and Artificial Intelligence:
Applications and Management,* Howard W. Sams \& Company, Bartee, T. C.
ed., 1988.

Loftin, K. C., et al. ?The Application of Integrated Knowledge?Based
Systems for the Biomedical Risk Accessment Intelligent Network (BRAIN),?E
\sphinxstyleemphasis{Proceedings of Technology 2002: The Third National Technology Transfer
Conference and Exposition}, Washington D.C., February 1993.

Loftin, R. B., and Savely, R.T. ?Intelligent Computer Aided Training and
Tutoring,?E*Proceedings of the Technology 2000 Conference*, Washington,
DC, November 1990.

Loftin, R. B., et al. ?An Intelligent Training System for Space Shuttle
Flight Controllers,?E*Innovative Applications of Artificial
Intelligence*, 1989, AAAI Press/The MIT Press, Menlo Press, Schoor,
Herbert, and Rappaport, Alain ed.

Loftin, R. B., et al. ?An Intelligent Training System for Payload?Assist
Module Deploys,?E*Proceedings of The First Annual Workshop on Space
Operations Automation and Robotics (SOAR ?E7)*, Houston, TX, August
1987.

Lucas, T. S., and Lewis, G. ?DISPLAVAL: An Expert System Approach for
the Training of Display Builders,?E*Proceedings of Contributed Sessions
1991 Conference on Intelligent Computer Aided Training*, Houston, TX,
November 1991.

McCarthy, L., et al. ?Spatial Considerations for Instructional
Development in a Virtual Environment,?E*Proceedings of The Contributed
Sessions 1993 Conference on Intelligent Computer Aided Training and
Virtual Environment Technology* (ICAT-VET ?E3), Houston, TX, May 1993.

?Mission Accomplished,?E*NASA Tech Briefs*, September 1993.

Mitchell, P. ?An Expert System for Shuttle and Satellite Radar Tracker
Scheduling,?E*Proceedings of The Second Annual Workshop on Space
Operations Automation and Robotics (SOAR ?E8)*, Albuquerque, NM, July
1988.

Mitchell, R. ?Expert Systems and Air?Combat Simulation,?E*AI Expert*,
September 1989.

Mortenson, P. ?Predicting Wind Shear from the Dispatch Office,?E*Airline
Executive*, April 1988.

Mueller, S. ?Development of a Personal?Computer?Based Intelligent
Tutoring System,?E*Proceedings of The Second Annual Workshop on Space
Operations Automation and Robotics (SOAR ?E8)*, Albuquerque, NM, July
1988.

Muratore, J., et al. ?Space Shuttle Telemetry Monitoring,?E*Innovative
Applications of Artificial Intelligence*, 1989, AAAI Press/The MIT
Press, Menlo Press, Schoor, Herbert, and Rappaport, Alain ed.

Nash, J. ?Expert Systems: A New Partnership,?E*AI Expert*, December
1992.

Norton, J. E., et al. ?Microcomputer Intelligence for Technical Training
(MITT): The Evolution of an Intelligent Tutoring System,?E*Proceedings
of Contributed Sessions 1991 Conference on Intelligent Computer Aided
Training,* Houston, TX, November 1991.

\sphinxstyleemphasis{Proceedings of the First CLIPS Conference}, Houston, Texas, August
1990.

\sphinxstyleemphasis{Proceedings of the Second CLIPS Conference}, Houston, Texas, September
1991.

\sphinxstyleemphasis{Proceedings of the Third CLIPS Conference}, Houston, Texas, September
1994.

Robey, B., et al. ?The DRAIR Advisor: A Knowledge?Based System for
Materiel Deficiency Analysis,?E*Proceedings of the Fifth Innovative
Applications of Artificial Intelligence Conference*, July 11?E5, 1993,
Washington, D.C.

Robey, B., et al. ?DRAIR Advisor: A Knowledge-Based System for
Materiel-Deficiency Analysis,?E*AI magazine*, Volume 15, No. 2, Summer,
1994.

Rolincik, M, et al. ?An On?line Expert System for Diagnosing
Environmentally Induced Spacecraft Anomalies using CLIPS,?E*Proceedings
of The Sixth Annual Workshop on Space Operations Applications and
Research (SOAR ?E2)*, Houston, TX, August 1992.

Rolincik, M., et al. ?An Expert System for Diagnosing Environmentally
Induced Spacecraft Anomolies,?E*Proceedings of The Fifth Annual Workshop
on Space Operations Applications and Research (SOAR ?E1)*, Houston, TX,
July 1991.

Saito, T., et al. ?Acquiring Knowledge within an ICAT (Intelligent
Computer?Aided Training) Environment: Factors and Issues,?E*Proceedings
of Contributed Sessions 1991 Conference on Intelligent Computer Aided
Training*, Houston, TX, November 1991.

Saito, T., et al. ?On the Acquisition and Representation of Procedural
Knowledge,?E*Proceedings of The Fifth Annual Workshop on Space
Operations Applications and Research (SOAR ?E1)*, Houston, TX, July
1991.

Scholtz, T. ?The State Transition Diagram with Path Priority and it?s
Applications,?EM.S. Thesis, Naval Postgraduate School, Monterey, CA,
September 1993.

Schultz, R. D, and Stobie, I. ?The AI Bus Architecture for Distributed
Knowledge?Based Systems,?E*Proceedings of The Fourth Annual Workshop on
Space Operations Applications and Research (SOAR ?E0)*, Albuquerque, NM,
June 1990.

Spelt, P. F. ?Learning by an Autonomous Robot at a Process Control
Panel,?E*IEEE Expert*, Winter 1989.

\sphinxstyleemphasis{Spinoff 1993}, NASA, pp. 88, 102, 120?E21, 1994.

\sphinxstyleemphasis{Spinoff 1992}, NASA, p. 121, 1993.

\sphinxstyleemphasis{Spinoff 1991}, NASA, pp. 110?E11, 1992.

Swartz, M., et al. ?Intelligent Help for Radar Maintenance
Troubleshooters,?E*Proceedings of Contributed Sessions 1991 Conference
on Intelligent Computer Aided Training*, Houston, TX, November 1991.

Szatkowski, G. P., and Levin, B. E. ?Expert System Decision Support for
Low?cost Launch Vehicle Operations,?E*Proceedings of The Fourth Annual
Workshop on Space Operations Applications and Research (SOAR ?E0)*,
Albuquerque, NM, June 1990.

Truszkowski, W. ?Advances in Knowledge?Based Software Engineering,?E
\sphinxstyleemphasis{Proceedings of the Technology 2001Conference}, San Jose, CA, December
1991.

Wallfesh, S. K. ?Infantry Load Planning with LES,?E*Artificial
Intelligence Applications for Logistics, Aerospace Systems, Robotics \&
Personnel,* American Defense Preparedness Association, WIlliamsburg, VA,
8?E0 March 1993.

Wang, L., and Bochsler, D. ?Space Shuttle Onboard Navigation Console
Expert/Trainer System,?E*Proceedings of The First Annual Workshop on
Space Operations Automation and Robotics (SOAR ?E7)*, Houston, TX,
August 1987.

Warren, K. C., and Goodman, B. A. ?Engineering Intelligent Tutoring
Systems,?EProceedings of The Contributed Sessions 1993 Conference on
Intelligent Computer Aided Training and Virtual Environment Technology
(ICAT-VET ?E3), Houston, TX, May 1993.

Wiederholt, B. J. ?MITT Writer: An Authoring System for Developing
Intelligent Tutors for Complex Technical Domains,?E*Proceedings of
Contributed Sessions 1991 Conference on Intelligent Computer Aided
Training*, Houston, TX, November 1991.

Woods, D. ?Space Station Freedom: Embedding AI,?E*AI Expert*, April
1992.

Enhancements/Implementation

Donnell, B., ?Object/rule Integration in CLIPS,?E*Expert Systems: The
International Journal of Knowledge Engineering and Neural Networks*,
Learned Information, New Jersey, February 1994, Vol. 11, No. 1, ISSN
0266-4720, pp. 29-45.

Franke, J. L., et al. ?A General Purpose Certainty Processing Extension
to CLIPS,?E*Proceedings of The 7th Florida Artificial Intelligence
Research Symposium*, Florida AI Research Society, 1994.

Le, T., and Homeier, P. ?Portable Inference Engine: An Extended CLIPS
for Real?Time Production Systems,?E*Proceedings of The Second Annual
Workshop on Space Operations Automation and Robotics (SOAR ?E8)*,
Albuquerque, NM, July 1988.

Li, Y. P. ?DCLIPS?A Distributed CLIPS Implementation,?E*Proceedings of
the 9th AIAA Computing in Aerospace Conference*, American Institute of
Aeronautics and Astronautics, San Diego, CA, October 1993.

Odette, L. L., \sphinxstyleemphasis{Intelligent Embedded Systems}, Addison?Wesley Publishing
Company, pp.?63?E10,?1991.

Riley, G. ?Implementing CLIPS on a Parallel Computer,?E*Proceedings of
The First Annual Workshop on Space Operations Automation and Robotics
(SOAR ?E7)*, Houston, TX, August 1987.

Riley, G. ?Implementation of an Expert System Shell on a Parallel
Computer,?E*Proceedings of The Third Annual Artificial Intelligence \&
Advanced Computer Technology Conference*, Long Beach Convention Center,
Long Beach, CA, April 1987.

Salzgeber, M. J., et al. ?Managing Uncertainty in CLIPS: A System Level
Approach,?E*Proceedings of The 6th Florida Artificial Intelligence
Research Symposium*, Florida AI Research Society, 1993.

Eick, C. F., et al. ?DALI?A Knowledge Base Management System,?E
\sphinxstyleemphasis{Proceedings of the 1st Conference on Industrial and Engineering
Applications of AI \& Expert Systems}.

Rete Pattern Matching Algorithm

Forgy, C. ?Rete: A Fast Algorithm for the Many Pattern/Many Object
Pattern Match Problem,?EArtificial Intelligence, 19, pp. 17?E7, 1982.

Forgy, C. ?On the Efficient Implementation of Production Systems,?EPh.
D. Thesis, Carnegie-Mellon University, 1979.

Schneier, B. ?The Rete Matching Algorithm,?E*AI Expert*, pp. 24-29,
December 1992.


\chapter{Index}
\label{\detokenize{appendix:index}}\begin{itemize}
\item {} 
\sphinxstylestrong{190}: \sphinxstylestrong{44}? 7?DERIVE 22?NONE 22?self 109, \sphinxstylestrong{110}( 7) 7*

\end{itemize}

\sphinxstylestrong{190}** \sphinxstylestrong{197}/ \sphinxstylestrong{191}\& 7, \sphinxstylestrong{41}+ \sphinxstylestrong{189}\textless{} 7, \sphinxstylestrong{164}\textless{}=
\sphinxstylestrong{165}\textless{}\textgreater{} \sphinxstylestrong{163}= \sphinxstylestrong{46}, \sphinxstylestrong{162=\textgreater{}} \sphinxstylestrong{27}\textgreater{} \sphinxstylestrong{163}\textgreater{}= \sphinxstylestrong{164}\textbar{}
7, \sphinxstylestrong{41}\textasciitilde{} 7, \sphinxstylestrong{41}\$? 7abs \sphinxstylestrong{192}abstraction \sphinxstylestrong{18}action 16,
27, \sphinxstylestrong{159}activated 28active-duplicate-instance 83, 115,
\sphinxstylestrong{130}active-initialize-instance 83, \sphinxstylestrong{124}active-make-instance
83, \sphinxstylestrong{121}, 123active-message-duplicate-instance 83, 115,
\sphinxstylestrong{132}active-message-modify-instance 83, 115,
\sphinxstylestrong{129}active-modify-instance 83, 114, \sphinxstylestrong{128}Ada iv, 8, 9, 15,
16Advanced Programming Guide v, 1, 3, 5, 8, 51, 161, 178, 194, 309agenda
28, \sphinxstylestrong{29}, 33, 62, 289, 290, 291allowed-classes
154allowed-instance-names 155allowed-instances 155ampersand 7and
\sphinxstylestrong{165}antecedent \sphinxstylestrong{15}any-factp \sphinxstylestrong{230}, 324any-instancep 83,
\sphinxstylestrong{139}apropos \sphinxstylestrong{275}arrow \sphinxstylestrong{27}ART iiiArtificial Intelligence
Section iiiassert 11, 22, 83, 211, \sphinxstylestrong{217}, 220, 266assert-string
\sphinxstylestrong{220}attributedefault 22auto-focus \sphinxstylestrong{63}backslash 7, 180, 185,
186, 220Basic Programming Guide iv, v, 1batch 3, 5, \sphinxstylestrong{272}batch* 5,
\sphinxstylestrong{272}bind 39, 65, 83, 110, 126, \sphinxstylestrong{199}bload \sphinxstylestrong{270}, 271,
274bload-instances 307, \sphinxstylestrong{308}break 83, 139, 202, \sphinxstylestrong{204},
230browse-classes \sphinxstylestrong{302}bsave 153, 270, \sphinxstylestrong{271}bsave-instances
\sphinxstylestrong{307}, 308build \sphinxstylestrong{175}, 326C iii, 8, 9, 12, 15, 16,
21call-next-handler 83, 117, 118, \sphinxstylestrong{255}call-next-method 83, 86,
\sphinxstylestrong{241}, 242call-specific-method 75, 83, 86, \sphinxstylestrong{242}carriage return
7case sensitive 7check-syntax 177class 8, \sphinxstylestrong{13}, 78, 258, 299,
302abstract 90, \sphinxstylestrong{95}, 253, 299concrete 91, \sphinxstylestrong{95}, 253existence
\sphinxstylestrong{245}immediate \sphinxstylestrong{95}, 107non-reactive \sphinxstylestrong{95}precedence 93reactive
91, \sphinxstylestrong{95}, 253specific \sphinxstylestrong{92}, 95, 100, 118system \sphinxstylestrong{89}ADDRESS
\sphinxstylestrong{89}EXTERNAL-ADDRESS \sphinxstylestrong{89}FACT-ADDRESS \sphinxstylestrong{89}FLOAT
\sphinxstylestrong{89}INITIAL-OBJECT \sphinxstylestrong{89}INSTANCE \sphinxstylestrong{89}INSTANCE-ADDRESS
\sphinxstylestrong{89}INSTANCE-NAME \sphinxstylestrong{89}INTEGER \sphinxstylestrong{89}LEXEME \sphinxstylestrong{89}MULTIFIELD
\sphinxstylestrong{89}NUMBER \sphinxstylestrong{89}OBJECT \sphinxstylestrong{89}, 92, 302PRIMITIVE \sphinxstylestrong{89}STRING
\sphinxstylestrong{89}SYMBOL \sphinxstylestrong{89}USER \sphinxstylestrong{89}, 92, 112, 124, 257, 306user-defined
8, 14, \sphinxstylestrong{306}class function 240, \sphinxstylestrong{258}class-abstractp
\sphinxstylestrong{247}class-existp \sphinxstylestrong{245}class-reactivep \sphinxstylestrong{247}class-slots
\sphinxstylestrong{248}class-subclasses \sphinxstylestrong{248}class-superclasses \sphinxstylestrong{247}clear 11,
25, 65, 123, 145, 147, 151, 270, \sphinxstylestrong{271}clear-focus-stack
\sphinxstylestrong{292}CLIPS iiiCLOS 75, 89close \sphinxstylestrong{180}command 3, \sphinxstylestrong{159},
269command prompt \sphinxstylestrong{3}comment 7, 10Common Lisp Object System
ivcondition \sphinxstylestrong{16}conditional element \sphinxstylestrong{16}, 25, 27, 33, 62and 27,
33, \sphinxstylestrong{53}exists 33, \sphinxstylestrong{55}forall 33, \sphinxstylestrong{56}logical 33,
\sphinxstylestrong{58}not 33, \sphinxstylestrong{54}or 33, \sphinxstylestrong{52}pattern 27, 33, \sphinxstylestrong{34}literal
\sphinxstylestrong{35}test 30, 33, \sphinxstylestrong{51}conflict resolution strategy 16, \sphinxstylestrong{28},
29, 271, 272, 291breadth \sphinxstylestrong{29}complexity \sphinxstylestrong{30}depth \sphinxstylestrong{29}lex
\sphinxstylestrong{30}mea \sphinxstylestrong{31}random \sphinxstylestrong{32}simplicity \sphinxstylestrong{29}consequent
\sphinxstylestrong{15}conservation 253conserve-mem 270, \sphinxstylestrong{310}constant 3,
\sphinxstylestrong{9}constraint 33, 34, \sphinxstylestrong{41}, 44connective 34, \sphinxstylestrong{41}field
\sphinxstylestrong{34}literal \sphinxstylestrong{35}predicate 34, \sphinxstylestrong{44}, 51return value 34,
\sphinxstylestrong{46}construct 3, \sphinxstylestrong{10}, 175constructs 316constructs-to-c 274, 324,
325convenience 253COOL iv, 8, 14, 17, 18, 19, 75, 78, \sphinxstylestrong{89}, 240, 244,
298create\$ \sphinxstylestrong{166}crlf \sphinxstylestrong{181}daemon \sphinxstylestrong{111}, 121, 137deactivated
28declarative technique \sphinxstylestrong{86}, \sphinxstylestrong{107}, 118declare
\sphinxstylestrong{62}default-dynamic 22defclass 8, 10, \sphinxstylestrong{91}, 105,
\sphinxstylestrong{298}defclass-module \sphinxstylestrong{244}deffacts 10, \sphinxstylestrong{13}, \sphinxstylestrong{25},
283deffacts-module \sphinxstylestrong{234}deffunction \sphinxstylestrong{9}, 10, 16, \sphinxstylestrong{71}, 75, 294,
295action \sphinxstylestrong{72}advantages over generic functions \sphinxstylestrong{341}execution
error \sphinxstylestrong{72}recursion \sphinxstylestrong{72}regular parameter \sphinxstylestrong{71}return value
\sphinxstylestrong{72}wildcard parameter \sphinxstylestrong{71}deffunction-module
\sphinxstylestrong{238}defgeneric 10, \sphinxstylestrong{75}, 76defgeneric-module \sphinxstylestrong{239}defglobal
10, \sphinxstylestrong{15}, \sphinxstylestrong{65}, 293defglobal-module \sphinxstylestrong{238}definstances 10,
\sphinxstylestrong{15}, 91, \sphinxstylestrong{122}, 305initial-object \sphinxstylestrong{91}definstances-module
\sphinxstylestrong{256}defmessage-handler 10, 105, \sphinxstylestrong{106}, \sphinxstylestrong{303}defmethod 10,
\sphinxstylestrong{75}, 76defmodule 10, \sphinxstylestrong{145}, 308, \sphinxstylestrong{309}defmodules 17defrule 10,
\sphinxstylestrong{27}, \sphinxstylestrong{283}defrule-module \sphinxstylestrong{235}deftemplate 10, \sphinxstylestrong{12}, \sphinxstylestrong{21},
279deftemplate fact \sphinxstylestrong{12}, 21, 220deftemplate-module
\sphinxstylestrong{212}deftemplate-slot-allowed-values \sphinxstylestrong{212},
322deftemplate-slot-cardinality \sphinxstylestrong{212}, 322deftemplate-slot-defaultp
\sphinxstylestrong{213}, 322deftemplate-slot-default-value \sphinxstylestrong{214},
322deftemplate-slot-existp \sphinxstylestrong{214}, 322deftemplate-slot-multip \sphinxstylestrong{215},
322deftemplate-slot-names \sphinxstylestrong{215}, 322deftemplate-slot-range \sphinxstylestrong{216},
322deftemplate-slot-singlep \sphinxstylestrong{216}, 323deftemplate-slot-type
323deftemplate-slot-types \sphinxstylestrong{216}deg-grad \sphinxstylestrong{195}deg-rad
\sphinxstylestrong{195}delayed-do-for-all-facts 230, \sphinxstylestrong{233},
324delayed-do-for-all-instances 83, 139, \sphinxstylestrong{142}, 204, 327delete\$
\sphinxstylestrong{168}delete-instance 126, \sphinxstylestrong{257}delete-member\$ \sphinxstylestrong{172}delimiter
\sphinxstylestrong{7}dependencies \sphinxstylestrong{289}dependents \sphinxstylestrong{289}describe-class 92,
\sphinxstylestrong{299}direct-insert\$ \sphinxstylestrong{262}div \sphinxstylestrong{191}do-for-all-facts 230,
\sphinxstylestrong{232}, 233, 324do-for-all-instances 83, 139, \sphinxstylestrong{141}, 142, 204,
327do-for-fact 230, \sphinxstylestrong{232}, 324do-for-instance 83, 139, \sphinxstylestrong{141}, 204,
327double quote 7dribble-off \sphinxstylestrong{276}dribble-on \sphinxstylestrong{275}duplicate 11,
13, 23, 83, \sphinxstylestrong{220}, 266duplicate-instance 83, 115, \sphinxstylestrong{130}dynamic
binding \sphinxstylestrong{18}dynamic-get 125, \sphinxstylestrong{260}, 371dynamic-put 125, \sphinxstylestrong{261},
371embedded application 5encapsulation \sphinxstylestrong{18}, 89, 109,
120EnvFalseSymbol 325EnvTrueSymbol 325EOF \sphinxstylestrong{182}, 183, \sphinxstylestrong{187}eq
\sphinxstylestrong{161}eval \sphinxstylestrong{175}, 326evenp \sphinxstylestrong{160}exit 4, 180, \sphinxstylestrong{271}exp
\sphinxstylestrong{197}expand\$ 83, 108, 266, 325explode\$ \sphinxstylestrong{168}exponential notation
6exporting constructs 147expression \sphinxstylestrong{10}external-address 6, \sphinxstylestrong{8},
9, 181-f 4-f2 5facet 91, \sphinxstylestrong{96}, 299accessinitialize-only
\sphinxstylestrong{98}read-only \sphinxstylestrong{98}read-write \sphinxstylestrong{98}create-accessor \sphinxstylestrong{103},
253, 326?NONE \sphinxstylestrong{103}read \sphinxstylestrong{103}read-write \sphinxstylestrong{103}write
\sphinxstylestrong{103}default \sphinxstylestrong{96}default-dynamic \sphinxstylestrong{96}multislot
\sphinxstylestrong{96}override-message \sphinxstylestrong{104}pattern-matchnon-reactive
\sphinxstylestrong{101}reactive \sphinxstylestrong{101}propagationinherit \sphinxstylestrong{99}no-inherit 95,
\sphinxstylestrong{99}shared 96single-slot \sphinxstylestrong{96}slot \sphinxstylestrong{96}sourcecomposite 95,
\sphinxstylestrong{100}exclusive \sphinxstylestrong{100}storagelocal \sphinxstylestrong{97}shared
\sphinxstylestrong{97}visibility \sphinxstylestrong{102}private \sphinxstylestrong{102}public \sphinxstylestrong{102}fact
\sphinxstylestrong{11}, 13, 25, 280fact identifier \sphinxstylestrong{11}fact-address 6, 8, 9, \sphinxstylestrong{11},
50, 181, 227fact-existp \sphinxstylestrong{222}fact-index \sphinxstylestrong{11}, 23, 218, 219, 220,
\sphinxstylestrong{221}, 289fact-list \sphinxstylestrong{11}, 13, 25, 27fact-relation \sphinxstylestrong{222}facts
\sphinxstylestrong{280}fact-set \sphinxstylestrong{226}action 229distributed action \sphinxstylestrong{229}member
\sphinxstylestrong{226}member variable \sphinxstylestrong{226}, 229query \sphinxstylestrong{228}, 229query execution
error \sphinxstylestrong{230}query functions \sphinxstylestrong{230}template \sphinxstylestrong{226}template
restriction \sphinxstylestrong{226}fact-slot-names \sphinxstylestrong{222}fact-slot-value
\sphinxstylestrong{223}FALSE 44FalseSymbol 325fetch \sphinxstylestrong{312}, 324ff 181field \sphinxstylestrong{9},
12find-all-facts \sphinxstylestrong{231}, 233, 324find-all-instances 83, \sphinxstylestrong{140},
142find-fact \sphinxstylestrong{231}, 324find-instance 83, \sphinxstylestrong{140}fire 27first\$
\sphinxstylestrong{171}float 6, 8, \sphinxstylestrong{193}floatp \sphinxstylestrong{159}focus 28, 63, 151,
\sphinxstylestrong{291}foreach 83, 204, \sphinxstylestrong{206}, 266, 322format \sphinxstylestrong{183}, 188,
323FORTRAN 9funcall \sphinxstylestrong{211}, 324, 325, 327function 3, \sphinxstylestrong{9}, 16, 75,
138, 159, 229call 3, \sphinxstylestrong{10}external 5, 39, 46, 51predicate \sphinxstylestrong{44}, 51,
159, 259reserved names \sphinxstylestrong{393}system defined \sphinxstylestrong{9}, 393user defined 8,
\sphinxstylestrong{9}, 51, 378generic dispatch \sphinxstylestrong{75}, 76, 79, \sphinxstylestrong{81}, 341generic
function 14, 16, 17, \sphinxstylestrong{75}, \sphinxstylestrong{295}disadvantages \sphinxstylestrong{341}header 76,
\sphinxstylestrong{77}order dependence \sphinxstylestrong{76}ordering of method parameter
restrictions \sphinxstylestrong{341}performance penalty \sphinxstylestrong{76}return value
\sphinxstylestrong{87}gensym \sphinxstylestrong{207}, 208gensym* 121, 129, \sphinxstylestrong{207},
208get-auto-float-dividend \sphinxstylestrong{274}get-char \sphinxstylestrong{186},
323get-class-defaults-mode \sphinxstylestrong{253}, 327get-current-module
\sphinxstylestrong{263}get-defclass-list \sphinxstylestrong{244}get-deffacts-list
\sphinxstylestrong{234}get-deffunction-list \sphinxstylestrong{238}get-defgeneric-list
\sphinxstylestrong{239}get-defglobal-list \sphinxstylestrong{237}GetDefglobalValue
325get-definstances-list \sphinxstylestrong{256}get-defmessage-handler-list
\sphinxstylestrong{248}get-defmethod-list \sphinxstylestrong{239}get-defmodule-list
\sphinxstylestrong{263}get-defrule-list \sphinxstylestrong{235}get-deftemplate-list
\sphinxstylestrong{217}get-dynamic-constraint-checking \sphinxstylestrong{274}get-fact-duplication
\sphinxstylestrong{282}get-fact-list \sphinxstylestrong{224}get-focus \sphinxstylestrong{236}get-focus-stack
\sphinxstylestrong{236}get-function-restrictions 83, \sphinxstylestrong{210}get-incremental-reset
\sphinxstylestrong{288}get-method-restrictions 83, \sphinxstylestrong{243}GetNextFactInTemplate
324get-profile-percent-threshold 315get-region \sphinxstylestrong{314},
323get-reset-globals \sphinxstylestrong{294}get-salience-evaluation
\sphinxstylestrong{292}get-sequence-operator-recognition
\sphinxstylestrong{267}get-static-constraint-checking \sphinxstylestrong{275}get-strategy
\sphinxstylestrong{291}grad-deg \sphinxstylestrong{195}halt \sphinxstylestrong{291}help 322help-path 322I/O router
178if 83, \sphinxstylestrong{200}, 266if portion \sphinxstylestrong{15}imperative technique \sphinxstylestrong{86},
\sphinxstylestrong{107}, 118implode\$ \sphinxstylestrong{169}importing constructs 147incremental reset
28, 272, 288Inference Corporation iiiinference engine \sphinxstylestrong{16}, 27,
28inheritance 14, \sphinxstylestrong{18}, 91, 95class precedence list \sphinxstylestrong{19}, 91,
\sphinxstylestrong{92}, 93, 95, 100, 118, 299class precedence list 106is-a 92multiple
14, \sphinxstylestrong{19}, 89, \sphinxstylestrong{92}, \sphinxstylestrong{93}, 302initialize-instance 83, 97, 104, 112,
\sphinxstylestrong{124}, 257init-slots 112, 121, 124, \sphinxstylestrong{257}insert\$ \sphinxstylestrong{170}instance
8, \sphinxstylestrong{13}, \sphinxstylestrong{14}, 15, 95, 97, 299, \sphinxstylestrong{306}active \sphinxstylestrong{109}, 116, 118,
125, 126, 257, 260, 306creation 116, \sphinxstylestrong{120}deletion 113direct 90, 91,
\sphinxstylestrong{95}, 99initialization 112, 120, 124, 257manipulation
\sphinxstylestrong{120}printing 113instance-address 6, \sphinxstylestrong{8}, 9, 50, 181, 258, 259,
341instance-addressp \sphinxstylestrong{260}instance-existp 260instance-list 15,
27instance-name 6, \sphinxstylestrong{8}, 135, \sphinxstylestrong{258}, 259, \sphinxstylestrong{260}instance-namep
260instance-name-to-symbol \sphinxstylestrong{259}instancep \sphinxstylestrong{259}instances
\sphinxstylestrong{306}instance-set \sphinxstylestrong{135}action 138class restriction
\sphinxstylestrong{135}distributed action \sphinxstylestrong{137}member \sphinxstylestrong{135}member variable
\sphinxstylestrong{135}, 138query 19, \sphinxstylestrong{137}, 138, 341query execution error
\sphinxstylestrong{139}query functions \sphinxstylestrong{139}template \sphinxstylestrong{135}integer 6, 8,
\sphinxstylestrong{193}integerp \sphinxstylestrong{159}integration 5Interfaces Guide v, 3Jess 207-l
5left-hand side \sphinxstylestrong{15}length \sphinxstylestrong{209}length\$ 96, 108, \sphinxstylestrong{172},
209less than 7lexemep \sphinxstylestrong{160}LHS \sphinxstylestrong{27}line feed 7LISP iii,
15list-defclasses 298list-deffacts \sphinxstylestrong{283}list-deffunctions
\sphinxstylestrong{295}list-defgenerics \sphinxstylestrong{296}list-defglobals
\sphinxstylestrong{293}list-definstances \sphinxstylestrong{305}list-defmessage-handlers
\sphinxstylestrong{303}list-defmethods 77, 83, 84, \sphinxstylestrong{296}, 297list-defmodules
\sphinxstylestrong{309}list-defrules \sphinxstylestrong{284}list-deftemplates
\sphinxstylestrong{279}list-focus-stack \sphinxstylestrong{292}list-watch-items \sphinxstylestrong{278}load 5,
\sphinxstylestrong{269}, 270, 272load* \sphinxstylestrong{269}load-facts \sphinxstylestrong{280}LoadFactsFromString
326load-instances \sphinxstylestrong{308}local 281log \sphinxstylestrong{197}log10 \sphinxstylestrong{198}logical
name \sphinxstylestrong{179}, 275nil 181, 183stdin 182, 183, 186, 187, 275stdout 181,
183, 275t 181, 182, 183, 186, 187wclips 275wdialog 275wdisplay 275werror
275wtrace 275wwarning 275logical support \sphinxstylestrong{58}, 218, 219,
289loop-for-count 83, \sphinxstylestrong{202}, 204, 266lowcase \sphinxstylestrong{176}make-instance 8,
48, 83, 95, 97, 99, 104, 112, \sphinxstylestrong{120}, 122, 257, 308matches
\sphinxstylestrong{285}math functions \sphinxstylestrong{189}, \sphinxstylestrong{194}max
\sphinxstylestrong{192}max-number-of-elements 156member\$ \sphinxstylestrong{167}, 326mem-requests
\sphinxstylestrong{309}mem-used \sphinxstylestrong{309}message 14, 16, \sphinxstylestrong{17}, 18, 19, 75, 89, 97,
106, 108, 109, 116, 118, \sphinxstylestrong{120}, 121, 124dispatch \sphinxstylestrong{107}execution
error 108, 118, 254execution error \sphinxstylestrong{119}implementation \sphinxstylestrong{106},
107return value \sphinxstylestrong{120}message dispatch
\sphinxstylestrong{116}message-duplicate-instance 83, 104, 115,
\sphinxstylestrong{131}message-handler 14, 16, \sphinxstylestrong{17}, 19, 76, 89, 91, 92, 99,
\sphinxstylestrong{106}, 109, 118, 120, 125, 199, 257, 299, 306, 341action
\sphinxstylestrong{109}applicability 107, 108, 116, \sphinxstylestrong{118}, \sphinxstylestrong{304}documentation
\sphinxstylestrong{105}existence \sphinxstylestrong{246}forward declaration \sphinxstylestrong{105}regular
parameter \sphinxstylestrong{108}return value \sphinxstylestrong{120}shadow \sphinxstylestrong{118}, 254specific
116, 118, 120systemcreate \sphinxstylestrong{116}, 120, 121, 326delete \sphinxstylestrong{113}, 121,
122, \sphinxstylestrong{126}, 129direct-duplicate \sphinxstylestrong{115}, 130direct-modify \sphinxstylestrong{114},
127, 128init 99, \sphinxstylestrong{112}, 120, 121, 124, 256message-duplicate \sphinxstylestrong{115},
131, 132message-modify \sphinxstylestrong{115}, 128, 129print \sphinxstylestrong{113}typeafter
\sphinxstylestrong{106}, 118, 120around \sphinxstylestrong{106}, 118, 120, 254before \sphinxstylestrong{106}, 118,
120primary \sphinxstylestrong{106}, 118, 120wildcard parameter
\sphinxstylestrong{108}message-handler-existp \sphinxstylestrong{246}message-modify-instance 83,
104, 115, \sphinxstylestrong{128}method 17, \sphinxstylestrong{75}, 76, 89action \sphinxstylestrong{76}applicability
\sphinxstylestrong{79}, 86, 297execution error \sphinxstylestrong{86}, 240explicit \sphinxstylestrong{75}, 79,
\sphinxstylestrong{82}implicit \sphinxstylestrong{75}, 76, 79index \sphinxstylestrong{77}, 296parameter query
restriction \sphinxstylestrong{78}parameter restriction 76, 77, \sphinxstylestrong{78}, 82,
84parameter type restriction \sphinxstylestrong{78}precedence 78, 79, \sphinxstylestrong{84},
296regular parameter \sphinxstylestrong{78}, 79return value \sphinxstylestrong{87}shadow \sphinxstylestrong{86}, 240,
304wildcard parameter \sphinxstylestrong{79}wildcard parameter restriction 76min
\sphinxstylestrong{192}min-number-of-elements 156mod \sphinxstylestrong{198}modify 11, 13, 23, 83,
\sphinxstylestrong{219}, 266modify-instance 83, 114, \sphinxstylestrong{127}module specifier
147multifield value 8, \sphinxstylestrong{9}multifield wildcard 36multifieldp
\sphinxstylestrong{161}named fields \sphinxstylestrong{12}NASA iiineq \sphinxstylestrong{162}next-handlerp 83,
\sphinxstylestrong{254}next-methodp 83, \sphinxstylestrong{240}non-FALSE 44non-ordered fact \sphinxstylestrong{12},
21not \sphinxstylestrong{166}nth\$ 96, \sphinxstylestrong{166}numberp \sphinxstylestrong{159}object 8, \sphinxstylestrong{13}, 17,
18behavior \sphinxstylestrong{13}, 16, \sphinxstylestrong{17}, 18, 75, 91, \sphinxstylestrong{106}, 107primitive type
\sphinxstylestrong{14}properties \sphinxstylestrong{13}, 14, 17, \sphinxstylestrong{18}, \sphinxstylestrong{91}reference \sphinxstylestrong{8}, 13,
19object-pattern-match-delay 48, 83, \sphinxstylestrong{126}, 266oddp \sphinxstylestrong{161}off
316open \sphinxstylestrong{179}, 180operating-system \sphinxstylestrong{211}, 322OPS5 30options
\sphinxstylestrong{273}or \sphinxstylestrong{165}ordered fact \sphinxstylestrong{12}, 21overload 10, \sphinxstylestrong{17}, 71,
\sphinxstylestrong{75}, 76, 341override-next-handler 83, 117, 118,
\sphinxstylestrong{255}override-next-method 83, 86, \sphinxstylestrong{241}, 242parenthesis 7,
10Pascal 12, 16, 21pattern \sphinxstylestrong{16}, 27pattern entity
\sphinxstylestrong{27}pattern-address 50pattern-matching \sphinxstylestrong{16}, 65, 66performance
\sphinxstylestrong{339}pi \sphinxstylestrong{196}pointerp \sphinxstylestrong{161}polymorphism \sphinxstylestrong{18}pop-focus
\sphinxstylestrong{237}ppdefclass \sphinxstylestrong{298}ppdeffacts \sphinxstylestrong{283}ppdeffunction
\sphinxstylestrong{295}ppdefgeneric \sphinxstylestrong{295}ppdefglobal \sphinxstylestrong{293}ppdefinstances
\sphinxstylestrong{305}ppdefmessage-handler \sphinxstylestrong{303}ppdefmethod \sphinxstylestrong{296}ppdefmodule
\sphinxstylestrong{309}ppdefrule 147, 271, \sphinxstylestrong{284}ppdeftemplate \sphinxstylestrong{279}ppfact
\sphinxstylestrong{282}, 323ppinstance \sphinxstylestrong{306}pprule 284prefix notation
10preview-generic \sphinxstylestrong{297}preview-send \sphinxstylestrong{304}printout \sphinxstylestrong{181}, 183,
327print-region \sphinxstylestrong{313}profile 316profile-info 315, 316profile-reset
315progn 83, 126, 138, \sphinxstylestrong{203}, 204, 266, 316, 327progn\$ 83, \sphinxstylestrong{203},
204, 207, 266, 326quote 7rad-deg \sphinxstylestrong{196}random \sphinxstylestrong{208}, 327read 178,
\sphinxstylestrong{182}, 183, 272readline \sphinxstylestrong{182}, 272read-number \sphinxstylestrong{187}, 188,
323Reference Manual v, viirefresh \sphinxstylestrong{288}refresh-agenda
\sphinxstylestrong{292}release-mem \sphinxstylestrong{310}remove \sphinxstylestrong{186}remove-break
\sphinxstylestrong{287}rename \sphinxstylestrong{185}replace\$ \sphinxstylestrong{170}replace-member\$
\sphinxstylestrong{172}reset 11, 13, 15, 25, 65, 91, 120, 122, 151, 159, 271, 272,
283, 294rest\$ \sphinxstylestrong{171}restore-instances \sphinxstylestrong{308}RETE algorithm
\sphinxstylestrong{339}retract 11, 50, \sphinxstylestrong{218}return 28, 83, 139, 151, 202, \sphinxstylestrong{204},
230, 266RHS \sphinxstylestrong{27}right-hand side \sphinxstylestrong{15}round \sphinxstylestrong{198}roundoff
6RtnArgCount 326rule \sphinxstylestrong{15}, \sphinxstylestrong{27}run 151, \sphinxstylestrong{290}, 291salience 28,
29, \sphinxstylestrong{62}, 292dynamic 28, \sphinxstylestrong{63}, 292save \sphinxstylestrong{270}, 310, 326save-facts
\sphinxstylestrong{281}save-instances \sphinxstylestrong{307}, 308scientific math functions
\sphinxstylestrong{194}seed 33, \sphinxstylestrong{209}semicolon 7, 10send 17, 19, 106, 116, 119,
120, 304, 341sequence expansion 39sequencep 161set-auto-float-dividend
191, \sphinxstylestrong{274}set-break \sphinxstylestrong{287}set-class-defaults-mode \sphinxstylestrong{253}, 326,
327set-current-module 147, \sphinxstylestrong{263}, 290set-dynamic-constraint-checking
23, 105, 153, 271, \sphinxstylestrong{274}set-fact-duplication \sphinxstylestrong{281}setgen
\sphinxstylestrong{208}set-incremental-reset \sphinxstylestrong{288}set-locale 187, \sphinxstylestrong{188},
323set-profile-percent-threshold 315set-reset-globals 65,
\sphinxstylestrong{294}set-salience-evaluation 63,
\sphinxstylestrong{292}set-sequence-operator-recognition
\sphinxstylestrong{267}set-static-constraint-checking 23, 105, 153,
\sphinxstylestrong{274}set-strategy 29, 159, \sphinxstylestrong{291}show-breaks
\sphinxstylestrong{288}show-defglobals \sphinxstylestrong{294}significant digits 6single-field value
\sphinxstylestrong{9}single-field wildcard 36slot \sphinxstylestrong{12}, 14, 19, 91, 92, \sphinxstylestrong{95}, 100,
120, 245, 299access 98, 103, 245, 246accessor \sphinxstylestrong{103},
137put-\textless{}slot-name\textgreater{} 121default value 96, 97, 121, 124, 257, 307direct
access \sphinxstylestrong{110}, 125, 137, 199existence \sphinxstylestrong{245}facet 96,
\sphinxstylestrong{100}inheritance propagation 99multifield \sphinxstylestrong{261}overlay
\sphinxstylestrong{100}override 99visibility \sphinxstylestrong{246}slot daemons
341slot-allowed-classes \sphinxstylestrong{254}, 323slot-allowed-values
\sphinxstylestrong{251}slot-cardinality \sphinxstylestrong{251}slot-default-value
\sphinxstylestrong{252}slot-delete\$ \sphinxstylestrong{262}slot-direct-accessp
\sphinxstylestrong{246}slot-direct-delete\$ \sphinxstylestrong{262}slot-direct-replace\$
\sphinxstylestrong{261}slot-existp \sphinxstylestrong{245}slot-facets \sphinxstylestrong{249}slot-initablep
\sphinxstylestrong{246}slot-insert\$ 96, \sphinxstylestrong{262}slot-override 121, 124, 257,
307slot-publicp \sphinxstylestrong{246}slot-range \sphinxstylestrong{252}slot-replace\$
\sphinxstylestrong{261}slot-sources \sphinxstylestrong{250}slot-types \sphinxstylestrong{250}slot-writablep
\sphinxstylestrong{246}, 325Smalltalk iv, 75, 89sort \sphinxstylestrong{210}, 327space 7specificity
\sphinxstylestrong{29}sqrt \sphinxstylestrong{196}standard math functions \sphinxstylestrong{189}str-cat
\sphinxstylestrong{173}str-compare \sphinxstylestrong{176}str-index \sphinxstylestrong{174}string 6, \sphinxstylestrong{7},
8stringp \sphinxstylestrong{160}string-to-field \sphinxstylestrong{178}, 327str-length
\sphinxstylestrong{177}subclass \sphinxstylestrong{92}, 116, 245, 299, 302subclassp \sphinxstylestrong{245}subseq\$
\sphinxstylestrong{169}subsetp \sphinxstylestrong{167}sub-string \sphinxstylestrong{174}superclass 91, \sphinxstylestrong{92}, 95,
106, 245, 299direct \sphinxstylestrong{92}superclassp \sphinxstylestrong{245}switch 83, \sphinxstylestrong{205},
266, 327symbol 6, \sphinxstylestrong{7}, 8, 258, 259reserved 12and 12declare 12exists
12forall 12logical 12not 12object 12or 12test 12symbolp
\sphinxstylestrong{160}symbol-to-instance-name \sphinxstylestrong{259}sym-cat \sphinxstylestrong{173}system
\sphinxstylestrong{273}tab 7, 181template 219then portion \sphinxstylestrong{15}tilde 7time
\sphinxstylestrong{209}timer \sphinxstylestrong{211}timer 327top level \sphinxstylestrong{3}toss
\sphinxstylestrong{315}trigonometric math functions \sphinxstylestrong{194}TrueSymbol 325truth
maintenance \sphinxstylestrong{58}type function \sphinxstylestrong{240}, 258unconditional support
\sphinxstylestrong{58}undefclass \sphinxstylestrong{298}undeffacts \sphinxstylestrong{283}undeffunction
\sphinxstylestrong{295}undefgeneric \sphinxstylestrong{296}undefglobal 65, \sphinxstylestrong{293}undefinstances
\sphinxstylestrong{306}undefmessage-handler \sphinxstylestrong{304}undefmethod \sphinxstylestrong{297}undefrule
147, \sphinxstylestrong{284}undeftemplate \sphinxstylestrong{279}unmake-instance 50,
\sphinxstylestrong{257}unwatch \sphinxstylestrong{278}upcase \sphinxstylestrong{176}User?s Guide v,
viiuser-functions 316value \sphinxstylestrong{9}variable 5, 7, \sphinxstylestrong{9}, 11, 15, 34, 35,
38, 54, 175, \sphinxstylestrong{199}global 3, 15, 62, \sphinxstylestrong{65}, 199, 271vertical bar
7visible 281vtab 181watch \sphinxstylestrong{276}, 278watch itemactivations 28,
\sphinxstylestrong{277}all \sphinxstylestrong{277}compilations 269, \sphinxstylestrong{276}deffunctions
\sphinxstylestrong{277}facts 217, 218, \sphinxstylestrong{276}focus \sphinxstylestrong{277}generic-functions
\sphinxstylestrong{277}globals 65, \sphinxstylestrong{277}instances \sphinxstylestrong{277}message-handlers
\sphinxstylestrong{277}messages \sphinxstylestrong{277}methods \sphinxstylestrong{277}rules \sphinxstylestrong{277}, 290slots
\sphinxstylestrong{277}statistics \sphinxstylestrong{277}, 290while 83, \sphinxstylestrong{201}, 266wildcard 34, 35,
\sphinxstylestrong{36}wordp 160


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}